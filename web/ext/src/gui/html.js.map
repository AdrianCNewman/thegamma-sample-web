{"version":3,"sources":["../../../src/gui/html.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;4CAAA;AAAA;;AAAA;AAAA;AAAA,G;;;;kCAAA;AAAA;;AAAA;AAAA;AAAA,G;;;;AAAA;;AA2BQ;AAAA,qCAKF;AAAA,kCAAW,WAAX;AACS;AACT,cAAiB,wCAAR;AAAA;AAAA,iBAAT;AAFA,kBAGuB;AAAA;AAAU,OAHjC;AAGkC,KAHlC,EALE,0BAWE;AAAK;AAAL,kBACmB;AAAA;AAAO,OAD1B;AAAE,KAAF,EAXF,6BAeE;AAAK;AACA,kCAAU;AAAA;AAAA,OAAV;;AACT;AAAA;AAAkB;AAA2B;;AAFzC;AAGJ;;AACQ,4CAEQ;AAAA,6CAA6C;AAAC,uCAAD;AAAM,WAAnD;AAAqD,SAF7D,MACW;AAAA;AAAqB;AALpC;;AAGJ;AAAA;AAGqE;;AAEnE;AAAA;AAAA;;AAAkB;AAAG;;AAChB,+BAAwB;AAAA;AAAI,SAA5B;AATH;;AASG;AAAA;AAAA;AAAA;AAAA;AAA6B,SAA7B;AAA6B,OADlC;;AARE;AAAE,KAAF,EAfF,IAEF,uCAFE;AAAA;AAAA;AAAI;;AA4BV;AAAA,WAAM,sBAAN,EAA2C;AAAA;AAAgC;;AAC/D;AACZ;AACA;AAAG;;AAEQ;AAAA;AAAO;;;eACF,iC;;;;eACC,8B;;;;AA9DnB;AAAA;AAAA;;kDAmEQ;AAAA;AAAA;AACF,6BAAG,cAAH,0BAEE;AAAA;;AACY,oJACJ;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA,kDACO;AAAA,6CAAmB;AAAA;AAAc,iBAAjC;AAAkC;AADxC;AAEE,WANb;AAQF,0DAAW,aAAX,EAA2B,aAA3B;AATQ,SAAJ;AAAA;AAAI,K;;+CAYR;AAAA;AAAU,K;;qDAGN;AAAM;AAAN;AAAA;AAAA;;AAKI;AAAA;;AAAA;;AAAA;AAAA;AAAA;AACJ;AAAS;;AAAU,eAAW;AAAA;AAAW,eAAtB;AADf;AAAmB,WAAnB;AAAA;AAAmB;AAAA,SAAnB;AAAA;AAAmB;AAAA,OAAnB;;AAGR,gCAAyB;AAAA,gBAAS,cAAT;AAAuB;AAAS,OAAzD;;AARI,cAUJ;AAAA;AAAW,OAVP,EAYF;AAAA;AACA,oCACE;AAAA;AACA;AAAQ,SAFV;AAEY,OAfV;AAAG,K;;;;;;;AAlFX,sBAmGQ,QAnGR","file":"html.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/gui","sourcesContent":["ï»¿module TheGamma.Html\r\nmodule FsOption = FSharp.Core.Option\r\nopen Fable.Import.Browser\r\nopen Fable.Core\r\n\r\n[<Fable.Core.Emit(\"jQuery($0).chosen()\")>]\r\nlet private chosen (el:HTMLElement) : unit = failwith \"JS\"\r\n\r\n[<Fable.Core.Emit(\"jQuery($0).on($1, $2)\")>]\r\nlet private on (el:HTMLElement) (evt:string) (f:unit -> unit) : unit = failwith \"JS\"\r\n\r\n[<Fable.Core.Emit(\"event\")>]\r\nlet private event () : Event = failwith \"JS\"\r\n\r\ntype DomAttribute = \r\n  | Event of (HTMLElement -> Event -> unit)\r\n  | Property of string\r\n\r\ntype DomNode = \r\n  | Text of string\r\n  | Delayed of (string -> unit)\r\n  | Element of tag:string * attributes:(string * DomAttribute)[] * children : DomNode[] * onRender : (HTMLElement -> unit) option\r\n  | Part of func:(HTMLElement -> unit)\r\n\r\nlet mutable counter = 0\r\n\r\nlet rec render node = \r\n  match node with\r\n  | Text(s) -> \r\n      document.createTextNode(s) :> Node, ignore\r\n\r\n  | Delayed(func) ->\r\n      counter <- counter + 1\r\n      let el = document.createElement(\"div\")\r\n      el.id <- sprintf \"delayed_%d\" counter\r\n      el :> Node, (fun () -> func el.id)\r\n\r\n  | Part(func) ->\r\n      let el = document.createElement(\"div\")\r\n      el :> Node, (fun () -> func el)\r\n\r\n  | Element(tag, attrs, children, f) ->\r\n      let el = document.createElement(tag)\r\n      let rc = Array.map render children\r\n      for c, _ in rc do el.appendChild(c) |> ignore\r\n      for k, a in attrs do \r\n        match a with\r\n        | Property(v) -> el.setAttribute(k, v)\r\n        | Event(f) -> el.addEventListener(k, U2.Case1(EventListener(f el)))\r\n      let onRender () = \r\n        for _, f in rc do f()\r\n        f |> FsOption.iter (fun f -> f el)\r\n      el :> Node, onRender\r\n\r\nlet renderTo (node:HTMLElement) dom = \r\n  while box node.lastChild <> null do ignore(node.removeChild(node.lastChild))\r\n  let el, f = render dom\r\n  node.appendChild(el) |> ignore\r\n  f()\r\n  \r\nlet text s = Text(s)\r\nlet (=>) k v = k, Property(v)\r\nlet (=!>) k f = k, Event(f)\r\n\r\n\r\ntype El() = \r\n  static member (?) (_:El, n:string) = fun a b ->\r\n    let n, f = \r\n      if n <> \"chosen\" then n, None\r\n      else \"select\", Some (fun el ->\r\n        chosen el\r\n        for k, v in a do\r\n          match v with\r\n          | Event f -> on el k (fun () -> f el (event()))\r\n          | _ -> ()\r\n      )\r\n    Element(n, Array.ofList a, Array.ofList b, f)\r\n\r\n  member x.delayed(f) =\r\n    Delayed(f)\r\n\r\n  member x.part (initial:'State) (fold:'State -> 'Event -> 'State) = \r\n    let evt = Control.Event<_>()\r\n    let mutable state = initial\r\n    let mutable container = None\r\n    let mutable renderer = None\r\n    let render () =\r\n      match container, renderer with\r\n      | Some el, Some r -> r state |> renderTo el\r\n      | _ -> ()\r\n    evt.Publish.Add(fun e -> state <- fold state e; render ())\r\n\r\n    evt.Trigger,\r\n    fun (r:'State -> DomNode) ->\r\n      renderer <- Some r\r\n      Part(fun el -> \r\n        container <- Some el\r\n        render() )\r\n\r\nlet h = El()\r\n"]}