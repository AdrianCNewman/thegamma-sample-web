{"version":3,"sources":["../../../src/main/main.fsx"],"names":[],"mappings":"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","file":"main.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/main","sourcesContent":["﻿#r \"../../node_modules/fable-core/Fable.Core.dll\"\r\n#r \"../libraries/bin/Debug/libraries.dll\"\r\n#r \"../thegamma/bin/Debug/thegamma.dll\"\r\n#r \"../bindings/bin/Debug/bindings.dll\"\r\n#r \"../gui/bin/Debug/gui.dll\"\r\nopen Fable.Core.Extensions\r\nopen Fable.Import\r\nopen Fable.Import.Browser\r\nmodule FsOption = Microsoft.FSharp.Core.Option\r\n\r\nopen TheGamma\r\nopen TheGamma.Html\r\n//open TheGamma.Babel\r\nopen TheGamma.Common\r\nopen TheGamma.TypeChecker\r\nopen Fable.Core\r\n \r\nFable.Import.Node.require.Invoke(\"core-js\") |> ignore\r\n\r\n[<Emit(\"$0.setCustomValidity($1)\")>]\r\nlet setCustomValidity (el:obj) (msg:string) : unit = failwith \"JS\"\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Global provided types\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nlet services = \r\n  if isLocalHost() then \"http://127.0.0.1:10042/\"\r\n  else \"http://thegamma-services.azurewebsites.net/\"\r\n\r\ntype ProvidedTypes = \r\n  { LookupNamed : string -> Type list -> Type\r\n    Globals : list<string * Metadata list * Babel.Expression * Type> }\r\n    \r\nlet types = async {\r\n  let mutable named = Map.empty\r\n  let lookupNamed n tyargs = \r\n    match named.TryFind(n) with\r\n    | Some(r, tya) -> \r\n        if List.length tya <> List.length tyargs then \r\n          Log.error(\"Named type '%s' has mismatching length of type arguments\", n)\r\n          failwith (sprintf \"Named type '%s' has mismatching length of type arguments\" n)\r\n        if tya.Length > 0 then \r\n          Type.App(r, tyargs)\r\n        else r \r\n    | None -> \r\n        Log.error(\"Could not find named type '%s'\", n)\r\n        failwith (sprintf \"Could not find named type '%s'\" n)\r\n\r\n  let restTys = \r\n    [ TypePoviders.RestProvider.provideRestType lookupNamed \r\n        \"olympics1\" (services + \"olympics\") \"\"\r\n      TypePoviders.RestProvider.provideRestType lookupNamed \r\n        \"olympics3\" (services + \"pivot\") (\"source=\" + services + \"olympics\")\r\n      TypePoviders.RestProvider.provideRestType lookupNamed \r\n        \"smlouvy1\" (services + \"smlouvy\") \"\"\r\n      TypePoviders.RestProvider.provideRestType lookupNamed \r\n        \"smlouvy2\" (services + \"pivot\") (\"source=\" + services + \"smlouvy\")\r\n      TypePoviders.RestProvider.provideRestType lookupNamed \r\n        \"adventure\" (services + \"adventure\") \"\"\r\n      TypePoviders.RestProvider.provideRestType lookupNamed \r\n        \"world\" (services + \"worldbank\") \"\"\r\n      \r\n      TypeProviders.Pivot.providePivotType (services + \"pdata/olympics\") \"olympics\" lookupNamed\r\n        [ \"Games\", PrimitiveType.String; \"Year\", PrimitiveType.Number;  \"Sport\", PrimitiveType.String; \"Discipline\", PrimitiveType.String \r\n          \"Athlete\", PrimitiveType.String; \"Team\", PrimitiveType.String; \"Gender\", PrimitiveType.String; \"Event\", PrimitiveType.String \r\n          \"Medal\", PrimitiveType.String; \"Gold\", PrimitiveType.Number; \"Silver\", PrimitiveType.Number; \"Bronze\", PrimitiveType.Number ]\r\n      \r\n      TypeProviders.Pivot.providePivotType (services + \"pdata/smlouvy\") \"smlouvy\" lookupNamed\r\n        [ \"Uzavřeno\", PrimitiveType.String; \"Publikováno\", PrimitiveType.String; \"Hodnota\", PrimitiveType.Number\r\n          \"Chybí hodnota\", PrimitiveType.String; \"Subjekt\", PrimitiveType.String; \"Útvar\", PrimitiveType.String\r\n          \"Schválil\", PrimitiveType.String; \"Předmět\", PrimitiveType.String; \"Odkaz\", PrimitiveType.String\r\n          \"Platnost\", PrimitiveType.String; \"Příjemci\", PrimitiveType.String; \"Příjemci (IČO)\", PrimitiveType.String ]            \r\n\r\n      // TODO: some more types \r\n      TypePoviders.NamedType(\"value\", [\"a\"], Type.Any)\r\n      TypePoviders.NamedType(\"object\", [], Type.Any)\r\n      TypePoviders.NamedType(\"seq\", [\"a\"], Type.Any) \r\n      TypePoviders.NamedType(\"async\", [\"a\"], Type.Any) ]\r\n\r\n  let! fsTys = TypePoviders.FSharpProvider.provideFSharpTypes lookupNamed (\"/ext/libraries.json?\" + string System.DateTime.Now.Ticks)     \r\n  let allTys = restTys @ fsTys\r\n\r\n  named <- \r\n    allTys \r\n    |> Seq.choose (function TypePoviders.NamedType(s, tya, t) -> Some(s, (t, tya)) | _ -> None)\r\n    |> Map.ofSeq\r\n\r\n  let globals = \r\n    allTys \r\n    |> List.choose (function TypePoviders.GlobalValue(s, m, e, t) -> Some(s, m, e, t) | _ -> None)\r\n  \r\n  return { Globals = globals; LookupNamed = lookupNamed } } |> Async.StartAsNamedFuture \"types\"\r\n\r\nlet globalTypes = async { \r\n  let! ty = types |> Async.AwaitFuture\r\n  Log.trace(\"typechecker\", \"Global values: %O\", Array.ofList ty.Globals)\r\n  return ty.Globals |> List.map (fun (n, m, e, t) -> Interpreter.globalEntity n m t (Some e)) } |> Async.StartAsNamedFuture \"global types\"\r\n\r\nlet globalExprs = async { \r\n  let! ty = types |> Async.AwaitFuture\r\n  return ty.Globals |> List.map (fun (n, _, e, _) -> n, e) |> Map.ofList } |> Async.StartAsNamedFuture \"global exps\"\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// HTML helpers\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nlet findElements f (el:Element) =\r\n  let rec loop acc (el:Node) = \r\n    if el = null then acc\r\n    else\r\n      let acc = \r\n        if el.nodeType = 1.0 && f (el :?> Element) then (el :?> Element)::acc\r\n        else acc\r\n      loop (loop acc el.firstChild) el.nextSibling\r\n  loop [] el.firstChild\r\n\r\nlet tryFindChildElement f (el:Element) = \r\n  let rec loop (el:Node) = \r\n    if el = null then None\r\n    elif el.nodeType = 1.0 && f (el :?> HTMLElement) then Some (el :?> HTMLElement)\r\n    else \r\n      match loop el.firstChild with\r\n      | None -> loop el.nextSibling\r\n      | res -> res  \r\n  loop el.firstChild \r\n\r\nlet findChildElement f e = tryFindChildElement f e |> FsOption.get\r\n\r\nlet withClass cls (el:Element) = el.classList.contains cls\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// More experiments\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nopen TheGamma.Ast\r\nopen TheGamma.Services\r\nopen TheGamma.Common\r\n\r\nlet pickMetaByType ctx typ metas = \r\n  metas |> List.tryPick (fun m -> \r\n    if m.Context = ctx && m.Type = typ then Some(m.Data)\r\n    else None)\r\n\r\nlet pickPivotFields expr =\r\n  match expr.Entity with\r\n  | Some { Kind = EntityKind.ChainElement _; Meta = m } \r\n  | Some { Kind = EntityKind.GlobalValue _; Meta = m } \r\n  | Some { Kind = EntityKind.Variable(_, { Meta = m }) } -> \r\n      match pickMetaByType \"http://schema.thegamma.net/pivot\" \"Fields\" m with\r\n      | Some m -> Some(unbox<TypeProviders.Pivot.Field list> m)\r\n      | _ -> None\r\n  | _ -> None\r\n\r\nlet pickPivotTransformations expr =\r\n  match expr.Entity with\r\n  | Some { Kind = EntityKind.ChainElement _; Meta = m } -> \r\n      match pickMetaByType \"http://schema.thegamma.net/pivot\" \"Transformations\" m with\r\n      | Some m -> Some(unbox<TypeProviders.Pivot.Transformation list> m)\r\n      | _ -> None\r\n  | Some { Kind = EntityKind.GlobalValue _; Meta = m } -> \r\n      Some([])\r\n  | _ -> None\r\n\r\nlet tryFindPreview globals (ent:Entity) = \r\n  let nm = {Name.Name=\"preview\"}\r\n  match FsOption.map Types.reduceType ent.Type with \r\n  | Some(Type.Object(TypeChecker.FindMethod nm _))\r\n  | Some(Type.Object(TypeChecker.FindProperty nm _)) ->\r\n      let res = Interpreter.evaluate globals ent  \r\n      match res with\r\n      | Some { Preview = Some p } ->\r\n          Some(fun id ->\r\n            table<int, int>.create(unbox<Series.series<string, obj>> p).set(showKey=false).show(id)\r\n          )\r\n      | _ -> None\r\n      //Log.trace(\"system\", \"Preview rendered\")\r\n      //Some(sprintf \"<ul style='font-size:10pt'>%s</ul>\" (String.concat \"\" s))\r\n      //Some(sprintf \"preview :-) %A\" res)\r\n  | _ ->\r\n      None //Some(\"no preview :-(\")\r\n\r\nlet commandAtLocation loc (program:Program) =\r\n  program.Body.Node |> List.tryFind (fun cmd ->\r\n    cmd.Range.Start <= loc && cmd.Range.End + 1 >= loc)\r\n(*\r\nlet chainElementAtLocation loc (ents:Binder.BindingResult) =\r\n  let chainElements = \r\n    ents.Entities |> Array.choose (fun (rng, ent) ->\r\n      match ent.Kind with\r\n      | EntityKind.ChainElement(name=n) when rng.Start <= loc && rng.End >= loc -> Some(rng, ent)\r\n      | _ -> None)\r\n  if chainElements.Length > 0 then\r\n    Some(chainElements |> Array.minBy (fun (rng, _) -> rng.End))\r\n  else None\r\n*)\r\nopen TheGamma.TypeProviders\r\n\r\nlet transformName = function\r\n  | Pivot.DropColumns _ -> \"drop columns\"\r\n  | Pivot.Empty _ -> \"empty\"\r\n  | Pivot.FilterBy _ -> \"filter by\"\r\n  | Pivot.GetSeries _ -> \"get series\"\r\n  | Pivot.GetTheData _ -> \"get the data\"\r\n  | Pivot.GroupBy _ -> \"group by\"\r\n  | Pivot.Paging _ -> \"paging\"\r\n  | Pivot.SortBy _ -> \"sort by\"\r\n\r\ntype PivotSection = \r\n  { Transformation : Pivot.Transformation   \r\n    Nodes : Node<Expr> list }\r\n\r\nlet createPivotSections tfss = \r\n  let rec loop acc (currentTfs, currentEnts, currentLength) = function\r\n    | (e, tfs)::tfss when \r\n          transformName (List.head tfs) = transformName currentTfs && \r\n          List.length tfs = currentLength ->\r\n        loop acc (List.head tfs, e::currentEnts, currentLength) tfss\r\n    | (e, tfs)::tfss ->\r\n          let current = { Transformation = currentTfs; Nodes = List.rev currentEnts }\r\n          loop (current::acc) (List.head tfs, [e], List.length tfs) tfss\r\n    | [] -> \r\n          let current = { Transformation = currentTfs; Nodes = List.rev currentEnts }\r\n          List.rev (current::acc)\r\n    \r\n  let tfss = tfss |> List.choose (fun node ->\r\n    match pickPivotTransformations node with\r\n    | Some(tfs) ->\r\n        let tfs = tfs |> List.filter (function Pivot.Empty -> false | _ -> true)\r\n        if List.isEmpty tfs then None else Some(node, tfs)\r\n    | None -> None )\r\n  match tfss with\r\n  | (e, tfs)::tfss -> loop [] (List.head tfs, [e], List.length tfs) tfss\r\n  | [] -> []\r\n\r\nlet rec collectChain acc node =\r\n  match node.Node with\r\n  | Expr.Call(Some e, n, _) \r\n  | Expr.Property(e, n) -> collectChain ((n.Range.Start, node)::acc) e\r\n  | Expr.Variable(n) -> Some((n.Range.Start, node)::acc)\r\n  | _ -> None\r\n\r\nlet rec collectFirstChain expr = \r\n  match collectChain [] expr with\r\n  | Some((_::_) as chain) -> Some(id, chain)\r\n  | _ ->\r\n  match expr with\r\n  | { Node = ExprNode(es, ns) } -> \r\n      let rec loop acc es =   \r\n        match es with \r\n        | [] -> None\r\n        | e::es ->\r\n            match collectFirstChain e with \r\n            | None -> loop (e::acc) es\r\n            | Some(recreate, chain) ->\r\n                let recreate newChain =\r\n                  { expr with Node = rebuildExprNode e.Node (List.rev acc @ [ recreate newChain ] @ es) ns }\r\n                Some(recreate, chain)\r\n      loop [] es\r\n  | _ -> None\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Elmish pivot editor\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype PivotEditorMenus =\r\n  | AddDropdownOpen\r\n  | ContextualDropdownOpen\r\n  | Hidden\r\n\r\ntype PivotEditorAction = \r\n  | InitializeGlobals of seq<Entity>\r\n  | UpdateSource of string * int * Program * Monaco.LocationMapper\r\n  | UpdateLocation of int\r\n  | SelectRange of Range\r\n  | SelectChainElement of int\r\n  | AddTransform of Pivot.Transformation\r\n  | RemoveSection of Symbol\r\n  | RemoveElement of Symbol\r\n  | ReplaceElement of Symbol * string * option<list<Expr>>\r\n  | ReplaceRange of Range * string\r\n  | AddElement of Symbol * string * option<list<Expr>>\r\n  | SwitchMenu of PivotEditorMenus\r\n  | SetFocus of string * int option\r\n  | Multiplex of PivotEditorAction list\r\n\r\ntype PivotEditorState = \r\n  { // Initialized once - global values\r\n    Globals : seq<Entity>\r\n    // Updated when code changes - parsed program\r\n    Code : string\r\n    Program : Program\r\n    Mapper : Monaco.LocationMapper\r\n    // Updated when cursor moves \r\n    Location : int\r\n\r\n    // Calculated from the above\r\n    Body : Node<Expr> option\r\n    Menus : PivotEditorMenus\r\n    // Instructing the event loop to do things to the editor  \r\n    Selection : option<monaco.IRange>\r\n    Focus : option<string * int option> }\r\n\r\nlet updateBody state = \r\n  match commandAtLocation state.Location state.Program with\r\n  | Some(cmd) ->\r\n      let line, col = state.Mapper.AbsoluteToLineCol(cmd.Range.End + 1)\r\n      let (Command.Expr expr | Command.Let(_, expr)) = cmd.Node \r\n      { state with Body = Some expr }\r\n  | _ -> \r\n      { state with Body = None }\r\n\r\nlet hideMenus state = { state with Menus = Hidden }\r\n\r\nlet editorLocation (mapper:Monaco.LocationMapper) startIndex endIndex = \r\n  let sl, sc = mapper.AbsoluteToLineCol(startIndex)\r\n  let el, ec = mapper.AbsoluteToLineCol(endIndex)\r\n  let rng = JsInterop.createEmpty<monaco.IRange>\r\n  rng.startLineNumber <- float sl\r\n  rng.startColumn <- float sc\r\n  rng.endLineNumber <- float el\r\n  rng.endColumn <- float ec\r\n  rng\r\n\r\nlet selectName nd state = \r\n  let rng =\r\n    match nd with\r\n    | { Node = Expr.Call(_, n, _) | Expr.Property(_, n) } -> n.Range\r\n    | _ -> nd.Range\r\n  let loc = editorLocation state.Mapper rng.Start (rng.End+1)\r\n  { state with Selection = Some loc }\r\n\r\nlet tryTransformChain f state = \r\n  match state.Body with\r\n  | Some body ->\r\n      match collectFirstChain body with\r\n      | Some(recreate, chain) ->\r\n          let sections = chain |> List.map snd |> createPivotSections \r\n          f body recreate (List.map snd chain) sections |> hideMenus\r\n      | _ -> hideMenus state\r\n  | _ -> hideMenus state\r\n\r\nlet marker = \"InsertPropertyHere\"\r\n\r\nlet replaceAndSelectMarker newName state = \r\n  let startIndex = state.Code.IndexOf(marker)\r\n  let newCode = state.Code.Replace(marker, Ast.escapeIdent newName)\r\n  let mapper = Monaco.LocationMapper(state.Code)\r\n  let rng = editorLocation mapper startIndex (startIndex + (Ast.escapeIdent newName).Length)\r\n  { state with Code = newCode; Selection = Some rng }\r\n\r\nlet reconstructChain state (body:Node<_>) newNodes = \r\n  let newBody =\r\n    List.tail newNodes \r\n    |> List.fold (fun prev part ->\r\n      match part.Node with \r\n      | Expr.Property(_, n) -> { part with Node = Expr.Property(prev, n) }\r\n      | Expr.Call(_, n, args) -> { part with Node = Expr.Call(Some prev, n, args) }\r\n      | _ -> failwith \"Unexpected node in call chain\") (List.head newNodes)\r\n\r\n  let newCode = (Ast.formatSingleExpression newBody).Trim()\r\n  let newCode = state.Code.Substring(0, body.Range.Start) + newCode + state.Code.Substring(body.Range.End + 1)\r\n  { state with Code = newCode }\r\n\r\nlet createChainNode args = \r\n  let node nd = Ast.node {Start=0; End=0} nd\r\n  match args with\r\n  | None -> node (Expr.Property(node Expr.Empty, node {Name=marker}))\r\n  | Some args -> \r\n      let args = args |> List.map (fun a -> { Name = None; Value = node a })\r\n      node (Expr.Call(None, node {Name=marker}, node args))\r\n\r\nlet rec updatePivotState state event = \r\n  match event with\r\n  | InitializeGlobals(globals) ->\r\n      { state with PivotEditorState.Globals = globals }\r\n  | UpdateLocation(loc) ->\r\n      { state with Location = loc } |> updateBody |> hideMenus\r\n  | UpdateSource(code, loc, program, mapper) ->\r\n      { state with Location = loc; Program = program; Code = code; Mapper = mapper } |> updateBody |> hideMenus\r\n  | SwitchMenu menu ->\r\n      { state with Menus = menu }\r\n  | SetFocus(focus, sel) ->\r\n      { state with Focus = Some(focus, sel) }\r\n  | Multiplex events ->\r\n      events |> List.fold updatePivotState state\r\n\r\n  | SelectChainElement(dir) ->\r\n      state |> tryTransformChain (fun body recreate chain sections ->\r\n        let rec loop before (chain:Node<_> list) = \r\n          match chain with\r\n          | c::chain when c.Range.End + 1 < state.Location -> loop c chain\r\n          | c::after::_ -> before, c, after\r\n          | [c] -> before, c, c\r\n          | [] -> before, before, before\r\n        let before, it, after = loop (List.head chain) (List.tail chain)\r\n        state |> selectName (if dir < 0 then before elif dir > 0 then after else it)\r\n      )\r\n          \r\n  | SelectRange(rng) ->    \r\n      { state with Selection = Some (editorLocation state.Mapper rng.Start (rng.End+1)) }\r\n\r\n  | ReplaceRange(rng, value) ->    \r\n      Log.trace(\"live\", \"Replace '%s' with '%s'\", state.Code.Substring(rng.Start, rng.End - rng.Start + 1), value)\r\n      let newCode = state.Code.Substring(0, rng.Start) + value + state.Code.Substring(rng.End + 1)\r\n      let location = editorLocation (Monaco.LocationMapper(newCode)) rng.Start (rng.Start+value.Length)\r\n      { state with Code = newCode; Selection = Some location }\r\n\r\n  | AddElement(sym, name, args) ->\r\n      state |> tryTransformChain (fun body recreate chain sections ->\r\n        let newNodes =\r\n          chain |> List.collect (fun nd -> \r\n            if nd.Entity.Value.Symbol <> sym then [nd]\r\n            else [nd; createChainNode args] )        \r\n        reconstructChain state body newNodes\r\n        |> replaceAndSelectMarker name\r\n      )\r\n\r\n  | ReplaceElement(sym, name, args) ->\r\n      state |> tryTransformChain (fun body recreate chain sections ->\r\n        let newNodes =\r\n          chain |> List.map (fun nd -> \r\n            if nd.Entity.Value.Symbol <> sym then nd\r\n            else createChainNode args )\r\n        reconstructChain state body newNodes\r\n        |> replaceAndSelectMarker name\r\n      )\r\n\r\n  | RemoveElement sym ->\r\n      state |> tryTransformChain (fun body recreate chain sections ->\r\n        let beforeDropped = chain |> List.takeWhile (fun nd -> nd.Entity.Value.Symbol <> sym) |> List.tryLast\r\n        let beforeDropped = defaultArg beforeDropped (List.head chain)\r\n        let newNodes = chain |> List.filter (fun nd -> nd.Entity.Value.Symbol <> sym)        \r\n        reconstructChain state body newNodes\r\n        |> selectName beforeDropped\r\n      )\r\n\r\n  | RemoveSection sym ->\r\n      state |> tryTransformChain (fun body recreate chain sections ->\r\n        let beforeDropped = \r\n          sections |> List.map (fun sec -> List.head sec.Nodes) \r\n          |> List.takeWhile (fun nd -> nd.Entity.Value.Symbol <> sym) |> List.tryLast\r\n        let beforeDropped = defaultArg beforeDropped (List.head chain)\r\n        let newNodes = sections |> List.filter (fun sec -> (List.head sec.Nodes).Entity.Value.Symbol <> sym)\r\n        let newNodes = List.head chain :: (newNodes |> List.collect (fun sec -> sec.Nodes))\r\n        reconstructChain state body newNodes\r\n        |> selectName beforeDropped \r\n      )\r\n\r\n  | AddTransform tfs ->\r\n      state |> tryTransformChain (fun body recreate chain sections ->\r\n        let whites =\r\n          sections \r\n          |> List.map (fun sec -> Ast.formatWhiteAfterExpr (List.last sec.Nodes))\r\n          |> List.countBy id\r\n        let whiteAfter, _ = (\"\",0)::whites |> List.maxBy (fun (s, c) -> if s = \"\" then 0 else c)\r\n        Log.trace(\"live\", \"Whitespace of sections: %O, inserting '%s'\", Array.ofList whites, whiteAfter)\r\n        let node n = Ast.node { Start=0; End=0; } n\r\n\r\n        let firstProperty, getProperties = \r\n          let res k l = k, fun _ -> l\r\n          match tfs with\r\n          | Pivot.DropColumns _ -> res \"drop columns\" [marker; \"then\"]\r\n          | Pivot.SortBy _ -> res \"sort data\" [marker; \"then\"]\r\n          | Pivot.FilterBy _ -> res \"filter data\" [marker; \"then\"] // TODO\r\n          | Pivot.Paging _ -> res \"paging\" [marker; \"then\"]\r\n          | Pivot.GetSeries _ -> res \"get series\" [marker]\r\n          | Pivot.GetTheData -> res \"get the data\" [marker]\r\n          | Pivot.GroupBy(_, _) -> \"group data\", fun expr ->\r\n              Log.trace(\"live\", \"Pick fields of %O, got: %O\", expr, pickPivotFields expr)\r\n              match pickPivotFields expr with\r\n              | Some (f::_) -> [marker; \"by \" + f.Name; \"then\"]\r\n              | _ -> [marker; \"by <Property>\"; \"then\"]\r\n          | Pivot.GroupBy([], _) | Pivot.Empty -> res \"\" []\r\n\r\n        let injectCall expr = \r\n          getProperties expr |> List.fold (fun expr name ->\r\n            node (Expr.Property(expr, node { Name = name }))) expr\r\n          |> Parser.whiteAfter [ { Token = TokenKind.White whiteAfter; Range = {Start=0; End=0} } ]\r\n\r\n        let tryInjectBefore prev part =\r\n          match pickPivotTransformations part with\r\n          | Some (Pivot.GetSeries _ :: _) \r\n          | Some (Pivot.GetTheData _ :: _) -> true, injectCall prev\r\n          | _ -> false, prev\r\n\r\n        let injected, newBody =\r\n          List.tail chain |> List.fold (fun (injected, prev) part ->\r\n            let injected, prev = if injected then injected, prev else tryInjectBefore prev part\r\n            match part.Node with \r\n            | Expr.Property(_, n) -> injected, { part with Node = Expr.Property(prev, n) }\r\n            | Expr.Call(_, n, args) -> injected, { part with Node = Expr.Call(Some prev, n, args) }\r\n            | _ -> failwith \"Unexpected node in call chain\") (false, List.head chain)\r\n\r\n        let newBody = recreate (if injected then newBody else injectCall newBody)\r\n        let newCode = (Ast.formatSingleExpression newBody).Trim()\r\n        let newCode = state.Code.Substring(0, body.Range.Start) + newCode + state.Code.Substring(body.Range.End + 1)\r\n        { state with Code = newCode } |> replaceAndSelectMarker firstProperty \r\n      )\r\n\r\nlet renderNodeList trigger nodes =\r\n  [ for nd in nodes do\r\n      match nd.Node with\r\n      | Expr.Property(_, n) when n.Node.Name <> \"then\" ->\r\n          yield h?span [] [\r\n            h?a [\"click\" =!> trigger (SelectRange(n.Range)) ] [\r\n              text n.Node.Name \r\n            ]\r\n            h?a [\"click\" =!> trigger (RemoveElement(nd.Entity.Value.Symbol))] [\r\n              h?i [\"class\" => \"fa fa-times\"] [] \r\n            ]\r\n          ]\r\n      | _ -> () ]\r\n\r\nlet renderContextMenu trigger = \r\n  h?a [\"class\" => \"right\"; \"click\" =!> trigger (SwitchMenu ContextualDropdownOpen) ] [\r\n    h?i [\"class\" => \"fa fa-plus\"] [] \r\n  ]\r\n\r\nlet renderAddPropertyMenu trigger f nodes =\r\n  [ let lastNode = nodes |> List.rev |> List.find (function { Node = Expr.Property(_, n) } -> n.Node.Name <> \"then\" | _ -> true) \r\n    match lastNode.Entity.Value.Type with\r\n    | Some(Type.Object obj) ->\r\n        let members = \r\n          obj.Members \r\n          |> Seq.choose (function Member.Property(name=n) when f n -> Some n | _ -> None)\r\n          |> Seq.sort\r\n        yield h?ul [] [\r\n          for n in members ->\r\n            h?li [] [ \r\n              h?a [ \"click\" =!> trigger (AddElement(lastNode.Entity.Value.Symbol, n, None)) ] [ text n] \r\n            ]\r\n        ]\r\n    | _ -> () ]\r\n\r\nlet renderSection triggerEvent section = \r\n  let trigger action = fun _ (e:Event) -> e.cancelBubble <- true; triggerEvent action\r\n  let triggerWith f = fun el (e:Event) -> e.cancelBubble <- true; triggerEvent (f el)\r\n  let getNodeNameAndSymbol = function\r\n    | Some { Entity = Some e; Node = Expr.Property(_, n) } -> n.Node.Name, Some e.Symbol\r\n    | _ -> \"\", None\r\n  [ match section with\r\n    | Some { Nodes = nodes; Transformation = Pivot.GetSeries _ } ->\r\n        let getSeriesNode, keyNode, valNode = \r\n          match nodes with \r\n          | gs::gsk::gsv::_ -> gs, Some gsk, Some gsv\r\n          | gs::gsk::_ -> gs, Some gsk, None\r\n          | gs::_ -> gs, None, None\r\n          | _ -> failwith \"No get series node in get series transformation\"\r\n        let keyName, keySym = getNodeNameAndSymbol keyNode\r\n        let valName, valSym = getNodeNameAndSymbol valNode\r\n        match getSeriesNode.Entity.Value.Type with\r\n        | Some(Type.Object obj) ->\r\n            yield h?select [\"change\" =!> triggerWith(fun el -> \r\n                match keySym with\r\n                | None -> AddElement(getSeriesNode.Entity.Value.Symbol, (unbox<HTMLSelectElement> el).value, None)\r\n                | Some selSym -> ReplaceElement(selSym, (unbox<HTMLSelectElement> el).value, None)) ] [\r\n              if keyName = \"\" then yield h?option [ \"value\" => \"\"; \"selected\" => \"selected\" ] [ text \"\" ]\r\n              for m in obj.Members do\r\n                match m with\r\n                | Member.Property(name=n) when n.StartsWith(\"with key\") ->\r\n                    yield h?option [  \r\n                      yield \"value\" => n\r\n                      if keyName = n then yield \"selected\" => \"selected\" ] [ text n ] \r\n                | _ -> ()\r\n            ]\r\n        | _ -> ()\r\n        match keyNode with\r\n        | Some({ Entity = Some ({ Type = Some (Type.Object obj) } as keyEnt)}) ->\r\n            yield h?select [\"change\" =!> triggerWith(fun el -> \r\n                match valSym with\r\n                | None -> AddElement(keyEnt.Symbol, (unbox<HTMLSelectElement> el).value, None)\r\n                | Some selSym -> ReplaceElement(selSym, (unbox<HTMLSelectElement> el).value, None)) ] [\r\n              if valName = \"\" then yield h?option [ \"value\" => \"\"; \"selected\" => \"selected\" ] [ text \"\" ]\r\n              for m in obj.Members do\r\n                match m with\r\n                | Member.Property(name=n) when n.StartsWith(\"and value\") ->\r\n                    yield h?option [  \r\n                      yield \"value\" => n\r\n                      if keyName = n then yield \"selected\" => \"selected\" ] [ text n ] \r\n                | _ -> ()\r\n            ]\r\n        | _ -> ()\r\n\r\n    | Some { Nodes = nodes; Transformation = Pivot.GroupBy _ } ->\r\n        let firstNode, selNode, aggNodes = \r\n          match nodes with \r\n          | gby::sel::aggs -> gby, Some sel, aggs\r\n          | gby::_ -> gby, None, []\r\n          | _ -> failwith \"No group by node in group by transformation\"\r\n        let selName, selSym = getNodeNameAndSymbol selNode\r\n        match firstNode.Entity.Value.Type with\r\n        | Some(Type.Object obj) ->\r\n            yield h?select [\"change\" =!> triggerWith(fun el -> \r\n                match selSym with\r\n                | None -> AddElement(firstNode.Entity.Value.Symbol, (unbox<HTMLSelectElement> el).value, None)\r\n                | Some selSym -> ReplaceElement(selSym, (unbox<HTMLSelectElement> el).value, None)) ] [\r\n              if selName = \"\" then yield h?option [ \"value\" => \"\"; \"selected\" => \"selected\" ] [ text \"\" ]\r\n              for m in obj.Members do\r\n                match m with\r\n                | Member.Property(name=n) when n.StartsWith(\"by\") ->\r\n                    yield h?option [  \r\n                      yield \"value\" => n\r\n                      if selName = n then yield \"selected\" => \"selected\" ] [ text n ] \r\n                | _ -> ()\r\n            ]\r\n        | _ -> ()\r\n        yield! renderNodeList trigger aggNodes  \r\n        yield renderContextMenu trigger\r\n\r\n    | Some { Nodes = nodes; Transformation = Pivot.Paging _ } ->                    \r\n        let methods = nodes |> List.map (function { Node = Expr.Call(_, n, _) } -> n.Node.Name | _ -> \"\") |> set\r\n        for nd in nodes do\r\n          match nd.Node with\r\n          | Expr.Call(_, n, { Node = [arg] }) ->\r\n              let removeOp =\r\n                if n.Node.Name = \"take\" then ReplaceElement(nd.Entity.Value.Symbol, \"then\", None)\r\n                else RemoveElement(nd.Entity.Value.Symbol)\r\n              yield h?span [] [\r\n                  h?a [\"click\" =!> trigger (SelectRange(n.Range)) ] [ text n.Node.Name ]\r\n                  h?input [ \r\n                    \"id\" => \"input-pg-\" + n.Node.Name\r\n                    \"input\" =!> fun el _ -> \r\n                      let input = unbox<HTMLInputElement> el\r\n                      let parsed, errors = Parser.parseProgram input.value\r\n                      if errors.Length = 0 && parsed.Body.Node.Length = 1 then\r\n                        setCustomValidity el \"\"\r\n                        Multiplex\r\n                          [ SetFocus(\"input-pg-\" + n.Node.Name, Some(int input.selectionStart));\r\n                            ReplaceRange(arg.Value.Range, input.value) ] |> triggerEvent\r\n                      else setCustomValidity el \"Cannot parse expression\"\r\n                    \"value\" => Ast.formatSingleExpression arg.Value ] []\r\n                  h?a [\"click\" =!> trigger (removeOp)] [\r\n                    h?i [\"class\" => \"fa fa-times\"] [] \r\n                  ]\r\n                ]\r\n          | _ -> ()\r\n        if not (methods.Contains \"take\" && methods.Contains \"skip\") then\r\n          yield renderContextMenu trigger\r\n\r\n    | Some { Nodes = nodes; Transformation = Pivot.SortBy _ } ->\r\n        let props = nodes |> List.choose (function\r\n          | { Node = Expr.Property(_, n); Entity = Some { Symbol = sym} }\r\n              when n.Node.Name <> \"then\" && n.Node.Name <> \"sort data\" -> Some(sym, n) | _ -> None)\r\n        let last = List.tryLast props\r\n        for sym, n in props ->\r\n          h?span [] [\r\n            yield h?a [\"click\" =!> trigger (SelectRange(n.Range)) ] [\r\n              text n.Node.Name \r\n            ]\r\n            if n.Node.Name = (snd last.Value).Node.Name then\r\n              yield h?a [\"click\" =!> trigger (RemoveElement(sym))] [\r\n                h?i [\"class\" => \"fa fa-times\"] [] \r\n              ]\r\n          ]\r\n        yield renderContextMenu trigger\r\n\r\n    | Some { Nodes = nodes; Transformation = Pivot.DropColumns _ } ->\r\n        yield! renderNodeList trigger (List.tail nodes)\r\n        yield renderContextMenu trigger\r\n\r\n    | _ -> () ]\r\n\r\nlet renderPivot triggerEvent state = \r\n  let trigger action = fun _ (e:Event) -> e.cancelBubble <- true; triggerEvent action\r\n  let triggerWith f = fun el (e:Event) -> e.cancelBubble <- true; triggerEvent (f el)\r\n  match state.Body with\r\n  | None -> None \r\n  | Some body ->\r\n  match collectFirstChain body with\r\n  | None -> None\r\n  | Some(_, chainNodes) ->\r\n      let starts = [| for r,n in chainNodes -> sprintf \"%d: %s\" r n.Entity.Value.Name |]\r\n      Log.trace(\"live\", \"Find chain element at %d in %O\", state.Location, starts)\r\n      match chainNodes |> List.filter (fun (start, node) -> state.Location >= start) |> List.tryLast with\r\n      | None -> None\r\n      | Some(_, selNode) ->\r\n          let selEnt = selNode.Entity.Value\r\n          let sections = chainNodes |> List.map snd |> createPivotSections \r\n          let selSec = sections |> List.tryFind (fun sec -> \r\n            sec.Nodes |> List.exists (fun secEnt -> selEnt.Symbol = secEnt.Entity.Value.Symbol) )\r\n          let preview = defaultArg (tryFindPreview state.Globals selEnt) ignore\r\n          let dom = \r\n            h?div [\r\n                yield \"class\" => \"pivot-preview\"\r\n                if state.Menus <> Hidden then yield \"click\" =!> trigger (SwitchMenu Hidden)\r\n              ] [\r\n              h?ul [\"class\" => \"tabs\"] [\r\n                let _, firstNode = chainNodes |> List.head\r\n                yield h?li [\"class\" => if selNode.Entity.Value.Symbol = firstNode.Entity.Value.Symbol then \"selected\" else \"\"] [ \r\n                  h?a [\"click\" =!> trigger (SelectRange(firstNode.Range)) ] [\r\n                    match firstNode.Node with\r\n                    | Expr.Variable n -> yield text n.Node.Name\r\n                    | _ -> yield text \"data\"\r\n                  ]\r\n                ]\r\n                for sec in sections ->\r\n                  let selected = sec.Nodes |> List.exists (fun secEnt -> selEnt.Symbol = secEnt.Entity.Value.Symbol)\r\n                  let secSymbol = (sec.Nodes |> List.head).Entity.Value.Symbol\r\n                  let identRange = \r\n                    match sec.Nodes with\r\n                    | { Node = Expr.Variable n | Expr.Call(_, n, _) | Expr.Property(_, n) }::_ -> n.Range\r\n                    | _ -> failwith \"Unexpected node in pivot call chain\" \r\n\r\n                  h?li [\"class\" => if selected then \"selected\" else \"\"] [ \r\n                    h?a [\"click\" =!> trigger (SelectRange(identRange)) ] [\r\n                      text (transformName sec.Transformation) \r\n                    ]\r\n                    h?a [\"click\" =!> trigger (RemoveSection(secSymbol))] [\r\n                      h?i [\"class\" => \"fa fa-times\"] [] \r\n                    ]\r\n                  ]\r\n                yield h?li [\"class\" => if state.Menus = AddDropdownOpen then \"add selected\" else \"add\"] [ \r\n                  h?a [\"click\" =!> trigger (SwitchMenu AddDropdownOpen) ] [\r\n                    h?i [\"class\" => \"fa fa-plus\"] [] \r\n                  ]\r\n                ]\r\n              ]\r\n              h?div [\"class\" => \"add-menu\"] [\r\n                let clickHandler tfs = \"click\" =!> trigger (AddTransform(tfs))\r\n                if state.Menus = AddDropdownOpen then \r\n                  yield h?ul [] [\r\n                    yield h?li [] [ h?a [ clickHandler(Pivot.DropColumns []) ] [ text \"drop columns\"] ]\r\n                    yield h?li [] [ h?a [ clickHandler(Pivot.FilterBy []) ] [ text \"filter by\"] ]\r\n                    yield h?li [] [ h?a [ clickHandler(Pivot.GroupBy([], [])) ] [ text \"group by\"] ]\r\n                    yield h?li [] [ h?a [ clickHandler(Pivot.Paging []) ] [ text \"paging\"] ]\r\n                    yield h?li [] [ h?a [ clickHandler(Pivot.SortBy []) ] [ text \"sort by\"] ]\r\n                    let getDataCalled = \r\n                      sections |> List.exists (function \r\n                        | { Transformation = Pivot.GetTheData | Pivot.GetSeries _ } -> true | _ -> false)\r\n                    if not getDataCalled then\r\n                      yield h?li [] [ h?a [ clickHandler(Pivot.GetTheData) ] [ text \"get the data\"] ]\r\n                      yield h?li [] [ h?a [ clickHandler(Pivot.GetSeries(\"!\", \"!\")) ] [ text \"get series\"] ]\r\n                  ]\r\n              ]\r\n              h?div [\"class\" => \"toolbar\"] [\r\n                yield h?span [\"class\"=>\"navig\"] [\r\n                  h?a [] [ h?i [\"click\" =!> trigger (SelectChainElement -1); \"class\" => \"fa fa-chevron-left\"] [] ]\r\n                  h?a [] [ h?i [\"click\" =!> trigger (SelectChainElement 0); \"class\" => \"fa fa-circle\"] [] ]\r\n                  h?a [] [ h?i [\"click\" =!> trigger (SelectChainElement +1); \"class\" => \"fa fa-chevron-right\"] [] ]\r\n                ]\r\n                yield! renderSection triggerEvent selSec\r\n              ]\r\n\r\n              h?div [\"class\" => \"add-menu\"] [\r\n                match state.Menus, selSec with\r\n                | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.Paging _ } ->\r\n                    let methods = nodes |> List.choose (function \r\n                      | { Node = Expr.Property(_, n) | Expr.Call(_, n, _); Entity = e } -> \r\n                          Some(n.Node.Name, e.Value.Symbol) | _ -> None) |> dict\r\n                    let lastSym = (List.last nodes).Entity.Value.Symbol\r\n                    let firstSym = (List.head nodes).Entity.Value.Symbol\r\n                    yield h?ul [] [\r\n                      if not (methods.ContainsKey \"take\") then\r\n                        let op = \r\n                          if methods.ContainsKey \"then\" then ReplaceElement(methods.[\"then\"], \"take\", Some [Expr.Number 10.])\r\n                          else AddElement(lastSym, \"take\", Some [Expr.Number 10.])\r\n                        yield h?li [] [ h?a [ \"click\" =!> trigger op ] [ text \"take\"] ]\r\n                      if not (methods.ContainsKey \"skip\") then\r\n                        let op = AddElement(firstSym, \"skip\", Some [Expr.Number 10.])\r\n                        yield h?li [] [ h?a [ \"click\" =!> trigger op ] [ text \"skip\"] ]\r\n                    ]\r\n\r\n                | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.GroupBy _ } ->\r\n                    yield! nodes |> renderAddPropertyMenu trigger (fun n -> \r\n                      n <> \"then\" && n <> \"preview\" && not (n.StartsWith(\"and\")) )\r\n                | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.SortBy _ } ->\r\n                    yield! nodes |> renderAddPropertyMenu trigger (fun n -> n <> \"then\" && n <> \"preview\")\r\n                | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.DropColumns _ } ->\r\n                    yield! nodes |> renderAddPropertyMenu trigger (fun n -> n <> \"then\" && n <> \"preview\")\r\n                | _ -> ()\r\n              ]\r\n              h?div [\"class\" => \"preview-body\"] [\r\n                yield h.delayed preview\r\n              ] \r\n            ]\r\n          let endLine, _ = state.Mapper.AbsoluteToLineCol(body.Range.End)\r\n          Some(endLine, dom)\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Zones infra\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype PreviewService(checker:CheckingService, ed:monaco.editor.ICodeEditor) =\r\n  let mutable currentZone : option<_* monaco.editor.IViewZone *_> = None\r\n\r\n  let removeZone () =\r\n    match currentZone with \r\n    | Some(id, _, _) -> ed.changeViewZones(fun accessor -> accessor.removeZone(id))\r\n    | None -> ()\r\n    currentZone <- None\r\n\n  let createAndAddZone endLine =\n    let mutable zoneId = -1.\n    let zone = JsInterop.createEmpty<monaco.editor.IViewZone>\n    \n    let node = document.createElement_div()\n    let wrapper = document.createElement_div()\n    node.appendChild(wrapper) |> ignore\n    ed.changeViewZones(fun accessor ->  \n      match currentZone with Some(id, _, _) -> accessor.removeZone(id) | _ -> ()\n      zone.afterLineNumber <- endLine\n      zone.heightInPx <- Some 300.0\n      zone.domNode <- node\n      zoneId <- accessor.addZone(zone) \n      currentZone <- Some (zoneId, zone, wrapper) )\n\r\n  let updateZones dom =\r\n    match dom with \r\n    | None -> removeZone ()\r\n    | Some(line, dom) ->\r\n        if currentZone.IsNone then\r\n          createAndAddZone 0.0\r\n        Log.trace(\"live\", \"Render %O to zone %O\", dom, currentZone)\r\n        match currentZone with\r\n        | Some(id, zone, wrapper) -> \r\n            if zone.afterLineNumber <> float line then\r\n              zone.afterLineNumber <- float line\r\n              ed.changeViewZones(fun accessor ->\r\n                accessor.layoutZone(id)\r\n              )\r\n            dom |> renderTo wrapper\r\n        | _ -> () // Shouldn't happen because we created the zone above \r\n\r\n  let mutable lastCode = \"\"\r\n  let mutable lastMapper = Monaco.LocationMapper(\"\")\r\n  let mutable changingEditor = false\r\n\r\n  let getUpdateEventAfterChange () = async {\r\n    let code = ed.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\r\n    let position = ed.getPosition()\r\n    if code <> lastCode then\r\n      lastCode <- code\r\n      lastMapper <- Monaco.LocationMapper(code)\r\n      let loc = lastMapper.LineColToAbsolute(int position.lineNumber, int position.column)\r\n      let! _, _, program = checker.TypeCheck(code)\r\n      return (UpdateSource(code, loc, program, lastMapper)) \r\n    else \r\n      let loc = lastMapper.LineColToAbsolute(int position.lineNumber, int position.column)\r\n      return (UpdateLocation(loc)) }\r\n\r\n  let createPivotPreview (ed:monaco.editor.ICodeEditor) = \r\n    let pivotEvent = new Event<PivotEditorAction>()\r\n\r\n    let mutable pivotState = \r\n      { Selection = None\r\n        Focus = None\r\n        Mapper = Monaco.LocationMapper(\"\")\r\n        Code = \"\"\r\n        Globals = []\r\n        Location = 0\r\n        Body = None\r\n        Program = { Body = Ast.node { Start = 0; End = 0 } [] }\r\n        Menus = Hidden }\r\n\r\n    pivotEvent.Publish.Add(fun evt ->\r\n      try\r\n        Log.trace(\"live\", \"Updating state %O with event %O\", pivotState, evt)\r\n        let oldState = pivotState \r\n        pivotState <- updatePivotState pivotState evt \r\n        if (match evt with UpdateSource _ -> false | _ -> true) &&\r\n           (oldState.Code <> pivotState.Code) then\r\n          changingEditor <- true\r\n          ed.getModel().setValue(pivotState.Code)\r\n        match pivotState.Selection with\r\n        | Some rng ->\r\n            changingEditor <- true\r\n            ed.setSelection(rng)\r\n            pivotState <- { pivotState with Selection = None }\r\n        | _ -> ()\r\n\r\n        if changingEditor = true then\r\n          changingEditor <- false\r\n          async { \r\n            Log.trace(\"live\", \"Editor changed. Getting after change event...\")\r\n            let! evt = getUpdateEventAfterChange ()\r\n            Log.trace(\"live\", \"Editor changed. Updating state %O with event %O\", pivotState, evt)\r\n            pivotState <- updatePivotState pivotState evt\r\n            updateZones (renderPivot pivotEvent.Trigger pivotState)\r\n            match pivotState.Focus with \r\n            | Some(focus, sel) ->\r\n                Log.trace(\"live\", \"Set focus to element #%s\", focus)\r\n                pivotState <- { pivotState with Focus = None }\r\n                let element = document.getElementById(focus) |> unbox<HTMLInputElement>\r\n                element.focus()\r\n                sel |> FsOption.iter (fun s -> element.selectionStart <- float s; element.selectionEnd <- float s)\r\n            | _ -> () } |> Async.StartImmediate\r\n        else\r\n          updateZones (renderPivot pivotEvent.Trigger pivotState)\r\n      with e ->\r\n        Log.exn(\"live\", \"Error when updating state %O with event %O: %O\", pivotState, evt, e) )\r\n\r\n    async { let! glob = globalTypes |> Async.AwaitFuture \r\n            pivotEvent.Trigger(InitializeGlobals glob) } |> Async.StartImmediate\r\n\r\n    pivotEvent.Trigger\r\n\r\n  let trigger = createPivotPreview ed    \r\n      \r\n  do\r\n    ed.onDidChangeCursorPosition(fun ce -> \r\n      if not changingEditor then\r\n        let code = ed.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\r\n        Log.trace(\"live\", \"Cursor position changed: code <> lastCode = %s\", code <> lastCode)\r\n        async { let! evt = getUpdateEventAfterChange ()\r\n                trigger evt } |> Async.StartImmediate ) |> ignore\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Putting everything togeter\r\n// ------------------------------------------------------------------------------------------------\r\n\r\n\r\n[<Emit(\"setRunner($0, $1)\")>]\r\nlet setRunner (article:string) (f:unit -> unit) = failwith \"JS\"\r\n\r\n[<Emit(\"shareSnippet($0, $1)\")>]\r\nlet shareSnippet (snippet:string) (compiled:string) = failwith \"JS\"\r\n\r\n[<Emit(\"cannotShareSnippet()\")>]\r\nlet cannotShareSnippet () = failwith \"JS\"\r\n\r\nlet callShowMethod outId cmd = async {\r\n  match cmd.Node with\r\n  | Command.Expr({ Entity = Some { Type = Some typ } } as inst) ->\r\n      match Types.reduceType typ with\r\n      | Type.Object { Members = members } ->\r\n          let hasShow = members |> Array.exists (function \r\n            | Member.Method(name=\"show\"; arguments=[_, _, Type.Primitive PrimitiveType.String]) -> true\r\n            | _ -> false)\r\n          if hasShow then\r\n            let rng = { Range.Start = cmd.Range.End; End = cmd.Range.End }\r\n            let outExpr = Ast.node rng (Expr.String(outId))\r\n            let args = [{ Argument.Name = None; Argument.Value = outExpr }]\r\n            let expr = Ast.node rng (Expr.Call(Some inst, Ast.node rng { Name = \"show\" }, Ast.node rng args))\r\n            return Ast.node cmd.Range (Command.Expr(expr))\r\n          else \r\n            return cmd\r\n      | _ -> return cmd\r\n  | _ -> return cmd }\r\n\r\nlet renderErrors article el (source, errors) = \r\n  if not (Seq.isEmpty errors) then\r\n    Log.event(\"compiler\", \"errors\", article, \r\n      JsInterop.createObj [\"source\", box source; \"errors\", box [| for e in errors -> e.Number |] ])\r\n  h?ul[\"class\" => \"error\"] \r\n    [ for e in errors |> Seq.sortBy (fun e -> e.Range.Start) -> \r\n        h?li [] [\r\n          h?span [\"class\" => \"err\"] [ text (sprintf \"error %d\" e.Number) ]\r\n          text \" \"\r\n          h?span [\"class\" => \"loc\"] [ text (sprintf \"at line %d col %d\" e.Range.Start.Line e.Range.Start.Column) ]\r\n          text (\": \" + e.Message) ] ]\r\n  |> renderTo el\r\n\r\n[<Emit(\"eval($0)\")>]\r\nlet eval (s:string) : unit = ()\r\n\r\nlet setupEditor (parent:HTMLElement) =\r\n  let source = (findChildElement (withClass \"ia-source\") parent).innerText.Trim()\r\n  let compiled = tryFindChildElement (withClass \"ia-compiled\") parent |> FsOption.map (fun el -> el.innerText.Trim())\r\n  let outputId = (findChildElement (withClass \"ia-output\") parent).id\r\n    \r\n  let runBtn = findChildElement (withClass \"ia-run\") parent\r\n  let shareBtn = findChildElement (withClass \"ia-share\") parent\r\n  let showCodeBtn = findChildElement (withClass \"ia-show-source\") parent\r\n  let showOptionsBtn = tryFindChildElement (withClass \"ia-show-options\") parent\r\n  \r\n  let editorEl = findChildElement (withClass \"ia-editor\") parent\r\n  let monacoEl = findChildElement (withClass \"ia-monaco\") parent\r\n  let errorsEl = findChildElement (withClass \"ia-errors\") parent\r\n  let optionsEl = findChildElement (withClass \"ia-options\") parent\r\n  \r\n  let article = parent.dataset.[\"article\"]\r\n\r\n  let checkingService = CheckingService(article, globalTypes)\r\n  let editorService = EditorService(article, checkingService.TypeCheck, 2000)\r\n  checkingService.ErrorsReported.Add (renderErrors article errorsEl)\r\n\r\n  let run text = async {\r\n    Log.event(\"compiler\", \"run\", article, text)\r\n    let! code = async {\r\n      match compiled with\r\n      | Some compiled when text = source -> return compiled\r\n      | _ ->\r\n        let! _, _, prog = checkingService.TypeCheck(text)\r\n        let! newBody = prog.Body.Node |> Async.map (callShowMethod outputId)\r\n        let prog = { prog with Body = { prog.Body with Node = newBody } }\r\n        return! CodeGenerator.compileAndRun globalExprs text prog }\r\n\r\n    // Get fable to reference everything\r\n    let s = TheGamma.Series.series<int, int>.create(async { return [||] }, \"\", \"\", \"\") \r\n    TheGamma.TypePovidersRuntime.RuntimeContext(\"lol\", \"\", \"troll\") |> ignore\r\n    TypePovidersRuntime.trimLeft |> ignore\r\n    TheGamma.GoogleCharts.chart.bar |> ignore\r\n    TheGamma.table<int, int>.create(s) |> ignore\r\n    TheGamma.Maps.timeline<int, int>.create(s) |> ignore\r\n    TheGamma.Series.series<int, int>.values([| 1 |]) |> ignore\r\n    eval code }\r\n\r\n  setRunner article (fun () -> \r\n    run source |> Async.StartImmediate)\r\n\r\n  let mutable optionsVisible = false\r\n  let mutable editorVisible = false\r\n\r\n  let ed = Lazy.Create(fun () ->   \r\n    let ed = Monaco.createMonacoEditor monacoEl.id source (fun opts ->\r\n      opts.fontFamily <- Some \"Inconsolata\"\r\n      opts.fontSize <- Some 15.0\r\n      opts.lineHeight <- Some 20.0 )\r\n\r\n    let resizeEditor (text:string) =\r\n      let dim = JsInterop.createEmpty<monaco.editor.IDimension>\r\n      dim.width <- parent.clientWidth - 40.0\r\n      dim.height <- max 100.0 (20.0 + float (text.Split('\\n').Length) * 20.0)\r\n      ed.layout(dim)\r\n      monacoEl.style.height <- string dim.height + \"px\" \r\n\r\n    ed.getModel().onDidChangeContent(fun _ ->\r\n      let text = ed.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\r\n      if optionsVisible then\r\n        editorService.UpdateSource(text) \r\n      resizeEditor text) |> ignore\r\n      \r\n    resizeEditor source\r\n    PreviewService(checkingService, ed) |> ignore\r\n    ed )\r\n  \r\n  let getText() = \r\n    if not ed.IsValueCreated then source\r\n    else ed.Value.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\r\n\r\n  let setText (edit:string) membr t = \r\n    Log.event(\"options\", \"set-text\", article, JsInterop.createObj [\"edit\", box edit; \"member\", box membr ])\r\n    ed.Value.getModel().setValue(t)\r\n    if showOptionsBtn.IsSome && optionsVisible then\r\n      editorService.UpdateSource(t, true)\r\n    run(t) |> Async.StartImmediate\r\n\r\n  let showOrHideActions () =\r\n    let vis = if optionsVisible || editorVisible then \"inline\" else \"none\"\r\n    let modf = getText() <> source\r\n    runBtn.style.display <- vis\r\n    shareBtn.style.display <- if modf then \"inline\" else vis\r\n\r\n  showOptionsBtn |> FsOption.iter (fun btn -> \r\n    editorService.EditorsUpdated.Add (fun eds ->\r\n      eds\r\n      |> List.sortBy (fun ed -> ed.Range.Start)\r\n      |> List.map (Editors.renderEditor checkingService.IsWellTyped setText (getText())) \r\n      |> h?div [\"class\" => \"ia-editor-panel\"]\r\n      |> renderTo optionsEl )\r\n  \r\n    btn.onclick <- fun _ ->\r\n      optionsVisible <- not optionsVisible\r\n      showOrHideActions()\r\n      optionsEl.style.display <- if optionsVisible then \"block\" else \"none\"\r\n      Log.event(\"gui\", \"options\", article, box optionsVisible)\r\n      if optionsVisible then editorService.UpdateSource(getText())\r\n      box () )\r\n\r\n  let switchEditor () =\r\n    editorVisible <- not editorVisible\r\n    showOrHideActions()\r\n    editorEl.style.display <- if editorVisible then \"block\" else \"none\"\r\n    Log.event(\"gui\", \"editor\", article, editorVisible)\r\n    if editorVisible then \r\n      ed.Force() |> ignore\r\n      editorService.UpdateSource(getText()) \r\n    \r\n  showCodeBtn.onclick <- fun _ -> switchEditor(); box()\r\n  if source.Contains(\"empty.create\") then switchEditor()\r\n\r\n  shareBtn.onclick <- fun e -> \r\n    let text = getText()\r\n    Log.event(\"gui\", \"share\", article, text)\r\n    async { \r\n      let! ok, _, prog = checkingService.TypeCheck(text)\r\n      let! newBody = prog.Body.Node |> Async.map (callShowMethod \"output-id-placeholder\")\r\n      let prog = { prog with Body = { prog.Body with Node = newBody } }\r\n      let! compiled = CodeGenerator.compileAndRun globalExprs text prog         \r\n      if not ok then cannotShareSnippet()\r\n      else shareSnippet text compiled } |> Async.StartImmediate\r\n    box ()\r\n\r\n  runBtn.onclick <- fun e -> \r\n    Log.event(\"gui\", \"run\", article, \"click\")\r\n    getText() |> run |> Async.StartImmediate |> box\r\n\r\n  ed, checkingService\r\n\r\nlet servicesLookup = ResizeArray<Lazy<monaco.editor.ICodeEditor> * _>()\r\n\r\nMonaco.setupMonacoServices(fun name ->\r\n  servicesLookup |> Seq.pick (fun (ed, svc) ->\r\n    if ed.IsValueCreated && ed.Value.getModel().uri.toString() = name then Some(svc)\r\n    else None )\r\n)\r\n\r\nfor el in findElements (withClass \"ia-figure\") document.body do\r\n  servicesLookup.Add(setupEditor (el :?> HTMLElement))\r\n"]}