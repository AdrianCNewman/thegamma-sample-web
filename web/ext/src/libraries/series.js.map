{"version":3,"sources":["../../../src/libraries/series.fs"],"names":[],"mappings":"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","file":"series.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/libraries","sourcesContent":["ï»¿namespace TheGamma.Series\r\n\r\nopen Fable.Core\r\nopen TheGamma.Common\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n// Series helpers - various JavaScript functions needed for simple series implementation\r\n// --------------------------------------------------------------------------------------------------------------------\r\n\r\nmodule SeriesInternals =\r\n  open System.Collections.Generic\r\n\r\n  [<Emit(\"($0==null)\")>]\r\n  let isNull(o:obj) : bool = failwith \"never\"\r\n\r\n  [<Emit(\"$0[$1]\")>]\r\n  let getProperty<'T> (obj:obj) (name:string) : 'T = failwith \"never\"\r\n\r\n  [<Emit(\"($0 < $1 ? -1 : ($0 == $1 ? 0 : 1))\")>]\r\n  let compare (x:'a) (y:'a) : int = failwith \"never\"\r\n\r\n  let slice lo hi (arr:'T[]) =\r\n    Array.init (hi - lo + 1) (fun i -> arr.[lo + i])\r\n\r\n  let dictAny (v:seq<'k*'v>) = unbox<IDictionary<'k,'v>> (dict (unbox<seq<obj * obj>> v))\r\n\r\n  let zipUnsorted (arr1:_[]) (arr2:_[]) =\r\n    let d1 = dictAny arr1\r\n    let d2 = dictAny arr2\r\n    let res = ResizeArray<_>()\r\n    for kv1 in d1 do\r\n      let v2 =\r\n        if d2.ContainsKey(kv1.Key) then Some(d2.[kv1.Key])\r\n        else None\r\n      res.Add(kv1.Key, (Some kv1.Value, v2))\r\n    for kv2 in d2 do\r\n      if not (d1.ContainsKey(kv2.Key)) then\r\n        res.Add(kv2.Key, (None, Some kv2.Value))\r\n    Array.ofSeq res\r\n\r\n  let isSortedUsing test proj (arr:_[]) =\r\n    let rec loop i =\r\n      if i = arr.Length then true\r\n      else test (proj arr.[i-1]) (proj arr.[i]) && loop (i+1)\r\n    arr.Length = 0 || loop 1\r\n\r\n  let zipSorted (arr1:('k*'v1)[]) (arr2:('k*'v2)[]) =\r\n    let mutable i1 = 0\r\n    let mutable i2 = 0\r\n    let inline (<.) (a:'k) (b:'k) = compare a b < 0\r\n    let inline eq (a:'k) (b:'k) = compare a b = 0\r\n    let res = ResizeArray<_>()\r\n    while i1 < arr1.Length && i2 < arr2.Length do\r\n      let (k1, v1), (k2, v2) = arr1.[i1], arr2.[i2]\r\n      if eq k1 k2 then\r\n        res.Add(k1, (Some v1, Some v2))\r\n        i1 <- i1 + 1\r\n        i2 <- i2 + 1\r\n      elif k1 <. k2 then\r\n        res.Add(k1, (Some v1, None))\r\n        i1 <- i1 + 1\r\n      elif k2 <. k1 then\r\n        res.Add(k2, (None, Some v2))\r\n        i2 <- i2 + 1\r\n    while i1 < arr1.Length do\r\n      let k1, v1 = arr1.[i1]\r\n      res.Add(k1, (Some v1, None))\r\n      i1 <- i1 + 1\r\n    while i2 < arr2.Length do\r\n      let k2, v2 = arr2.[i2]\r\n      res.Add(k2, (None, Some v2))\r\n      i2 <- i2 + 2\r\n    Array.ofSeq res\r\n\r\n  let zipAny (arr1:('k*'v1)[]) (arr2:('k*'v2)[]) =\r\n    let inline (<=.) (a:'k) (b:'k) = compare a b <= 0\r\n    let inline (>=.) (a:'k) (b:'k) = compare a b >= 0\r\n    if isSortedUsing (<=.) fst arr1 && isSortedUsing (<=.) fst arr2 then zipSorted arr1 arr2\r\n    elif isSortedUsing (>=.) fst arr1 && isSortedUsing (>=.) fst arr2 then Array.rev (zipSorted (Array.rev arr1) (Array.rev arr2))\r\n    else zipUnsorted arr1 arr2\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n// Async series library for TheGamma - implements type `series<'k, 'v>` with various operations\r\n// --------------------------------------------------------------------------------------------------------------------\r\n\r\nopen SeriesInternals\r\n\r\n//type value<'k> = { value : Async<'k> }\r\n\r\ntype internal helpers = \r\n  static member inline lift (f:('a*'b)[] -> ('c*'d)[]) (s:series<_, _>) =\r\n    let nd = async {\r\n      let! vs = s.data |> Async.AwaitFuture\r\n      return f vs } |> Async.StartAsFuture\r\n    { data = nd\r\n      keyName = s.keyName\r\n      valueName = s.valueName\r\n      seriesName = s.seriesName } \r\n  static member inline asyncLift (f:('a*'b)[] -> Async<('c*'d)[]>) (s:series<_, _>) =\r\n    let nd = async {\r\n      let! vs = s.data |> Async.AwaitFuture\r\n      return! f vs } |> Async.StartAsFuture\r\n    { data = nd\r\n      keyName = s.keyName\r\n      valueName = s.valueName\r\n      seriesName = s.seriesName }\r\n(*    \r\n  static member inline liftAggregation f (s:series<_, _>) =\r\n    { value = async {\r\n        let! vs = s.data\r\n        return f vs } }\r\n*)\r\n\r\nand series<'k, 'v> = \r\n  internal \r\n    { data : Future<('k * 'v)[]> \r\n      keyName : string\r\n      valueName : string\r\n      seriesName : string }\r\n\r\n  member internal x.set(data, ?keyName, ?valueName, ?seriesName) = \r\n    { data = data \r\n      keyName = defaultArg keyName x.keyName\r\n      valueName = defaultArg valueName x.valueName\r\n      seriesName = defaultArg seriesName x.seriesName }\r\n  member x.setProperties(?keyName, ?valueName, ?seriesName) = \r\n    { x with \r\n        keyName = defaultArg keyName x.keyName\r\n        valueName = defaultArg valueName x.valueName\r\n        seriesName = defaultArg seriesName x.seriesName }\r\n\r\n//type series =\r\n  static member create(data, keyName, valueName, seriesName) = \r\n    { data = data |> Async.StartAsFuture; keyName = keyName; valueName = valueName; seriesName = seriesName }\r\n\r\n  // TODO: This is where the naming starts to suck\r\n  static member values(values) = \r\n    let data = async {\r\n      return values |> Array.mapi (fun i v -> i, v) } |> Async.StartAsFuture\r\n    { data = data; keyName = \"key\"; valueName = \"value\"; seriesName = \"\" }\r\n\r\n  static member range(from, ``to``) = \r\n    series<int, int>.values [| from .. ``to`` |]\r\n\r\n  static member rangeBy(from, ``to``, step) = \r\n    series<int, int>.values [| from .. step .. ``to`` |]\r\n\r\n  static member ordinal(data, keyName, valueName, seriesName) = \r\n    let data = async {\r\n      let! values = data\r\n      return values |> Array.mapi (fun i v -> i, v) } |> Async.StartAsFuture\r\n    { data = data; keyName = keyName; valueName = valueName; seriesName = seriesName }\r\n\r\n  member s.sortKeys(?reverse) =\r\n    s |> helpers.lift (fun arr ->\r\n      arr |> Array.sortWith (fun (k1, _) (k2, _) -> compare k1 k2)\r\n          |> (if reverse = Some true then Array.rev else id))\r\n\r\n  member s.sortValues(?reverse) =\r\n    s |> helpers.lift (fun arr ->\r\n      arr |> Array.sortWith (fun (_,v1) (_,v2) -> compare v1 v2)\r\n          |> (if reverse = Some true then Array.rev else id))\r\n\r\n  member s.sortBy(f, ?reverse) =\r\n    s |> helpers.lift (fun arr ->\r\n      arr |> Array.sortWith (fun (_,v1) (_,v2) -> compare (f v1) (f v2))\r\n          |> (if reverse = Some true then Array.rev else id))\r\n\r\n  member s.reverse() =\r\n    s |> helpers.lift (Array.rev)\r\n\r\n  member s.take(count) =\r\n    s |> helpers.lift (fun arr -> slice 0 ((min arr.Length count)-1) arr)\r\n\r\n  member s.skip(count) =\r\n    s |> helpers.lift (fun arr -> slice (min arr.Length count) (arr.Length-1) arr)\r\n\r\n  member s.map(f) =\r\n    s |> helpers.lift (Array.map (fun (k, v) -> k, f v))\r\n(*\r\n  member s.mapTask(f:'v -> value<'r>) =\r\n    s.set(async {\r\n      let! arr = s.data\r\n      let res = Array.init arr.Length (fun _ -> None)\r\n      for i in 0 .. arr.Length-1 do\r\n        let! r = (f(snd arr.[i])).value\r\n        res.[i] <- Some r\r\n      return Array.init arr.Length (fun i -> fst arr.[i], res.[i].Value)\r\n    })\r\n*)\r\n  member s.mapKeys(f) =\r\n    s |> helpers.lift (Array.map (fun (k, v) -> f k, v))\r\n\r\n  member s.mapPairs(f) =\r\n    s |> helpers.lift (Array.map (fun (k, v) -> k, f k v))\r\n\r\n  member s.filter(f) =\r\n    s |> helpers.lift (Array.filter (snd >> f))\r\n\r\n  member s.choose(f) =\r\n    s |> helpers.lift (Array.choose (fun (k, v) -> match f v with None -> None | Some r -> Some(k, r)))\r\n\r\n  member s.joinOuter<'v2>(s2:series<'k, 'v2>) : series<'k, 'v option * 'v2 option>=\r\n    let data = async {\r\n      let! v1 = s.data |> Async.AwaitFuture\r\n      let! v2 = s2.data |> Async.AwaitFuture\r\n      return zipAny v1 v2 }\r\n    series<obj,obj>.create(data, s.keyName, \"Values\", s.seriesName + \" and \" + s2.seriesName)\r\n\r\n  member s.joinInner<'v2>(s2:series<'k, 'v2>) : series<'k, 'v * 'v2>=\r\n    s.joinOuter(s2).choose(function Some(v1), Some(v2) -> Some((v1, v2)) | _ -> None)\r\n\r\n  member s.appendScalar(key:'k, value:'v) =\r\n    s |> helpers.lift (fun arr -> Array.append arr [| key, value |])\r\n(*\r\n  member s.appendValue(key:'k, value:value<'v>) =\r\n    s.set(async {\r\n      let! arr = s.data\r\n      let! v = value.value\r\n      return Array.append arr [| key, v |] })\r\n*)\r\n  member s.append(s2:series<'k, 'v>) =\r\n    s.set(async {\r\n      let! arr1 = s.data |> Async.AwaitFuture\r\n      let! arr2 = s2.data |> Async.AwaitFuture\r\n      return Array.append arr1 arr2 } |> Async.StartAsFuture)\r\n(*\r\n  member s.last() =\r\n    s |> helpers.liftAggregation (fun arr -> snd arr.[arr.Length - 1])\r\n\r\n  member s.first() =\r\n    s |> helpers.liftAggregation (fun arr -> snd arr.[0])\r\n\r\n  member s.minBy(f) =\r\n    s |> helpers.liftAggregation (Array.minBy (fun (k, v) -> f v))\r\n\r\n  member s.maxBy(f) =\r\n    s |> helpers.liftAggregation (Array.maxBy (fun (k, v) -> f v))\r\n*)\r\n  member s.realign(newKeys:series<'k, 'v>, defaultValue) = \r\n    s |> helpers.asyncLift (fun arr -> async {\r\n      let! newKeys = newKeys.data |> Async.AwaitFuture\r\n      let newKeys = newKeys |> Array.map (fun (k, v) -> unbox<System.IComparable> v)\r\n      let lookup = Map.ofArray (unbox<(System.IComparable * 'v)[]> arr)\r\n      return newKeys |> Array.map (fun k ->\r\n        match lookup.TryFind k with\r\n        | Some res -> unbox<'k> k, res\r\n        | None -> unbox<'k> k, defaultValue) })\r\n\r\n  member s.preview() = s.take(10)\r\n      \r\n(*\r\nopen System.Runtime.CompilerServices\r\n\r\n[<Extension>]\r\ntype SeriesExtensions =\r\n  [<Extension>]\r\n  static member sum(s:series<'k, float>) =\r\n    s |> helpers.liftAggregation (Array.sumBy snd)\r\n\r\n  [<Extension>]\r\n  static member series(values:seq<'v>) =\r\n    let getKey i (v:'v) =\r\n      let name = getProperty<string> v \"name\"\r\n      let id = getProperty<string> v \"id\"\r\n      if not (isNull name) then name\r\n        elif not (isNull id) then id\r\n          else string i\r\n    let data = async { return values |> Array.ofSeq |> Array.mapi (fun i v -> getKey i v, v) }\r\n    series.create(data, \"Key\", \"Value\", \"Series\")\r\n\r\n  [<Extension>]\r\n  static member series(values:list<'v>) =\r\n     SeriesExtensions.series(values :> seq<_>)\r\n[<Extension>]\r\ntype ListExtensions =\r\n  [<Extension>]\r\n  static member map(list, f) = List.map f list\r\n\r\n[<Extension>]\r\ntype TupleExtensions =\r\n  [<Extension>]\r\n  static member map((a,b), f) = (f a, f b)\r\n  [<Extension>]\r\n  static member map((a,b,c), f) = (f a, f b, f c)\r\n  [<Extension>]\r\n  static member map((a,b,c,d), f) = (f a, f b, f c, f d)\r\n  [<Extension>]\r\n  static member map((a,b,c,d,e), f) = (f a, f b, f c, f d, f e)\r\n  [<Extension>]\r\n  static member map((a,b,c,d,e,g), f) = (f a, f b, f c, f d, f e, f g)\r\n  [<Extension>]\r\n  static member map((a,b,c,d,e,g,h), f) = (f a, f b, f c, f d, f e, f g, f h)\r\n  *)"]}