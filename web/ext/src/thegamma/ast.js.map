{"version":3,"sources":["../../../src/thegamma/ast.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;kCAAA;AAAA;;AAAA;AAAA,G;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;0BA2GU;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAC,SAAD;AAAA;AAAC;AAAA;;;;;;;;wCA3GX;AAAA;;AAAA;AAAA;AAAA,G;;;;4BAAA;AAAA;;AAAA;AAAA;AAAA,G;;;;AA4HO;AA5HP,6CA8HI;AAAA,wBAAU,yCAAV,EAAuC,iCAAvC;AAA0D,KA9H9D;;AAAA,mDAgII;AAAA,cAAC,6BAA8B,uBAA9B,QAAD,WACC,8BAA+B,sBAA/B,QADD;AACuD,KAjI3D;;AA4HO;AA5HP,GA4HO","file":"ast.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿// ------------------------------------------------------------------------------------------------\r\n// \r\n// ------------------------------------------------------------------------------------------------\r\n\r\nnamespace TheGamma\r\nopen Fable.Extensions\r\n\r\ntype Range = \r\n  { Start : int\r\n    End : int }\r\n\r\ntype Error<'Range> =\r\n  { Number : int\r\n    Message : string\r\n    Range : 'Range }\r\n\r\ntype [<RequireQualifiedAccess>] Operator = \r\n  | Plus\r\n  | Minus\r\n  | Multiply\r\n  | Divide\r\n  | GreaterThan\r\n  | LessThan\r\n  | GreaterThanOrEqual\r\n  | LessThanOrEqual\r\n\r\ntype [<RequireQualifiedAccess>] TokenKind = \r\n  | LParen\r\n  | RParen\r\n  | Equals\r\n  | Dot\r\n  | Comma\r\n  | Let\r\n  | LSquare\r\n  | RSquare\r\n  | Fun\r\n  | Arrow\r\n  | To\r\n  | By\r\n  | Operator of Operator\r\n  | Boolean of bool\r\n  | Number of string * float\r\n  | String of string\r\n  | Ident of string\r\n  | QIdent of string\r\n  | White of string\r\n  | Newline\r\n  | Error of char\r\n\r\ntype Token = \r\n  { Token : TokenKind \r\n    Range : Range }\r\n\r\ntype Name = \r\n  { Name : string\r\n    Range : Range }\r\n\r\ntype Argument<'T> = \r\n  { Name : Name option\r\n    Value : Expr<'T> }\r\n\r\nand Command<'T> = \r\n  { Command : CommandKind<'T>\r\n    Range : Range }\r\n\r\nand CommandKind<'T> = \r\n  | Let of Name * Expr<'T>\r\n  | Expr of Expr<'T>\r\n\r\nand [<RequireQualifiedAccess>] ExprKind<'T> = \r\n  | Variable of Name\r\n  | Property of Expr<'T> * Name\r\n  | Call of Expr<'T> * Name * Argument<'T> list\r\n  | Function of Name * Expr<'T>\r\n  | String of string\r\n  | Number of float\r\n  | Boolean of bool\r\n  | List of Expr<'T> list\r\n  | Empty\r\n  | Unit\r\n  | Null\r\n\r\nand Expr<'T> =\r\n  { Expr : ExprKind<'T>\r\n    Range : Range \r\n    Type : 'T }\r\n\r\ntype Program<'T> = \r\n  { Body : Command<'T> list \r\n    Range : Range }\r\n\r\n\r\ntype Emitter = \r\n  { Emit : Babel.Expression * (string * Babel.Expression) list -> Babel.Expression }\r\n\r\ntype Schema = \r\n  { Type : string; JSON : obj }\r\n\r\ntype [<RequireQualifiedAccess>] Documentation = \r\n  | Text of string\r\n  | Details of string * string\r\n  | None \r\n\r\ntype [<RequireQualifiedAccess>] Member = \r\n  | Property of name:string * typ:Type * schema:Schema option * docs:Documentation * emitter:Emitter\r\n  | Method of name:string * typars:string list * arguments:(string * bool * Type) list * typ:Type * docs:Documentation * emitter:Emitter\r\n  member x.Name = \r\n    match x with Property(name=s) | Method(name=s) -> s\r\n\r\nand ObjectType = \r\n  { Members : Member[] \r\n    Typeargs : Type list }\r\n\r\nand [<RequireQualifiedAccess>] Type =\r\n  | Delayed of guid:string * Future<Type>\r\n  | Primitive of string\r\n  | Object of ObjectType\r\n  | Function of arguments:Type list * returns:Type\r\n  | Parameter of string\r\n  | List of elementType:Type\r\n  | Unit\r\n  | Any\r\n\r\n\r\nmodule Ranges = \r\n  let unionRanges r1 r2 =\r\n    { Start = min r1.Start r2.Start; End = max r1.End r2.End }\r\n  let strictSubRange first second = \r\n    (first.Start > second.Start && first.End <= second.End) ||\r\n    (first.Start >= second.Start && first.End < second.End)\r\n"]}