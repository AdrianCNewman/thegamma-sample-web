{"version":3,"sources":["../../../src/thegamma/parser.fs"],"names":[],"mappings":"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","file":"parser.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿// ------------------------------------------------------------------------------------------------\r\n// turns list<Token> into Expr\r\n// ------------------------------------------------------------------------------------------------\r\nmodule TheGamma.Parser\r\n\r\nopen TheGamma\r\nopen TheGamma.Parsec\r\n\r\nlet anyWhite = zeroOrMore (pred (fun t -> match t.Token with TokenKind.Newline | TokenKind.White _ -> true | _ -> false))\r\n\r\nlet anyUntilLineEnd = Parser(fun input ->\r\n  let rec loop input =\r\n    match input with\r\n    | offset, { Token = TokenKind.Newline }::rest -> Some((offset+1, rest), [], ())\r\n    | offset, tok::rest -> loop (offset+1, rest)\r\n    | offset, [] -> Some((offset, []), [], ())\r\n  loop input)\r\n\r\n// Parsing of simple expressions that correspond to tokens\r\nlet token tok = pred (fun t -> t.Token = tok)\r\n\r\nlet optionalOrError err p = \r\n  range (optional p) |> bind (function\r\n    | _, Some v -> unit (Some v)\r\n    | rng, None -> error (err rng) <*>> unit None)\r\n\r\nlet separated sep p =\r\n  p <*> zeroOrMore (sep <*> p)\r\n  |> map (fun (a1, args) -> a1::(List.map snd args))\r\n\r\nlet separatedThen sep p1 p2 =\r\n  p1 <*> zeroOrMore (sep <*> p2)\r\n  |> map (fun (a1, args) -> a1::(List.map snd args))\r\n\r\nlet separatedOrEmpty sep p = \r\n  optional (separated sep p) \r\n  |> map (fun l -> defaultArg l [])\r\n\r\nlet ident =\r\n  anyWhite <*>> range (choose (fun tok ->\r\n    match tok.Token with\r\n    | TokenKind.Ident id\r\n    | TokenKind.QIdent id -> Some(id)\r\n    | _ -> None)) |> map (fun (rng, id) -> { Name = id; Range = rng })\r\n\r\nlet expressionSetter, expression = slot()\r\n\r\nlet argument = \r\n  ( (ident <<*> anyWhite <<*> token TokenKind.Equals <*> expression)\r\n    |> map (fun (name, expr) -> { Name = Some name; Value = expr }) ) <|>\r\n  ( expression\r\n    |> map (fun expr -> { Name = None; Value = expr }) )\r\n\r\nlet argumentList =  \r\n   anyWhite <*>>\r\n   range \r\n    ( token TokenKind.LParen <*>> \r\n      separatedOrEmpty (anyWhite <*> token TokenKind.Comma) argument <<*> \r\n      // Recovery: If we don't find ), just consume everything until the end of line\r\n      ( ignore ( anyWhite <*> token TokenKind.RParen ) <|> \r\n        ( range anyUntilLineEnd \r\n          |> bind (fun (rng, _) -> error (Errors.Parser.missingClosingParen rng)) ) ) )\r\n\r\n\r\ntype CallOrProperty = \r\n  { Name : Name\r\n    Arguments : option<Range * list<Argument<unit>>> }\r\n     \r\nlet callOrProperty =\r\n  ( // Recovery: if the identifier is empty, but there is arg list, continue\r\n    range (ident <*> optional argumentList |> map(fun (id, args) -> Some id, args)) <|> \r\n    range (optional ident <*> argumentList |> map(fun (id, args) -> id, Some args)) )\r\n  |> bind (function\r\n      | _, (Some(name), args) -> unit { Name = name; Arguments = args }\r\n      | rng, (None, args) -> \r\n          error (Errors.Parser.emptyIdentifier rng) <*>>\r\n          unit { Name = { Name = \"\"; Range = rng }; Arguments = args })\r\n\r\nlet callOrPropertyOrNothing = \r\n  callOrProperty <|>\r\n  // Recovery: there is nothing after '.' in method chain\r\n  ( range (unit ()) |> bind (fun (rng, _) ->\r\n      error (Errors.Parser.nothingAfterDot rng) <*>>\r\n      unit { Name = { Name = \"\"; Range = rng; }; Arguments = None }) )\r\n\r\nlet invocationChain =\r\n  separatedThen (anyWhite <*> token TokenKind.Dot) callOrProperty callOrPropertyOrNothing\r\n  |> bind (function \r\n    | first::chain ->\r\n        let inst = { Expr = ExprKind.Variable first.Name; Range = first.Name.Range; Type = () }\r\n        let parsed = chain |> List.fold (fun st item -> \r\n          let expr, r =\r\n            match item.Arguments with\r\n            | Some(arng, args) -> ExprKind.Call(st, item.Name, args), Ranges.unionRanges st.Range (Ranges.unionRanges item.Name.Range arng)\r\n            | None -> ExprKind.Property(st, item.Name), Ranges.unionRanges st.Range item.Name.Range\r\n          { Expr = expr; Range = r; Type = () }) inst\r\n        ( match first.Arguments with\r\n          | Some(rng, _) -> error (Errors.Parser.valueNotAfunction rng first.Name.Name)\r\n          | _ -> unit () ) <*>> unit parsed\r\n    | [] -> \r\n        failwith \"Unexpected: Parsed empty chain\")\r\n\r\n\r\nlet expressionOrNothing = \r\n  map Some expression <|>\r\n  // Recovery: there is nothing after ',' in a list\r\n  ( range (unit ()) |> bind (fun (rng, _) ->\r\n      error (Errors.Parser.nothingAfterComma rng) <*>>\r\n      unit None) )\r\n\r\nlet list =\r\n  anyWhite <*>> range (token TokenKind.LSquare <*>>\r\n    separatedThen (anyWhite <*> token TokenKind.Comma) (map Some expression) expressionOrNothing <<*> \r\n    anyWhite <<*> (optionalOrError Errors.Parser.missingClosingSquare (token TokenKind.RSquare)))\r\n  |> map (fun (rng, items) ->\r\n    { Range = rng; Type = (); Expr = ExprKind.List(List.choose id items) } )\r\n\r\nlet lambda = \r\n  anyWhite <*>> \r\n    range (token TokenKind.Fun <*>> anyWhite <*>> ident <*> \r\n      (anyWhite <*>> token TokenKind.Arrow <*>> anyWhite <*>> expression))\r\n  |> map (fun (rng, (var, body)) -> \r\n    { Range = rng; Type = (); Expr = ExprKind.Function(var, body) })\r\n\r\nlet number = \r\n  anyWhite <*>> choose (function \r\n    | { Token = TokenKind.Number(_, n); Range = rng } -> \r\n        Some { Expr = ExprKind.Number(n); Range = rng; Type = () }\r\n    | _ -> None)\r\n\r\nlet string = \r\n  anyWhite <*>> choose (function \r\n    | { Token = TokenKind.String(n); Range = rng } -> \r\n        Some { Expr = ExprKind.String(n); Range = rng; Type = () }\r\n    | _ -> None)\r\n\r\nlet boolean = \r\n  anyWhite <*>> choose (function \r\n    | { Token = TokenKind.Boolean(b); Range = rng } -> \r\n        Some { Expr = ExprKind.Boolean(b); Range = rng; Type = () }\r\n    | _ -> None)\r\n\r\nlet listrange =\r\n  anyWhite <*>> \r\n    range (token TokenKind.LSquare <*>> anyWhite <*>>\r\n      number <<*> anyWhite <<*> token TokenKind.To <<*> anyWhite <*>\r\n          optional (number <<*> anyWhite <*>\r\n            optional (token TokenKind.By <*>> anyWhite <*>>\r\n              optional (number <<*> anyWhite))) <<*>\r\n          optionalOrError Errors.Parser.missingClosingSquare (token TokenKind.RSquare))\r\n  |> bind (fun (rng, e) ->\r\n    let getNum = function { Expr = ExprKind.Number n } -> n | _ -> failwith \"expected number\"\r\n    let asNum n = { Expr = ExprKind.Number n; Type = (); Range = rng }\r\n    match e with\r\n    | efrom, Some (eto, Some (Some (estep))) ->         \r\n        unit { Type = (); Range = rng; Expr = ExprKind.List(List.map asNum [getNum efrom .. getNum estep .. getNum eto]) }\r\n    | efrom, Some (eto, None) ->         \r\n        unit { Type = (); Range = rng; Expr = ExprKind.List(List.map asNum [getNum efrom .. getNum eto]) }\r\n    | _ ->\r\n        error (Errors.Parser.incompleteRange rng) <*>>\r\n        unit { Type = (); Range = rng; Expr = ExprKind.List([asNum 0.0]) })\r\n\r\nlet declaration = \r\n  anyWhite <*>> token TokenKind.Let <*>> ident <<*> anyWhite <<*> token TokenKind.Equals <*> expression\r\n\r\nlet letBinding =\r\n  range declaration\r\n  |> map (fun (rng, (name, expr)) -> \r\n      { Command = CommandKind.Let(name, expr); Range = rng })\r\n\r\nexpressionSetter.Set\r\n  ( anyWhite <*>> \r\n    ( invocationChain <|> \r\n      listrange <|>\r\n      list <|>\r\n      lambda <|>\r\n      number <|>\r\n      string <|>\r\n      boolean ) )\r\n\r\nlet program =\r\n  sequenceChoices\r\n    [ expression |> map (fun e -> { Command = CommandKind.Expr e; Range = e.Range })\r\n      letBinding ] <<*> anyWhite\r\n  |> range\r\n  |> map (fun (rng, cmds) -> { Body = cmds; Range = rng })\r\n\r\n(*\r\nlet var = \r\n  choose (function { Token = TokenKind.Ident id; Range = r } -> Some { Expr = ExprKind.Variable id } | _ -> None)\r\nlet qvar = \r\n  choose (function Token.QIdent id -> Some(Typed.Typed((), Expr.QVar id)) | _ -> None)\r\nlet integer = \r\n  choose (function Token.Number n -> Some(Typed.Typed((), Expr.Number n)) | _ -> None)\r\nlet op = \r\n  choose (function Token.Operator s -> Some s | _ -> None)\r\n\r\n// Parsing of patterns\r\nlet patIdent =\r\n  ( choose (function Token.Ident id -> Some(Pattern.Var id) | _ -> None) <|>\r\n    choose (function Token.QIdent id -> Some(Pattern.QVar id) | _ -> None) )\r\n  |> map (fun p -> TypedPat((), p))\r\n\r\nlet rec patNested () = \r\n  ( token Token.LParen <*>\r\n    pattern () <*>\r\n    token Token.RParen )\r\n  |> map (fun ((_, p), _) -> p)\r\n\r\nlet patOneOrTuple () = \r\n  ( patIdent <*>\r\n    zeroOrMore (token Token.Comma <*> pattern ()) )\r\n  |> map (fun (p, ps) -> \r\n    match ps with \r\n    | [] -> p\r\n    | ps -> TypedPat((), Pattern.Tuple(p :: (List.map snd ps))) )\r\n  \r\nlet pattern () = delay (fun () ->\r\n  patNested () <|> patOneOrTuple ())\r\n  \r\n\r\n// Parsing of function applications let operators\r\ntype Associativity = Left | Right\r\n\r\nlet precedence = function\r\n  | \"+\" | \"-\" -> 1, Left\r\n  | \"*\" | \"/\" -> 2, Left\r\n  | \"^\" -> 3, Right\r\n  | _ -> failwith \"Invalid operator name in <code>Parser.precedence</code>.\"\r\n\r\n/// Represnts a sequence of expressions separated by binary operators\r\n/// (e.g. 'f x + 1 * 2 / g y' has 4 expressions separated by 3 operators)\r\ntype OpExpr = OpExpr of Typed<unit> * option<string * OpExpr>\r\n\r\n/// Turn 'OpExpr' into a parsed 'Expr' using the \"Precedence climbing method\"\r\n/// (see https://en.wikipedia.org/wiki/Operator-precedence_parser)\r\nlet rec buildExpr minPrec (OpExpr(app, next)) = \r\n  let rec loop result next = \r\n    match next with \r\n    | Some(op, next) when fst (precedence op) >= minPrec ->\r\n        let prec, assoc = precedence op\r\n        let nextMinPrec = \r\n          if assoc = Left then prec + 1 else prec\r\n        let rhs, next = buildExpr nextMinPrec next\r\n        let result = Typed.Typed((), Expr.Binary(op, result, rhs))\r\n        loop result next\r\n    | _ -> result, next      \r\n  loop app next\r\n\r\n/// Parse '<term> <term> .. <term>' representing function application\r\nlet rec apps () = \r\n  oneOrMore (term ()) |> map (fun t -> \r\n      List.tail t |> List.fold (fun st v -> Typed.Typed((), Expr.App(st, v))) (List.head t))\r\n\r\n/// Parse '<apps> <op> <apps> .. <apps>' representing expression with operators\r\nlet opExpr () = delay (fun () ->\r\n  apps() <*> (optional (op <*> opExpr ()))\r\n  |> map (fun (hd, tl) -> OpExpr(hd, tl)) )\r\n\r\n/// Parse the same as 'opExpr' let then turn it into 'Expr' using 'buildExpr'\r\nlet expr () = \r\n  ( opExpr () <*> \r\n    zeroOrMore (token Token.Comma <*> opExpr ()) )\r\n  |> map (fun (e, es) ->\r\n      let exprs = e::(List.map snd es) |> List.map (buildExpr 1 >> fst)\r\n      match exprs with \r\n      | [e] -> e\r\n      | es -> Typed((), Expr.Tuple(es)) )\r\n\r\n/// Parse an expression wrapped in brackets\r\nlet bracketed () = delay (fun () ->\r\n  ( token Token.LParen <*>\r\n    expr () <*>\r\n    token Token.RParen )\r\n  |> map (fun ((_, e), _) -> e) )\r\n\r\n/// Parse let binding of the form 'let <pat> = <expr> in <expr>'\r\nlet binding () = delay (fun () ->\r\n  ( token Token.Let <*>\r\n    zeroOrMore(pattern ()) <*>\r\n    token Token.Equals <*>\r\n    expr () <*>\r\n    token Token.In <*>\r\n    expr () )\r\n  |> map (fun (((((_, pats), _), assign), _), body) ->\r\n    let pat, pats = List.head pats, List.rev (List.tail pats)\r\n    let assign = pats |> List.fold (fun assign pat -> Typed.Typed((), Expr.Fun(pat, assign))) assign\r\n    Typed.Typed((), Expr.Let(pat, assign, body))) )\r\n\r\n/// Parse a function of the form 'fun <pat> .. <pat> -> <expr>'\r\nlet func () = delay (fun () ->\r\n  ( token Token.Fun <*>\r\n    oneOrMore (pattern ()) <*>\r\n    token Token.Arrow <*>\r\n    expr () )\r\n  |> map (fun (((_, pats), _), body) -> \r\n    pats |> List.rev |> List.fold (fun body pat -> Typed.Typed((), Expr.Fun(pat, body))) body )) \r\n\r\nlet prev () = delay (fun () ->\r\n  ( token Token.Prev <*>\r\n    term () )\r\n  |> map (fun (_, body) ->\r\n    Typed.Typed((), Expr.Prev(body)) ))\r\n\r\n/// Parse a term (this handles most of the usual expressions)\r\nlet term () = delay (fun () ->\r\n  func () <|>\r\n  integer <|>\r\n  var <|> \r\n  qvar <|>\r\n  prev () <|>\r\n  binding () <|>\r\n  bracketed () )\r\n *)"]}