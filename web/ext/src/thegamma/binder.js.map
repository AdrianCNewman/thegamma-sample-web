{"version":3,"sources":["../../../src/thegamma/binder.fs"],"names":[],"mappings":"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","file":"binder.js","sourceRoot":"C:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿// ------------------------------------------------------------------------------------------------\r\n// Binder attaches `Entity` objects to `Node` objects produced by the parser\r\n// Entities are reused when possible and contain inferred types etc.\r\n// ------------------------------------------------------------------------------------------------\r\nmodule TheGamma.Binder\r\n\r\nopen TheGamma.Ast\r\nopen TheGamma.Common\r\n\r\n/// As we bind, we keep root entity, current scope & variables in scope\r\ntype BindingContext = \r\n  { Variables : Map<Name, Entity>  \r\n    Scope : Entity\r\n    Root : Entity\r\n    /// Table with previously created entities. This is a mutable mapping from \r\n    /// list of symbols (antecedent entities) together with entity kind & name\r\n    /// to the actual entity. Antecedents capture dependencies (if dependency \r\n    /// changed, we need to recreate the entity that depends on them)\r\n    Table : ListDictionary<Symbol, Map<EntityKind * Name, Entity>> \r\n    /// Collects all bound entities and their ranges\r\n    Bound : ResizeArray<Range * Entity> }\r\n\r\n\r\n/// Lookup entity (if it can be reused) or create & cache a new one\r\nlet bindEntity ctx kind antecedents name =\r\n  let symbols = antecedents |> List.map (fun a -> a.Symbol)\r\n  let nestedDict = \r\n    match ListDictionary.tryFind symbols ctx.Table with\r\n    | None -> Map.empty\r\n    | Some res -> res\r\n  if nestedDict.ContainsKey (kind, name) then \r\n    Log.trace(\"binder\", \"Cached: binding %s %s\", formatEntityKind kind, name.Name)\r\n    nestedDict.[kind, name]\r\n  else\r\n    Log.trace(\"binder\", \"New: binding %s %s\", formatEntityKind kind, name.Name)\r\n    let symbol = createSymbol ()\r\n    let entity = { Kind = kind; Antecedents = antecedents; Name = name; Symbol = symbol; Type = None; Errors = [] }\r\n    ListDictionary.set symbols (Map.add (kind, name) entity nestedDict) ctx.Table\r\n    entity    \r\n\r\n/// Assign entity to a node in parse tree\r\nlet setEntity ctx node entity = \r\n  ctx.Bound.Add(node.Range, entity)\r\n  node.Entity <- Some entity\r\n  entity\r\n\r\n/// Used for entities with no name\r\nlet anonymous = { Name.Name = \"\" }\r\n\r\n/// Bind entities to expressions in the parse tree\r\n/// (See `EntityKind` for explanation of how the entity tree looks like)\r\nlet rec bindExpression callSite ctx node = \r\n  let bindCallArgExpression site = bindExpression (Some site)\r\n  let bindExpression = bindExpression None\r\n  match node.Node with\r\n  | Expr.Variable(name) ->\r\n      match ctx.Variables.TryFind name.Node with \r\n      | Some decl -> bindEntity ctx EntityKind.Variable [decl] name.Node |> setEntity ctx node\r\n      | None -> bindEntity ctx EntityKind.GlobalValue [ctx.Scope] name.Node |> setEntity ctx node\r\n\r\n  | Expr.Call(instExpr, name, argsNode) ->\r\n      // Bind instance & create call site that depends on it\r\n      let inst = defaultArg (Option.map (bindExpression ctx) instExpr) ctx.Root\r\n      let site arg = bindEntity ctx (EntityKind.CallSite arg) [inst] name.Node\r\n      // Bind arguments - which depend on the call site\r\n      let args = argsNode.Node |> List.mapi (fun idx arg -> \r\n        let site = site (match arg.Name with Some n -> Choice1Of2 n.Node.Name | _ -> Choice2Of2 idx)\r\n        let expr = bindCallArgExpression site ctx arg.Value\r\n        match arg.Name with \r\n        | Some n -> bindEntity ctx EntityKind.NamedParam [expr] n.Node |> setEntity ctx n\r\n        | None -> expr)\r\n      let args = bindEntity ctx EntityKind.ArgumentList (ctx.Root::args) anonymous |> setEntity ctx argsNode\r\n      let named = bindEntity ctx EntityKind.NamedMember [ctx.Root] name.Node |> setEntity ctx name\r\n      bindEntity ctx (EntityKind.ChainElement(instExpr.IsSome, false)) [named; inst; args] name.Node |> setEntity ctx node \r\n\r\n  | Expr.Property(expr, name) ->\r\n      let ante = bindExpression ctx expr\r\n      let named = bindEntity ctx EntityKind.NamedMember [ctx.Root] name.Node |> setEntity ctx name      \r\n      bindEntity ctx (EntityKind.ChainElement(true, true)) [named; ante] name.Node |> setEntity ctx node \r\n\r\n  | Expr.Binary(l, op, r) ->\r\n      let lentity = bindExpression ctx l\r\n      let rentity = bindExpression ctx r\r\n      bindEntity ctx (EntityKind.Operator op.Node) [lentity; rentity] anonymous |> setEntity ctx node\r\n\r\n  | Expr.List(els) ->\r\n      let entities = els |> List.map (bindExpression ctx)      \r\n      bindEntity ctx EntityKind.List entities anonymous |> setEntity ctx node\r\n\r\n  | Expr.Function(v, e) ->\r\n      let scope = bindEntity ctx EntityKind.Scope [ctx.Scope] anonymous\r\n      let varParent = match callSite with None -> [scope] | Some s -> [s]\r\n      let var = bindEntity ctx EntityKind.Binding varParent v.Node |> setEntity ctx v\r\n      let body = bindExpression { ctx with Variables = Map.add v.Node var ctx.Variables } e\r\n      bindEntity ctx EntityKind.Function [var; body] anonymous |> setEntity ctx node\r\n\r\n  | Expr.Boolean b -> bindEntity ctx (EntityKind.Constant (Constant.Boolean b)) [ctx.Root] anonymous |> setEntity ctx node\r\n  | Expr.String s -> bindEntity ctx (EntityKind.Constant (Constant.String s)) [ctx.Root] anonymous |> setEntity ctx node\r\n  | Expr.Number n -> bindEntity ctx (EntityKind.Constant (Constant.Number n)) [ctx.Root] anonymous |> setEntity ctx node\r\n  | Expr.Empty -> bindEntity ctx (EntityKind.Constant Constant.Empty) [ctx.Root] anonymous |> setEntity ctx node\r\n\r\n/// Bind entities to a command in a parse tree. The handling of `let` is similar\r\n/// to the handling of lambda abstraction. This adds variables to context - we ignore\r\n/// bound entities, because nothing depends on it (except via variables)\r\nlet bindCommand ctx node =\r\n  match node.Node with\r\n  | Command.Let(v, e) ->\r\n      let body = bindExpression None ctx e \r\n      let scope = bindEntity ctx EntityKind.Scope [ctx.Scope] anonymous\r\n      let var = bindEntity ctx EntityKind.Variable [body] v.Node |> setEntity ctx v\r\n      bindEntity ctx EntityKind.Command [var; body] anonymous |> setEntity ctx node |> ignore\r\n      { ctx with Variables = Map.add v.Node var ctx.Variables }\r\n\r\n  | Command.Expr(e) ->\r\n      let body = bindExpression None ctx e \r\n      bindEntity ctx EntityKind.Command [body] anonymous|> setEntity ctx node |> ignore\r\n      ctx\r\n\r\n/// Bind entities to all nodes in the program\r\nlet bindProgram ctx (program:Program) =\r\n  ctx.Bound.Clear()\r\n  program.Body.Node |> List.fold bindCommand ctx |> ignore\r\n  ctx.Bound.ToArray()\r\n  \r\n/// Create a new binding context - this stores cached entities\r\nlet createContext name =\r\n  let root = \r\n    { Kind = EntityKind.Root; Antecedents = []; Errors = []\r\n      Name = { Name = name }; Symbol = createSymbol(); Type = None }\r\n  { Table = System.Collections.Generic.Dictionary<_, _>(); \r\n    Bound = ResizeArray<_>(); Variables = Map.empty; \r\n    Scope = root; Root = root }\r\n"]}