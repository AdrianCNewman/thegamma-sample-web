{"version":3,"sources":["../../../src/thegamma/monaco.fs"],"names":[],"mappings":"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","file":"monaco.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Monaco\r\n\r\nopen Fable.Core\r\nopen Fable.Import.monaco\r\nopen Fable.Import.Browser\r\n\r\nopen TheGamma.Common\r\nopen TheGamma.Services\r\nopen TheGamma.TypeChecker\r\n\r\ntype LocationMapper(code:string) = \r\n  let lengths = code.Split('\\n') |> Array.map (fun s -> s.Length)\r\n\r\n  /// Convert absolute 0-based location to 1-based line and 1-based column location\r\n  member x.AbsoluteToLineCol(offs) = \r\n    let mutable line = 0\r\n    let mutable col = 0\r\n    let mutable offs = offs\r\n    while line <= lengths.Length && offs > lengths.[line] do\r\n      offs <- offs - lengths.[line] - 1\r\n      line <- line + 1\r\n    line + 1, offs + 1\r\n\r\n  /// Convert 1-based line and 1-based column location to an absolute 0-based location\r\n  member x.LineColToAbsolute(line, col) = \r\n    let mutable offs = 0\r\n    for l in 1 .. line-1 do offs <- offs + lengths.[l-1] + 1\r\n    offs + col - 1\r\n\r\n[<Emit(\"_monaco = monaco;\")>]\r\nlet hack : unit = ()\r\nhack\r\n\r\nlet noState = \r\n  { new languages.IState with\r\n      member this.clone() = this\r\n      member this.equals(other) = true }\r\n\r\nlet getColorClass = function\r\n  | TokenKind.String _ -> \"string\" \r\n  | TokenKind.QIdent _ | TokenKind.Ident _ -> \"ident\" \r\n  | TokenKind.Dot _ -> \"operator\" \r\n  | TokenKind.By | TokenKind.To | TokenKind.Let \r\n  | TokenKind.Boolean _ | TokenKind.Fun | TokenKind.Arrow -> \"keyword\" \r\n  | TokenKind.Number _ -> \"number\" \r\n  | _ -> \"\"\r\n\r\nlet tokensProvider = \r\n  { new languages.TokensProvider with\r\n      member this.tokenize(line, state) =\r\n        let tokens = JsInterop.createEmpty<languages.ILineTokens>\r\n        tokens.endState <- noState\r\n        tokens.tokens <- ResizeArray()\r\n\r\n        let tokenized, _ = Tokenizer.tokenize line\r\n        for t in tokenized do\r\n          let tok = JsInterop.createEmpty<languages.IToken>\r\n          tok.startIndex <- float t.Range.Start\r\n          tok.scopes <- Fable.Core.U2.Case1 (getColorClass t.Token)\r\n          tokens.tokens.Add(tok)\r\n\r\n        tokens\r\n      member this.getInitialState() = noState }\r\n\r\nlet createCompletionProvider (getService:string -> CheckingService) = \r\n  { new languages.CompletionItemProvider with \r\n      member this.triggerCharacters = Some(ResizeArray [ \".\" ])\r\n      member this.provideCompletionItems(model, position, token) =           \r\n        async {      \r\n          try    \r\n            let svc = getService (model.uri.toString())\r\n\r\n            let input = model.getValue(editor.EndOfLinePreference.LF, false)\r\n            Log.event(\"editor\", \"completions\", \"\", JsInterop.createObj [\"source\", box input; \"position\", box position])\r\n\r\n            let conv = LocationMapper(input)\r\n            let loc = conv.LineColToAbsolute(int position.lineNumber, int position.column)\r\n            \r\n            let! _, ents, _ = svc.TypeCheck(input)\r\n            let optMembers = \r\n              ents.Entities |> Seq.tryPick (fun (rng, ent) ->\r\n                match ent.Kind with \r\n                | EntityKind.NamedMember(_, { Type = Some t }) when loc >= rng.Start && loc <= rng.End + 1 -> \r\n                    Log.trace(\"completions\", \"Antecedant at current location: %O\", t)\r\n                    match Types.reduceType t with\r\n                    | Type.Object { Members = mems } -> Some(rng, mems)\r\n                    | _ -> None\r\n                | EntityKind.NamedMember(n, { Type = Some t })  ->\r\n                    Log.trace(\"completions\", \"Ignoring '%s' at location %s-%s (current=%s)\", n.Name, rng.Start, rng.End, loc)\r\n                    None\r\n                | _ -> None)\r\n\r\n            let convertRange (rng:TheGamma.Range) = \r\n              let sl, sc = conv.AbsoluteToLineCol(rng.Start)\r\n              let el, ec = conv.AbsoluteToLineCol(rng.End)\r\n              let res = JsInterop.createEmpty<IRange>\r\n              res.startColumn <- float sc\r\n              res.startLineNumber <- float sl\r\n              res.endColumn <- float ec + 1.0\r\n              res.endLineNumber <- float el\r\n              res\r\n\r\n            match optMembers with \r\n            | None -> \r\n                Log.trace(\"completions\", \"no members at %s\", loc)\r\n                return ResizeArray []\r\n            | Some (nameRange, members) -> \r\n                let nameRange = convertRange nameRange\r\n                Log.trace(\"completions\", \"providing %s members at %O\", members.Length, nameRange)\r\n                let completion =\r\n                  [ for m in members ->\r\n                      let ci = JsInterop.createEmpty<languages.CompletionItem>\r\n                      let n, k =\r\n                        match m with \r\n                        | Member.Method(name=n) -> n, languages.CompletionItemKind.Method\r\n                        | Member.Property(name=n) -> n, languages.CompletionItemKind.Property\r\n                      ci.kind <- k\r\n                      ci.label <- n\r\n                      ci.insertText <- Some(Ast.escapeIdent n)\r\n                      ci.filterText <- Some(n)\r\n                      match m with\r\n                      | Member.Method(arguments=args) -> \r\n                          let acc, l = \r\n                            [ for n, opt, t in args -> (if opt then \"?\" else \"\") + n ] \r\n                            |> Seq.fold (fun (acc, l:string) s ->\r\n                                if l.Length > 100 then (l::acc, s)\r\n                                else (acc, if l = \"\" then s else l+\",\"+s)) ([], \"\")\r\n                          let args = l::acc |> List.rev |> String.concat \",\\n\"\r\n                          ci.documentation <- Some(\"(\" + args + \")\")\r\n                      | _ -> ()\r\n\r\n                      let eo = JsInterop.createEmpty<editor.ISingleEditOperation>\r\n                      eo.text <- Ast.escapeIdent n\r\n                      eo.range <- nameRange\r\n                      ci.textEdit <- Some eo\r\n                      ci ] \r\n                Log.trace(\"completions\", \"returning %O\", Array.ofSeq completion)\r\n                return ResizeArray(completion)\r\n            with e ->\r\n              Log.exn(\"completions\", \"completions failed %O\", e)\r\n              return ResizeArray() } |> Async.StartAsPromise |> Fable.Core.U4.Case2\r\n\r\n      member this.resolveCompletionItem(item, token) = Fable.Core.U2.Case1 item }\r\n\r\nlet setupMonacoServices (getService : string -> CheckingService) =\r\n  let lang = JsInterop.createEmpty<languages.ILanguageExtensionPoint>\r\n  lang.id <- \"thegamma\"\r\n  languages.Globals.setTokensProvider(\"thegamma\", tokensProvider) |> ignore\r\n  languages.Globals.registerCompletionItemProvider(\"thegamma\", createCompletionProvider getService) |> ignore\r\n  languages.Globals.register(lang)\r\n\r\n\r\nlet createMonacoEditor id code customize = \r\n  let services = JsInterop.createEmpty<editor.IEditorOverrideServices>\r\n  let options = JsInterop.createEmpty<editor.IEditorConstructionOptions>\r\n  let scroll = JsInterop.createEmpty<editor.IEditorScrollbarOptions>\r\n  scroll.vertical <- Some \"none\"\r\n  scroll.horizontal <- Some \"auto\"\r\n  options.scrollbar <- Some scroll\r\n  options.value <- Some code\r\n  options.language <- Some \"thegamma\"\r\n  options.lineNumbersMinChars <- Some 3.0\r\n  options.contextmenu <- Some false\r\n  options.scrollBeyondLastLine <- Some false\r\n  options.overviewRulerLanes <- Some 0.0\r\n  customize options\r\n  editor.Globals.create(document.getElementById(id), options, services)\r\n\r\n\r\n\r\n"]}