{"version":3,"sources":["../../../src/thegamma/monaco.fs"],"names":[],"mappings":"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","file":"monaco.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Monaco\r\n\r\nopen Fable.Core\r\nopen Fable.Import.monaco\r\nopen Fable.Import.Browser\r\nopen TheGamma.TypeChecker\r\nopen Fable.Extensions\r\n\r\n[<Emit(\"_monaco = monaco;\")>]\r\nlet hack : unit = ()\r\nhack\r\n\r\nlet noState = \r\n  { new languages.IState with\r\n      member this.clone() = this\r\n      member this.equals(other) = true }\r\n\r\nlet getColorClass = function\r\n  | TokenKind.String _ -> \"string\" \r\n  | TokenKind.QIdent _ | TokenKind.Ident _ -> \"ident\" \r\n  | TokenKind.Dot _ -> \"operator\" \r\n  | TokenKind.By | TokenKind.To | TokenKind.Let \r\n  | TokenKind.Boolean _ | TokenKind.Fun | TokenKind.Arrow -> \"keyword\" \r\n  | TokenKind.Number _ -> \"number\" \r\n  | _ -> \"\"\r\n\r\nlet tokensProvider = \r\n  { new languages.TokensProvider with\r\n      member this.tokenize(line, state) =\r\n        let tokens = JsInterop.createEmpty<languages.ILineTokens>\r\n        tokens.endState <- noState\r\n        tokens.tokens <- ResizeArray()\r\n\r\n        let _, tokenized = tokenize line\r\n        for t in tokenized do\r\n          let tok = JsInterop.createEmpty<languages.IToken>\r\n          tok.startIndex <- float t.Range.Start\r\n          tok.scopes <- Fable.Core.U2.Case1 (getColorClass t.Token)\r\n          tokens.tokens.Add(tok)\r\n\r\n        tokens\r\n      member this.getInitialState() = noState }\r\n\r\nlet createCompletionProvider globals = \r\n  { new languages.CompletionItemProvider with \r\n      member this.triggerCharacters = Some(ResizeArray [ \".\" ])\r\n      member this.provideCompletionItems(model, position, token) =           \r\n        async {          \r\n          try\r\n            let input = model.getValue(editor.EndOfLinePreference.LF, false)\r\n            Log.event(\"editor\", \"completions\", \"\", JsInterop.createObj [\"source\", box input; \"position\", box position])\r\n            let lines = input.Split('\\n')\r\n            let! globals = Async.AwaitFuture globals\r\n            let! errs, ty = typeCheck globals input\r\n            let! info = TypeChecker.collectProgramInfo { Completions = []; Source = input } ty\r\n            \r\n            let absPosition = \r\n              int position.column - 1 +\r\n                List.fold (+) 0 [ for i in 1 .. int position.lineNumber-1 -> lines.[i-1].Length + 1 ]\r\n  \r\n            let optMembers = \r\n              info.Completions \r\n              |> List.filter (fun (rng, _, _) -> absPosition >= rng.Start && absPosition <= rng.End)\r\n              |> List.sortBy (fun (rng, _, _) -> -rng.Start)\r\n              |> List.tryHead\r\n\r\n            let log = \r\n              [| for r, _, c in info.Completions -> \r\n                  let opts = c |> Seq.truncate 3 |> Seq.map (fun m -> m.Name) |> String.concat \", \"\r\n                  sprintf \"%d - %d: %s...\" r.Start r.End opts |]\r\n            Log.trace(\"completions\", \"requested at: %O\", position)\r\n            Log.trace(\"completions\", \"available: %O\", log)\r\n\r\n            let lengths = lines |> Array.map String.length |> List.ofSeq\r\n\r\n            let convertRange rng = \r\n              let s = CodeGenerator.offsetToLocation 1 rng.Start lengths\r\n              let e = CodeGenerator.offsetToLocation 1 rng.End lengths\r\n              let res = JsInterop.createEmpty<IRange>\r\n              res.startColumn <- float s.column+1.0\r\n              res.startLineNumber <- float s.line\r\n              res.endColumn <- float e.column+1.0\r\n              res.endLineNumber <- float e.line\r\n              res\r\n\r\n            match optMembers with \r\n            | None -> \r\n                Log.trace(\"completions\", \"no members at %s\", absPosition)\r\n                return ResizeArray []\r\n            | Some (_, nameRange, members) -> \r\n                let nameRange = convertRange nameRange\r\n                let completion =\r\n                  [ for m in members ->\r\n                      let ci = JsInterop.createEmpty<languages.CompletionItem>\r\n                      let n, k =\r\n                        match m with \r\n                        | Member.Method(name=n) -> n, languages.CompletionItemKind.Method\r\n                        | Member.Property(name=n) -> n, languages.CompletionItemKind.Property\r\n                      ci.kind <- k\r\n                      ci.label <- n\r\n                      ci.insertText <- Some(if needsEscaping n then \"'\" + n + \"'\" else n)\r\n                      ci.filterText <- Some(n)\r\n                      match m with\r\n                      | Member.Method(arguments=args) -> \r\n                          let acc, l = \r\n                            [ for n, opt, t in args -> (if opt then \"?\" else \"\") + n ] \r\n                            |> Seq.fold (fun (acc, l:string) s ->\r\n                                if l.Length > 100 then (l::acc, s)\r\n                                else (acc, if l = \"\" then s else l+\",\"+s)) ([], \"\")\r\n                          let args = l::acc |> List.rev |> String.concat \",\\n\"\r\n                          ci.documentation <- Some(\"(\" + args + \")\")\r\n                      | _ -> ()\r\n\r\n                      let eo = JsInterop.createEmpty<editor.ISingleEditOperation>\r\n                      eo.text <- if needsEscaping n then \"'\" + n + \"'\" else n\r\n                      eo.range <- nameRange\r\n                      ci.textEdit <- Some eo\r\n                      ci ] \r\n                Log.trace(\"completions\", \"returning %O\", Array.ofSeq completion)\r\n                return ResizeArray(completion)\r\n            with e ->\r\n              Log.exn(\"completions\", \"type checking failed %O\", e)\r\n              return ResizeArray [] } |> Async.StartAsPromise |> Fable.Core.U4.Case2\r\n\r\n      member this.resolveCompletionItem(item, token) = Fable.Core.U2.Case1 item }\r\n\r\nlet setupMonacoServices globals =\r\n  let lang = JsInterop.createEmpty<languages.ILanguageExtensionPoint>\r\n  lang.id <- \"thegamma\"\r\n  languages.Globals.setTokensProvider(\"thegamma\", tokensProvider) |> ignore\r\n  languages.Globals.registerCompletionItemProvider(\"thegamma\", createCompletionProvider globals) |> ignore\r\n  languages.Globals.register(lang)\r\n\r\nlet createMonacoEditor id code customize = \r\n  let services = JsInterop.createEmpty<editor.IEditorOverrideServices>\r\n  let options = JsInterop.createEmpty<editor.IEditorConstructionOptions>\r\n  let scroll = JsInterop.createEmpty<editor.IEditorScrollbarOptions>\r\n  scroll.vertical <- Some \"none\"\r\n  scroll.horizontal <- Some \"auto\"\r\n  options.scrollbar <- Some scroll\r\n  options.value <- Some code\r\n  options.language <- Some \"thegamma\"\r\n  options.lineNumbersMinChars <- Some 3.0\r\n  options.contextmenu <- Some false\r\n  options.scrollBeyondLastLine <- Some false\r\n  options.overviewRulerLanes <- Some 0.0\r\n  customize options\r\n  editor.Globals.create(document.getElementById(id), options, services)\r\n\r\n\r\n\r\n"]}