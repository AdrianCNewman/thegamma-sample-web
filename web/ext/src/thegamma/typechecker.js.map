{"version":3,"sources":["../../../src/thegamma/typechecker.fs"],"names":[],"mappings":"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","file":"typechecker.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["﻿module TheGamma.TypeChecker\r\n\r\nopen TheGamma\r\nopen Fable.Extensions\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Type checking\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype CheckingContext = \r\n  { Variables : Map<string, Type> }\r\n\r\ntype CheckingResult = \r\n  { Errors : Error<Range> list }\r\n\r\nlet addError e ctx = { ctx with Errors = e::ctx.Errors }\r\nlet addVariable k v ctx = { ctx with Variables = Map.add k v ctx.Variables }\r\n\r\nlet rec listsEqual l1 l2 f = \r\n  match l1, l2 with\r\n  | [], [] -> true\r\n  | x::xs, y::ys when f x y -> listsEqual xs ys f\r\n  | _ -> false \r\n\r\nlet rec arraysEqual (l1:_[]) (l2:_[]) f = \r\n  let rec loop i =\r\n    if i = l1.Length && i = l2.Length then true\r\n    elif i < l1.Length && i < l2.Length then \r\n      f (l1.[i]) (l2.[i]) && loop (i+1)\r\n    else false\r\n  loop 0\r\n\r\nlet rec membersEqual m1 m2 = // Ignoring types, because generics make that hard\r\n  match m1, m2 with \r\n  | Member.Property(n1, t1, s1, d1, _), Member.Property(n2, t2, s2, d2, _) -> n1 = n2 && s1 = s2 && d1 = d2 // && typesEqual t1 t2\r\n  | Member.Method(n1, t1, a1, r1, d1, _), Member.Method(n2, t2, a2, r2, d2, _) -> \r\n      n1 = n2 && d1 = d2 && // t1 = t2 && typesEqual r1 r2 && \r\n        listsEqual a1 a2 (fun (s1, b1, t1) (s2, b2, t2) -> \r\n          s1 = s2 && b1 = b2(* && typesEqual t1 t2 *) )\r\n  | _ -> false\r\n\r\nand typesEqual t1 t2 = \r\n  match t1, t2 with\r\n  | Type.Any, Type.Any -> true\r\n  | Type.Delayed(g1, _), Type.Delayed(g2, _) -> g1 = g2\r\n  | Type.Function(a1, r1), Type.Function(a2, r2) -> \r\n      listsEqual (r1::a1) (r2::a2) typesEqual\r\n  | Type.Object(o1), Type.Object(o2) -> \r\n      listsEqual o1.Typeargs o2.Typeargs typesEqual &&\r\n      arraysEqual o1.Members o2.Members membersEqual\r\n  | Type.Parameter n1, Type.Parameter n2 -> n1 = n2\r\n  | Type.Primitive n1, Type.Primitive n2 -> n1 = n2\r\n  | Type.Unit, Type.Unit -> true\r\n  | _ -> false\r\n\r\ntype ObjectMembers = \r\n  | Members of Member[]\r\n  | NotAnObject\r\n  | SilentError\r\n\r\nlet rec getObjectMembers t = async {\r\n  match t with\r\n  | Type.Delayed(_, f) ->\r\n      let! t = Async.AwaitFuture f\r\n      return! getObjectMembers t \r\n  | Type.Object(o) -> return Members(o.Members)\r\n  | Type.Unit\r\n  | Type.Parameter _\r\n  | Type.Function _\r\n  | Type.List _\r\n  | Type.Primitive _ -> return NotAnObject\r\n  | Type.Any _ -> return SilentError }\r\n\r\nlet rec unifyTypes assigns ts1 ts2 =\r\n  match ts1, ts2 with\r\n  | Type.Delayed(id1, f1)::ts1, Type.Delayed(id2, f2)::ts2 -> async {\r\n      let! o1 = f1 |> Async.AwaitFuture\r\n      let! o2 = f2 |> Async.AwaitFuture\r\n      return! unifyTypes assigns (o1::ts1) (o2::ts2) }      \r\n      \r\n  | t1::ts1, t2::ts2 when typesEqual t1 t2 -> unifyTypes assigns ts1 ts2\r\n\r\n  | Type.Object(o1)::ts1, Type.Object(o2)::ts2 when arraysEqual o1.Members o2.Members membersEqual ->\r\n      unifyTypes assigns (o1.Typeargs @ ts1) (o2.Typeargs @ ts2)\r\n  | Type.Any::ts1, t::ts2 | t::ts1, Type.Any::ts2 -> unifyTypes assigns ts1 ts2\r\n  | (Type.Parameter n)::ts1, t::ts2 | t::ts1, (Type.Parameter n)::ts2 -> \r\n      unifyTypes ((n, t)::assigns) ts1 ts2\r\n  | Type.Function(tis1, to1)::ts1, Type.Function(tis2, to2)::ts2 ->\r\n      unifyTypes assigns (to1::tis1 @ ts1) (to2::tis2 @ ts2)\r\n  | Type.List(t1)::ts1, Type.List(t2)::ts2 -> \r\n      unifyTypes assigns (t1::ts1) (t2::ts2)\r\n  | [], [] -> \r\n      async { return (fun res rng -> assigns, res) }\r\n  | ts1, ts2 -> \r\n      async { return (fun res rng ->\r\n          Log.error(\"typechecker\", \"Cannot unify types: %O and %O\", Array.ofList ts1, Array.ofList ts2)\r\n          assigns, addError (Errors.TypeChecker.cannotUnityTypes rng) res) }\r\n\r\nlet avoidCapture bound assigns =\r\n  let renames = bound |> List.choose (fun n -> \r\n    let assigned = Map.tryFindKey (fun k v -> match v with Type.Parameter nn -> n = nn | _ -> false) assigns\r\n    if assigned.IsSome then Some(n, n + \"0\") else None) \r\n  renames |> List.fold (fun assigns (o, n) -> Map.add o (Type.Parameter n) assigns) assigns,\r\n  Map.ofSeq renames   \r\n\r\nlet rec substituteMembers assigns members = \r\n  members |> Array.map (function\r\n    | Member.Method(n,tp,ars,t,d,e) -> \r\n        let assigns0 = assigns\r\n        let assigns, renames = avoidCapture tp assigns\r\n        // Log.trace(\"typechecker\", \"Substituting in %s<%s>, renaming: %O, assings: %O\", n, String.concat \",\" tp, Map.toArray renames, Map.toArray assigns0)\r\n        let tp = tp |> List.map (fun tp -> match Map.tryFind tp renames with Some r -> r | _ -> tp)\r\n        let nars = ars |> List.map (fun (n,o,t) -> n, o, substituteTypes assigns t)\r\n        Member.Method(n,tp,nars,substituteTypes assigns t,d,e)\r\n    | Member.Property(n,t,s,d,e) -> Member.Property(n,substituteTypes assigns t,s,d,e))      \r\n\r\nand substituteTypes assigns t =\r\n  match t with\r\n  | Type.Parameter s when Map.containsKey s assigns -> assigns.[s]\r\n  | Type.Parameter _ | Type.Any | Type.Primitive _ | Type.Unit -> t\r\n  | Type.Function(ts, t) -> Type.Function(List.map (substituteTypes assigns) ts, substituteTypes assigns t)\r\n  | Type.List(t) -> Type.List(substituteTypes assigns t)\r\n  | Type.Object(o) ->\r\n      let members = substituteMembers assigns o.Members\r\n      let bound = o.Typeargs |> List.choose (function Type.Parameter n -> Some n | _ -> None)\r\n      let assigns, _ = avoidCapture bound assigns\r\n      { Typeargs = List.map (substituteTypes assigns) o.Typeargs\r\n        Members = members } |> Type.Object\r\n  | Type.Delayed(g, f) -> \r\n      let f = \r\n        { new Future<Type> with \r\n            member x.Then(g) =             \r\n              f.Then(fun t -> g (substituteTypes assigns t)) }\r\n      Type.Delayed(g, f)\r\n\r\nlet rec applyTypes assigns t = \r\n  match t with \r\n  | Type.Delayed(g, f) ->\r\n      let f = \r\n        { new Future<Type> with \r\n            member x.Then(g) =             \r\n              f.Then(fun t -> g (applyTypes assigns t)) }\r\n      Type.Delayed(g, f)\r\n  | Type.Object(o) ->\r\n      { Typeargs = List.map (substituteTypes assigns) o.Typeargs\r\n        Members = substituteMembers assigns o.Members } |> Type.Object      \r\n  | t when List.isEmpty (Map.toList assigns) -> t\r\n  | Type.Any -> Type.Any\r\n  | _ -> \r\n      Log.error(\"typechecker\", \"Invalid type application %O with %O\", t, Map.toArray assigns)\r\n      failwith \"Invalid type application\"\r\n\r\nlet rec typeCheckExpr ctx ctxTyp res (expr:Expr<unit>) = async {\r\n  match expr.Expr with\r\n  | ExprKind.Null ->\r\n      return failwith \"Unexpected null in source code.\"\r\n  | ExprKind.Unit ->\r\n      return { Expr = ExprKind.Unit; Type = Type.Unit; Range = expr.Range }, res\r\n  | ExprKind.Empty ->\r\n      return { Expr = ExprKind.Empty; Type = Type.Any; Range = expr.Range }, res\r\n  | ExprKind.Variable(v) when ctx.Variables.ContainsKey v.Name ->  \r\n      return { Expr = ExprKind.Variable v; Type = ctx.Variables.[v.Name]; Range = expr.Range }, res\r\n  | ExprKind.Variable(v) ->\r\n      return \r\n        { Expr = ExprKind.Variable v; Type = Type.Any; Range = expr.Range }, \r\n        res |> addError (Errors.TypeChecker.variableNotInScope expr.Range v.Name)\r\n  | ExprKind.Number n -> \r\n      return { Expr = ExprKind.Number n; Type = Type.Primitive \"num\"; Range = expr.Range }, res\r\n  | ExprKind.String s -> \r\n      return { Expr = ExprKind.String s; Type = Type.Primitive \"string\"; Range = expr.Range }, res\r\n  | ExprKind.Boolean b -> \r\n      return { Expr = ExprKind.Boolean b; Type = Type.Primitive \"bool\"; Range = expr.Range }, res\r\n\r\n  | ExprKind.Function(n, e) ->\r\n      let varTy = ctxTyp |> Option.bind (function\r\n        | Type.Function([ty], _) -> Some ty | _ -> None)\r\n      let varTy = defaultArg varTy Type.Any\r\n      Log.trace(\"typechecker\", \"function: '%s -> ...' in context: %O\", n.Name, varTy)\r\n      let! e, res = typeCheckExpr (addVariable n.Name varTy ctx) None res e\r\n      return { Expr = ExprKind.Function(n, e); Type = Type.Function([varTy], e.Type); Range = expr.Range }, res\r\n\r\n  | ExprKind.List(els) ->\r\n      let! res, els =  els |> Async.foldMap (typeCheckExpr ctx None) res\r\n      let mutable tys = []\r\n      for el in els do\r\n        let known = tys |> List.exists (typesEqual el.Type)\r\n        if not known then tys <- el.Type::tys\r\n      let ty, res =\r\n        match tys with\r\n        | [] -> Type.Any, res // TODO: Something clever\r\n        | [ty] -> ty, res\r\n        | ty::_ -> Type.Any, res \r\n            // TODO: Ideally we would avoid explicit boxing\r\n            // |> addError (Errors.TypeChecker.mismatchingListTypes expr.Range)\r\n      return { Expr = ExprKind.List els; Type = Type.List(ty); Range = expr.Range }, res\r\n\r\n  | ExprKind.Property(e, name) ->\r\n      Log.trace(\"typechecker\", \"checking access %s\", name.Name)\r\n      let! typed, res = typeCheckExpr ctx None res e\r\n      let! members = getObjectMembers typed.Type \r\n      Log.trace(\"typechecker\", \"checked access %s\", name.Name)\r\n      let resTyp, res = \r\n        match members with\r\n        | ObjectMembers.Members members ->\r\n            match members |> Seq.tryPick (function Member.Property(name=n; typ=r) when n = name.Name -> Some r | _ -> None) with\r\n            | Some resTyp -> resTyp, res\r\n            | _ -> Type.Any, res |> addError (Errors.TypeChecker.propertyMissing name.Range name.Name members)\r\n        | ObjectMembers.SilentError -> Type.Any, res\r\n        | ObjectMembers.NotAnObject -> Type.Any, res |> addError (Errors.TypeChecker.notAnObject e.Range typed.Type)\r\n      return { Expr = ExprKind.Property(typed, name); Type = resTyp; Range = expr.Range }, res\r\n\r\n  | ExprKind.Call(e, name, args) ->\r\n      let! typed, res = typeCheckExpr ctx None res e\r\n      let! members = getObjectMembers typed.Type \r\n\r\n      let positionBased, nameBased, res = \r\n        let pb = args |> List.takeWhile (fun arg -> arg.Name.IsNone) \r\n        let nb = args |> List.skipWhile (fun arg -> arg.Name.IsNone)\r\n        pb |> List.map (fun arg -> arg.Value) |> Array.ofList,\r\n        nb |> List.choose (fun arg -> arg.Name |> Option.map (fun n -> n.Name, arg.Value)) |> Map.ofList,\r\n        match nb |> List.tryFind (fun arg -> arg.Name.IsNone) with\r\n        | Some arg -> res |> addError (Errors.TypeChecker.nameBasedParamMustBeLast arg.Value.Range)\r\n        | _ -> res\r\n                \r\n      let noRange = { Start = 0; End = 0 }\r\n      let checkArguments pars = \r\n        pars |> List.mapi (fun i p -> i, p) |> Async.foldMap (fun res (index, (name, optional, typ)) -> async {\r\n          let arg = \r\n            if index < positionBased.Length then Some(positionBased.[index]) \r\n            else Map.tryFind name nameBased \r\n          match arg with\r\n          | Some arg -> \r\n              let! t, res = typeCheckExpr ctx (Some typ) res arg\r\n              return { Name = Some { Name = name; Range = arg.Range }; Value = t }, res  // Here we are returning wrong range \r\n          | None when optional ->\r\n              let v = { Expr = ExprKind.Null; Range = noRange; Type = typ }\r\n              return { Name = Some { Name = name; Range = noRange }; Value = v }, res // dtto\r\n          | _ ->\r\n              let v = { Expr = ExprKind.Empty; Range = noRange; Type = typ }\r\n              return { Name = Some { Name = name; Range = noRange }; Value = v }, res }) res\r\n        \r\n\r\n        //List.zip args argTys |> Async.foldMap (fun res (arg, argTy) -> async {\r\n          //let! t, res = typeCheckExpr ctx argTy res arg.Value\r\n          //return { Name = arg.Name; Value = t }, res }) res\r\n\r\n      let! resTyp, typedArgs, res = async {\r\n        match members with\r\n        | ObjectMembers.Members members -> \r\n            match members |> Seq.tryPick (function Member.Method(name=n; typars=tp; arguments=args; typ=r) when n = name.Name -> Some(tp, r, args) | _ -> None) with\r\n            | Some(tp, resTyp, pars) -> \r\n                // TODO: check arguments\r\n                let! res, typedArgs = checkArguments pars\r\n                let typedArgs = \r\n                  List.zip pars typedArgs |> List.map (fun ((n, _, _), ta) ->\r\n                     { ta with Name = Some { Name = n; Range = ta.Value.Range }})\r\n\r\n                let parTys = pars |> List.map (fun (_, _, t) -> t)\r\n                let argTys = typedArgs |> List.map (fun a -> a.Value.Type)\r\n                Log.trace(\"typechecker\", \"unifying %s: pars: %O, args: %O\", name.Name, Array.ofList parTys, Array.ofList argTys)\r\n                let! unifyFunc = unifyTypes [] parTys argTys \r\n                let assigns, res = unifyFunc res name.Range\r\n\r\n                Log.trace(\"typechecker\", \"call %s: tyargs: %s, assigns: %O\", name.Name, String.concat \",\" tp, Array.ofList assigns)\r\n                let resTyp = applyTypes (Map.ofList assigns) resTyp\r\n                Log.trace(\"typechecker\", \"call %s: result type: %O\", name.Name, resTyp)\r\n                return resTyp, typedArgs, res \r\n            | _ -> \r\n                //let! res, _ = checkArguments None\r\n                let res = res |> addError (Errors.TypeChecker.methodMissing name.Range name.Name members)\r\n                return Type.Any, [], res\r\n        | ObjectMembers.SilentError -> \r\n            //let! res, typedArgs = checkArguments None\r\n            return Type.Any, [], res\r\n        | ObjectMembers.NotAnObject -> \r\n            //let! res, typedArgs = checkArguments None\r\n            return Type.Any, [], res |> addError (Errors.TypeChecker.notAnObject e.Range typed.Type) }\r\n\r\n      return { Expr = ExprKind.Call(typed, name, typedArgs); Type = resTyp; Range = expr.Range }, res }\r\n\r\nlet rec typeCheckCmd ctx res cmds = async {\r\n  match cmds with\r\n  | ({ Command = CommandKind.Let(name, expr) } as cmd)::cmds ->\r\n      let! typed, res = typeCheckExpr ctx None res expr\r\n      let! cmds, res = typeCheckCmd (addVariable name.Name typed.Type ctx) res cmds\r\n      return { Command = CommandKind.Let(name, typed); Range = cmd.Range}::cmds, res\r\n  | ({ Command = CommandKind.Expr(expr) } as cmd)::cmds ->      \r\n      let! typed, res = typeCheckExpr ctx None res expr\r\n      let! cmds, res = typeCheckCmd ctx res cmds\r\n      return { Command = CommandKind.Expr(typed); Range = cmd.Range}::cmds, res\r\n  | [] -> \r\n      return [], res }\r\n\r\nlet typeCheckProgram ctx res prog = async {\r\n  let! cmds, res = typeCheckCmd ctx res prog.Body\r\n  return { Body = cmds; Range = prog.Range }, res }\r\n\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// User friendly entry point\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nopen TheGamma.AstOperations\r\n\r\nlet needsEscaping (s:string) = \r\n  (s.[0] >= '0' && s.[0] <= '9') ||\r\n  (s.ToCharArray() |> Array.exists (fun c -> not ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) ))\r\n\r\nlet escapeIdent s = \r\n  if needsEscaping s then \"'\" + s + \"'\" else s\r\n\r\nlet mapNameRanges f (n:Name) = \r\n  { n  with Range = f n.Range }\r\n\r\nlet rec mapExprRanges f expr = \r\n  match expr.Expr with  \r\n  | ExprLeaf -> { expr with Range = f expr.Range }\r\n  | ExprNode(es, ns) -> \r\n      { Expr = rebuildExprNode expr.Expr (List.map (mapExprRanges f) es) (List.map (mapNameRanges f) ns)\r\n        Range = f expr.Range; Type = expr.Type }\r\n\r\nlet rec mapCmdRanges f cmd = \r\n  match cmd.Command with\r\n  | CommandKind.Expr e -> { Command = CommandKind.Expr (mapExprRanges f e); Range = cmd.Range }\r\n  | CommandKind.Let(n, e) -> { Command = CommandKind.Let(mapNameRanges f n, mapExprRanges f e); Range = cmd.Range }\r\n\r\nlet tokenize (input:string) = \r\n  let input = input.Replace(\"\\r\\n\", \"\\n\")\r\n  let tokens, errors = Tokenizer.tokenize input\r\n  List.ofArray errors, tokens\r\n\r\nlet parse (input:string) = \r\n  let errs1, tokens = tokenize input\r\n  let (Parsec.Parser p) = Parser.program\r\n\r\n  let rangeLookup = tokens |> List.map (fun tok -> tok.Range) |> Array.ofSeq\r\n\r\n  let tokToChar rng =\r\n    let safe start n = \r\n      if n >= rangeLookup.Length then rangeLookup.[rangeLookup.Length-1].End\r\n      elif n < 0 then 0\r\n      elif start then rangeLookup.[n].Start\r\n      else rangeLookup.[n].End\r\n    let rng = \r\n      { Start = safe true rng.Start\r\n        End = safe false (rng.End-1) }\r\n    if rng.End < rng.Start then { rng with End = rng.Start }\r\n    else rng\r\n\r\n  match p (0, tokens) with\r\n  | Some((offs, rest), errs2, prog) ->\r\n      let errs2 = errs2 |> List.map (fun e -> { e with Range = tokToChar e.Range })\r\n      let errors = \r\n        if List.isEmpty rest then errs1 @ errs2\r\n        else\r\n          { Number = 21; Range = tokToChar { Start = offs; End = offs + List.length rest }\r\n            Message = sprintf \"Parser stopped: %A\" rest } :: errs1 @ errs2\r\n      errors, { Range = prog.Range; Body = prog.Body |> List.map (mapCmdRanges tokToChar) }\r\n  | _ ->\r\n    { Number = 21; Range = tokToChar { Start = 0; End = List.length tokens }\r\n      Message = sprintf \"Parser stopped: %A\" tokens } :: errs1,\r\n    { Range = tokToChar { Start = 0; End = List.length tokens }\r\n      Body = [] }\r\n          \r\nlet typeCheck globals input = async {\r\n  let errs1, untyped = parse input\r\n  let! checkd, ctx = typeCheckProgram { Variables = globals } { Errors = [] } untyped\r\n  return errs1 @ ctx.Errors, checkd }\r\n\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Collecting editors\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype EditorInfo = \r\n  { Source : string\r\n    Completions : list<Range * Range * Member[]> }\r\n\r\nlet extendUntilDot (text:string) (rng:Range) = \r\n  let mutable start = rng.Start\r\n  while start > 0 && text.[start] <> '.'  do start <- start - 1\r\n  { rng with Start = start + 1 }\r\n\r\nlet withCompletion r t ctx = async {\r\n  let! members = getObjectMembers t\r\n  match members with\r\n  | Members members -> return { ctx with Completions = (extendUntilDot ctx.Source r, r, members)::ctx.Completions }\r\n  | _ -> return ctx }\r\n\r\nlet rec collectExprInfo ctx expr = async {\r\n  match expr.Expr with\r\n  | ExprKind.Property(inst, n) -> \r\n      let! ctx = collectExprInfo ctx inst\r\n      return! withCompletion n.Range inst.Type ctx\r\n  | ExprKind.Call(inst, n, args) ->\r\n      let! ctx = collectExprInfo ctx inst\r\n      let! ctx = args |> Async.fold (fun ctx arg -> collectExprInfo ctx arg.Value) ctx\r\n      return! withCompletion n.Range inst.Type ctx \r\n  | ExprKind.List(els) ->\r\n      return! Async.fold collectExprInfo ctx els\r\n  | ExprKind.Function(_, e) ->\r\n      return! collectExprInfo ctx e\r\n  | ExprKind.Empty\r\n  | ExprKind.Unit\r\n  | ExprKind.Null\r\n  | ExprKind.Number _\r\n  | ExprKind.String _\r\n  | ExprKind.Boolean _\r\n  | ExprKind.Variable _ -> return ctx }\r\n\r\nlet rec collectCmdInfo ctx cmds = async {\r\n  match cmds with\r\n  | [] -> return ctx\r\n  | { Command = CommandKind.Let(_, expr) }::cmds \r\n  | { Command = CommandKind.Expr(expr) }::cmds ->\r\n      let! ctx = collectExprInfo ctx expr\r\n      return! collectCmdInfo ctx cmds }\r\n\r\nlet collectProgramInfo ctx prog = \r\n  collectCmdInfo ctx prog.Body"]}