{"version":3,"sources":["../../../../src/thegamma/ast/ast.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;kCAAA;AAAA;;AAAA;AAAA,G;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;0BAyFU;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAC,SAAD;AAAA;AAAC;AAAA;;;;;;;;wCAzFX;AAAA;;AAAA;AAAA,G;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;4BAAA;AAAA;;AAAA;AAAA;AAAA,G;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;wCAAA;AAAA;;AAAA;AAAA;AAAA,G;;;;gCAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;cAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;;;oCAAA;AAAA;;AAAA;AAAA;AAAA,G;;;;kCAAA;AAAA;;AAAA;AAAA,G;;;;kCAAA;AAAA;;AAAA;AAAA;AAAA,G;;;;4BAAA;AAAA;;AAAA;AAAA;AAAA,G","file":"ast.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿namespace TheGamma\r\nopen TheGamma.Common\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Tokens and common \r\n// ------------------------------------------------------------------------------------------------\r\n\r\n/// Represents a range as character offset in a file. 0-indexed, the End position is the position\r\n/// of the last character of the thing in the range. Consider range of \"42\" in \"1 + 42 + 2\".\r\n/// The range of the token 42 here would be { Start = 4; End = 5 }:\r\n///\r\n///     1   +   4 2   +   2 \r\n///     0 1 2 3 4 5 6 7 8 9\r\n///\r\ntype Range = \r\n  { Start : int\r\n    End : int }\r\n\r\n/// Error with a range. Message can be Markdown, Range is generic so that we can reuse \r\n/// the data structure with both `Range` and line-based range when reporting errors.\r\ntype Error<'Range> =\r\n  { Number : int\r\n    Message : string\r\n    Range : 'Range }\r\n\r\n/// Binary operators (Equals is tokenized as separate token, but after parsing it can be operator)\r\ntype [<RequireQualifiedAccess>] Operator = \r\n  | Equals\r\n  | Plus\r\n  | Minus\r\n  | Multiply\r\n  | Divide\r\n  | Power\r\n  | GreaterThan\r\n  | LessThan\r\n  | GreaterThanOrEqual\r\n  | LessThanOrEqual\r\n\r\n/// Tokens produced by tokenizer\r\ntype [<RequireQualifiedAccess>] TokenKind = \r\n  | LParen\r\n  | RParen\r\n  | Equals\r\n  | Dot\r\n  | Comma\r\n  | Let\r\n  | LSquare\r\n  | RSquare\r\n  | Fun\r\n  | Arrow\r\n  | To\r\n  | By\r\n  | Operator of Operator\r\n  | Boolean of bool\r\n  | Number of string * float\r\n  | String of string\r\n  | Ident of string\r\n  | QIdent of string\r\n  | White of string\r\n  | Newline\r\n  | Error of char\r\n  | EndOfFile\r\n\r\n/// Token with a range\r\ntype Token = \r\n  { Token : TokenKind \r\n    Range : Range }\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Types and code generation\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype Emitter = \r\n  { Emit : Babel.Expression * Babel.Expression list -> Babel.Expression }\r\n\r\ntype Metadata = \r\n  { Context : string\r\n    Type : string\r\n    Data : obj }\r\n\r\ntype [<RequireQualifiedAccess>] Documentation = \r\n  | Text of string\r\n  | Details of string * string\r\n  | None \r\n\r\ntype [<RequireQualifiedAccess>] Member = \r\n  | Property of name:string * typ:Type * meta:Metadata list * emitter:Emitter\r\n  | Method of name:string * arguments:(string * bool * Type) list * typ:Type * meta:Metadata list * emitter:Emitter\r\n  member x.Name = \r\n    match x with Property(name=s) | Method(name=s) -> s\r\n\r\nand ObjectType = \r\n  { Members : Member[] }\r\n\r\nand [<RequireQualifiedAccess>] PrimitiveType = \r\n  | Number\r\n  | String\r\n  | Bool\r\n  | Unit\r\n\r\nand TypeVar = string\r\n\r\nand [<RequireQualifiedAccess>] Type =\r\n  | Forall of TypeVar list * Type\r\n  | Parameter of TypeVar \r\n  | App of Type * Type list\r\n\r\n  | Delayed of guid:string * Future<Type>\r\n  | Primitive of PrimitiveType\r\n  | Object of ObjectType\r\n  | Function of arguments:Type list * returns:Type\r\n  | List of elementType:Type\r\n  | Any\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Entities - binder attaches those to individual constructs in the parsed AST\r\n// ------------------------------------------------------------------------------------------------\r\n\r\n/// Name. In expressions, it usually appears as Node<Name> \r\ntype Name = \r\n  { Name : string }\r\n\r\n/// Represents constants that can appear in the code\r\n/// (We create separate entity for each, so that we can calculate\r\n/// values of entities and not just types)\r\ntype [<RequireQualifiedAccess>] Constant = \r\n  | Number of float\r\n  | String of string\r\n  | Boolean of bool\r\n  | Empty\r\n\r\n/// Represents different kinds of entities that we create. Roughhly\r\n/// corresponds to all places in code where something has a name.\r\ntype [<RequireQualifiedAccess>] EntityKind = \r\n\r\n  // Entities that represent root node, program and commands\r\n  | Root\r\n  | Program of commands:Entity list\r\n  | RunCommand of body:Entity\r\n  | LetCommand of variable:Entity * assignment:Entity\r\n\r\n  // Standard constructs of the language\r\n  | Operator of left:Entity * operator:Operator * right:Entity\r\n  | List of elements:Entity list\r\n  | Constant of Constant\r\n  | Function of variable:Entity * body:Entity\r\n\r\n  /// Reference to a global symbol\r\n  | GlobalValue of name:Name * Babel.Expression option \r\n  /// Reference to a local variable\r\n  | Variable of name:Name * value:Entity\r\n  /// Variable binding in lambda abstraction\r\n  | Binding of name:Name * callSite:Entity\r\n\r\n  /// Represents all arguments passed to method; Antecedants are individual arguments\r\n  /// (a mix of named parameter & ordinary expression entities)\r\n  | ArgumentList of arguments:Entity list\r\n  /// Call site in which a lambda function appears. Marks instance, method name & argument\r\n  /// (the argument is the name or the index of the parameter in the list)\r\n  | CallSite of instance:Entity * name:Name * parameter:Choice<string, int>\r\n  /// Named param in a call site with an expression assigned to it\r\n  | NamedParam of name:Name * assignment:Entity\r\n  /// Named member (property or call) with reference to the instance (or Root if no instance)\r\n  | NamedMember of name:Name * instance:Entity\r\n  /// Call or property access; `named` is `NamedMember` and `arguments` is `ArgumentList`\r\n  | ChainElement of isProperty:bool * name:Name * named:Entity * instance:Entity option * arguments:Entity option\r\n\r\n  \r\n/// An entity represents a thing in the source code to which we attach additional info.\r\n/// It is uniquely identified by its `Symbol` (which is also used for lookups)\r\nand Entity = \r\n  { Kind : EntityKind\r\n    Symbol : Symbol \r\n    mutable Value : EntityValue option\r\n    mutable Meta : Metadata list\r\n    mutable Type : Type option \r\n    mutable Errors : Error<Range> list }\r\n\r\nand RuntimeValue = interface end\r\n\r\nand EntityValue =\r\n  { Value : RuntimeValue\r\n    Preview : RuntimeValue option }\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Parsed AST \r\n// ------------------------------------------------------------------------------------------------\r\n\r\n/// Node wraps syntax element with other information. Whitespce before/after are tokens \r\n/// around it that the parser skipped (they may be whitespace, but also skipped error tokens).\r\n/// Entity is assigned to the expression later by a binder.\r\ntype Node<'T> = \r\n  { WhiteBefore : Token list\r\n    WhiteAfter : Token list\r\n    Range : Range \r\n    Node : 'T\r\n    mutable Entity : Entity option }\r\n\r\n/// Method call argument, optionally with a named\r\ntype Argument =\r\n  { Name : Node<Name> option\r\n    Value : Node<Expr> }\r\n\r\n/// A program is a list of commands (with range info)\r\nand Program = \r\n  { Body : Node<Node<Command> list> }\r\n\r\n/// Variable binding or an expression\r\nand Command = \r\n  | Let of Node<Name> * Node<Expr>\r\n  | Expr of Node<Expr>\r\n\r\n/// An expression (does not include let binding, which is a command)\r\nand [<RequireQualifiedAccess>] Expr = \r\n  | Variable of Node<Name>\r\n  | Property of Node<Expr> * Node<Name>\r\n  | Call of Node<Expr> option * Node<Name> * Node<Argument list>\r\n  | Function of Node<Name> * Node<Expr>\r\n  | String of string\r\n  | Number of float\r\n  | Boolean of bool\r\n  | Binary of Node<Expr> * Node<Operator> * Node<Expr>\r\n  | List of Node<Expr> list\r\n  | Empty\r\n\r\n"]}