{"version":3,"sources":["../../../../src/thegamma/ast/astops.fs"],"names":[],"mappings":"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","file":"astops.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Ast\r\n\r\n/// Create a node with given range and value\r\nlet node rng node =\r\n  { Entity = None\r\n    WhiteBefore = []\r\n    WhiteAfter = [] \r\n    Node = node\r\n    Range = rng }\r\n\r\n/// Does an identifier need escaping?\r\nlet needsEscaping (s:string) = \r\n  (s.[0] >= '0' && s.[0] <= '9') ||\r\n  (s.ToCharArray() |> Array.exists (fun c -> not ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) ))\r\n\r\n/// Escape identifier if it needs escaping\r\nlet escapeIdent s = \r\n  if needsEscaping s then \"'\" + s + \"'\" else s\r\n\r\n/// Union ranges, assuming Start <= End for each of them\r\nlet unionRanges r1 r2 =\r\n  { Start = min r1.Start r2.Start; End = max r1.End r2.End }\r\n\r\n/// Is the first range a strict sub-range of the second range\r\nlet strictSubRange first second = \r\n  (first.Start > second.Start && first.End <= second.End) ||\r\n  (first.Start >= second.Start && first.End < second.End)\r\n\r\n/// Format a single token (as it looks in the soruce code)\r\nlet formatToken = function\r\n  | TokenKind.LParen -> \"(\"\r\n  | TokenKind.RParen -> \")\"\r\n  | TokenKind.Equals -> \"=\"\r\n  | TokenKind.Dot -> \".\"\r\n  | TokenKind.Comma -> \",\"\r\n  | TokenKind.Let -> \"let\"\r\n  | TokenKind.LSquare -> \"[\"\r\n  | TokenKind.RSquare -> \"]\"\r\n  | TokenKind.Fun -> \"fun\"\r\n  | TokenKind.Arrow -> \"->\"\r\n  | TokenKind.Operator Operator.Divide -> \"/\"\r\n  | TokenKind.Operator Operator.GreaterThan -> \">\"\r\n  | TokenKind.Operator Operator.GreaterThanOrEqual -> \">=\"\r\n  | TokenKind.Operator Operator.LessThan -> \"<\"\r\n  | TokenKind.Operator Operator.LessThanOrEqual -> \"<=\"\r\n  | TokenKind.Operator Operator.Minus -> \"-\"\r\n  | TokenKind.Operator Operator.Multiply -> \"*\"\r\n  | TokenKind.Operator Operator.Plus -> \"+\"\r\n  | TokenKind.Operator Operator.Power -> \"^\"\r\n  | TokenKind.Operator Operator.Equals -> \"=\"\r\n  | TokenKind.Boolean true -> \"true\"\r\n  | TokenKind.Boolean false -> \"false\"\r\n  | TokenKind.Number(s, _) -> s\r\n  | TokenKind.String(s) -> \"\\\"\" + s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"\\n\", \"\\\\n\").Replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\"\r\n  | TokenKind.Ident(i) -> i\r\n  | TokenKind.QIdent(q) -> \"'\" + q + \"'\"\r\n  | TokenKind.White(w) -> w\r\n  | TokenKind.Newline -> \"\\n\"\r\n  | TokenKind.Error(c) -> string c\r\n  | TokenKind.EndOfFile -> \"\"\r\n  | TokenKind.By | TokenKind.To -> failwith \"Unsupported token\"\r\n\r\n/// Return human readable description of a token\r\nlet formatTokenInfo = function\r\n  | TokenKind.LParen -> \"left parenthesis `(`\"\r\n  | TokenKind.RParen -> \"right parenthesis `)`\"\r\n  | TokenKind.Equals -> \"equals sign `=`\"\r\n  | TokenKind.Dot -> \"dot character `.`\"\r\n  | TokenKind.Comma -> \"comma character `,`\"\r\n  | TokenKind.Let -> \"`let` keyword\"\r\n  | TokenKind.LSquare -> \"left square bracket `[`\"\r\n  | TokenKind.RSquare -> \"right square bracket `]`\"\r\n  | TokenKind.Fun -> \"`fun` keyword\"\r\n  | TokenKind.Arrow -> \"arrow sign `->`\"\r\n  | TokenKind.Operator Operator.Equals -> \"equals operator `=`\"\r\n  | TokenKind.Operator Operator.Divide -> \"division sign `/`\"\r\n  | TokenKind.Operator Operator.GreaterThan -> \"greater than sign `>`\"\r\n  | TokenKind.Operator Operator.GreaterThanOrEqual -> \"greater than or equals sign `>=`\"\r\n  | TokenKind.Operator Operator.LessThan -> \"less than sign `<`\"\r\n  | TokenKind.Operator Operator.LessThanOrEqual -> \"less than or equals sign `<=`\"\r\n  | TokenKind.Operator Operator.Minus -> \"minus sign `-`\"\r\n  | TokenKind.Operator Operator.Multiply -> \"multiplication sign `*`\"\r\n  | TokenKind.Operator Operator.Plus -> \"plus sign `+`\"\r\n  | TokenKind.Operator Operator.Power -> \"exponentiation sign `^`\"\r\n  | TokenKind.Boolean true -> \"logical `true` value\"\r\n  | TokenKind.Boolean false -> \"logical `false` value\"\r\n  | TokenKind.Number(s, _) -> sprintf \"numerical value `%s`\" s\r\n  | TokenKind.String(s) -> sprintf \"string value `%s`\" (s.Replace(\"`\", \"'\"))\r\n  | TokenKind.Ident(i) -> sprintf \"identifer `%s`\" i\r\n  | TokenKind.QIdent(q) -> sprintf \"quoted identifer `'%s'`\" q\r\n  | TokenKind.White(w) -> \"whitespace\"\r\n  | TokenKind.Newline -> \"end of line\"\r\n  | TokenKind.Error('`') -> \"back-tick character\"\r\n  | TokenKind.Error(c) -> sprintf \"other character `%s`\" (string c)\r\n  | TokenKind.EndOfFile -> \"end of file\"\r\n  | TokenKind.By | TokenKind.To -> failwith \"Unsupported token\"\r\n\r\n/// Turns series of tokens into string, using their Token value\r\nlet formatTokens (tokens:seq<Token>) = \r\n  tokens |> Seq.map (fun t -> formatToken t.Token) |> String.concat \"\"\r\n\n/// When formatting expression, we append strings and then join them (should be fast in JS)\ntype FormattingContext = \n  { Strings : ResizeArray<string> }\n  member x.Add(tok) = x.Strings.Add(formatToken tok)\n\nlet formatNode (ctx:FormattingContext) f node =\n  for t in node.WhiteBefore do ctx.Add(t.Token)\n  f ctx node.Node\n  for t in node.WhiteAfter do ctx.Add(t.Token)\n  \nlet formatName (ctx:FormattingContext) (name:Name) = \n  if name.Name = \"\" then ()\n  elif needsEscaping name.Name then ctx.Add(TokenKind.QIdent name.Name)\n  else ctx.Add(TokenKind.Ident name.Name)\n\nlet rec formatArgument (ctx:FormattingContext) (arg:Argument) =\n  match arg.Name with \r\n  | Some name -> \r\n      formatNode ctx formatName name\r\n      ctx.Add(TokenKind.Equals)\r\n  | _ -> ()\r\n  formatNode ctx formatExpression arg.Value\r\n\n/// Format a single parsed expression, preserving the parsed whitespace\r\nand formatExpression (ctx:FormattingContext) expr = \n  match expr with\n  | Expr.Variable(n) -> \r\n      formatNode ctx formatName n\r\n  | Expr.Property(inst, n) -> \r\n      formatNode ctx formatExpression inst\r\n      ctx.Add(TokenKind.Dot)\r\n      formatNode ctx formatName n\r\n  | Expr.Call(inst, n, args) ->\r\n      match inst with Some inst -> formatNode ctx formatExpression inst | _ -> ()\r\n      ctx.Add(TokenKind.Dot)\r\n      formatNode ctx formatName n\r\n      ctx.Add(TokenKind.LParen)\r\n      args |> formatNode ctx (fun ctx args -> \r\n        args |> List.iteri (fun i arg ->\r\n          if i <> 0 then ctx.Add(TokenKind.Comma)\r\n          formatArgument ctx arg ) )\r\n      ctx.Add(TokenKind.RParen)\r\n  | Expr.String s -> ctx.Add(TokenKind.String s)\r\n  | Expr.Number n -> ctx.Add(TokenKind.Number(string n, n))\r\n  | Expr.Boolean b -> ctx.Add(TokenKind.Boolean b)\r\n  | Expr.Binary(l, op, r) ->\r\n      formatNode ctx formatExpression l\r\n      op |> formatNode ctx (fun ctx op -> ctx.Add(TokenKind.Operator op))\r\n      formatNode ctx formatExpression r  \r\n  | Expr.Function(n, e) ->\r\n      ctx.Add(TokenKind.Fun)\r\n      formatNode ctx formatName n\r\n      ctx.Add(TokenKind.Arrow)\r\n      formatNode ctx formatExpression e\r\n  | Expr.List els ->\r\n      ctx.Add(TokenKind.LSquare)\r\n      for e in els do formatNode ctx formatExpression e\r\n      ctx.Add(TokenKind.RSquare)\r\n  | Expr.Empty -> ()\r\n\r\n/// Format a single parsed command, preserving the parsed whitespace\r\nlet formatCommand (ctx:FormattingContext) cmd = \r\n  match cmd with\r\n  | Command.Expr e -> \r\n      formatNode ctx formatExpression e\r\n  | Command.Let(n, e) -> \r\n      ctx.Add(TokenKind.Let)\r\n      formatNode ctx formatName n\r\n      ctx.Add(TokenKind.Equals)\r\n      formatNode ctx formatExpression e\r\n\r\n/// Format single parsed expression, preserving the parsed whitespace\r\nlet formatSingleExpression expr = \n  let ctx = { Strings = ResizeArray<_>() }\r\n  formatNode ctx formatExpression expr\r\n  System.String.Concat(ctx.Strings)\r\n\r\n/// Format parsed program, preserving the parsed whitespace\r\nlet formatProgram (prog:Program) = \r\n  let ctx = { Strings = ResizeArray<_>() }\r\n  prog.Body |> formatNode ctx (fun ctx cmds ->\r\n    for cmd in cmds do formatNode ctx (formatCommand) cmd)\r\n  System.String.Concat(ctx.Strings)\r\n\r\n/// Format all white space after the given expression\r\nlet formatWhiteAfterExpr nd = \r\n  let wa = \r\n    match nd.Node with \r\n    | Expr.Variable(n)\r\n    | Expr.Property(_, n) -> n.WhiteAfter @ nd.WhiteAfter \r\n    | _ -> nd.WhiteAfter\r\n  String.concat \"\" [ for t in wa -> formatToken t.Token ]\r\n\r\n/// Format entity kind into something readable\r\nlet formatEntityKind = function\r\n  | EntityKind.GlobalValue _ -> \"global value\"\r\n  | EntityKind.Variable _ -> \"variable\"\r\n  | EntityKind.Binding _ -> \"binding\"\r\n  | EntityKind.Operator(_, op, _) -> (formatToken (TokenKind.Operator op)) + \" operator\"\r\n  | EntityKind.List _ -> \"list\"\r\n  | EntityKind.Constant(Constant.Empty) -> \"empty value\"\r\n  | EntityKind.Constant(Constant.Number n) -> sprintf \"number `%f`\" n \r\n  | EntityKind.Constant(Constant.String n) -> sprintf \"string `%s`\" n \r\n  | EntityKind.Constant(Constant.Boolean true) -> \"`true` value\" \r\n  | EntityKind.Constant(Constant.Boolean false) -> \"`false` value\" \r\n  | EntityKind.Function _ -> \"function\"\r\n  | EntityKind.LetCommand _ -> \"let command\"\r\n  | EntityKind.RunCommand _ -> \"run command\"\r\n  | EntityKind.Program _ -> \"program\"\r\n  | EntityKind.Root _ -> \"root\"\r\n  | EntityKind.CallSite _ -> \"call site\"\r\n  | EntityKind.NamedParam _ -> \"named param\"\r\n  | EntityKind.ChainElement _ -> \"chain element\"\r\n  | EntityKind.ArgumentList _ -> \"argument list\"\r\n  | EntityKind.NamedMember _ -> \"property or method\"\r\n\r\n/// Used for entities with no name\r\nlet anonymous = \"\"\r\n\r\n/// Return entity name (or anonymous) and all its antecedants\r\nlet entityCodeNameAndAntecedents = function\r\n  | EntityKind.Root -> 0, [], anonymous\r\n  | EntityKind.Program(ans) -> 1, ans, anonymous\r\n  | EntityKind.RunCommand(an) -> 2, [an], anonymous\r\n  | EntityKind.LetCommand(an1, an2) -> 3, [an1; an2], anonymous\r\n  | EntityKind.Operator(an1, op, an2) -> 4, [an1; an2], (formatToken (TokenKind.Operator op))\r\n  | EntityKind.List(ans) -> 5, ans, anonymous\r\n  | EntityKind.Constant(Constant.String s) -> 6, [], s\r\n  | EntityKind.Constant(Constant.Number n) -> 7, [], (string n)\r\n  | EntityKind.Constant(Constant.Boolean b) -> 8, [], (string b)\r\n  | EntityKind.Constant(Constant.Empty) -> 9, [], anonymous\r\n  | EntityKind.Function(an1, an2) -> 10, [an1; an2], anonymous\r\n  | EntityKind.GlobalValue(n, _) -> 11, [], n.Name\r\n  | EntityKind.Variable(n, an) -> 12, [an], n.Name\r\n  | EntityKind.Binding(n, an) -> 13, [an], n.Name\r\n  | EntityKind.ArgumentList(ans) -> 14, ans, anonymous\r\n  | EntityKind.CallSite(an1, n, Choice1Of2 s) -> 15, [an1], (n.Name + \".\" + s)\r\n  | EntityKind.CallSite(an1, n, Choice2Of2 m) -> 16, [an1], (n.Name + \".\" + string m)\r\n  | EntityKind.NamedParam(n, an) -> 17, [an], n.Name\r\n  | EntityKind.NamedMember(n, an) -> 18, [an], n.Name\r\n  | EntityKind.ChainElement(b, n, an1, an2, an3) -> 19, List.choose id [Some an1; an2; an3], (n.Name + \".\" + string b)\r\n\r\n// Provide easy access to entity's antecedents\r\ntype Entity with\r\n  member x.Antecedents = let _, ans, _ = entityCodeNameAndAntecedents x.Kind in ans\r\n  member x.Name = let _, _, name = entityCodeNameAndAntecedents x.Kind in name\r\n\r\n/// Return full name of the type\r\nlet rec formatType = function\r\n  | Type.App(t, tya) -> formatType t + \"<\" + String.concat \", \" (List.map formatType tya) + \">\"\r\n  | Type.Forall(_, t) -> formatType t\r\n  | Type.Parameter(v) -> v\r\n  | Type.Delayed(g, _) -> \"@\" + g\r\n  | Type.Primitive PrimitiveType.Bool -> \"bool\"\r\n  | Type.Primitive PrimitiveType.Number -> \"number\"\r\n  | Type.Primitive PrimitiveType.String -> \"string\"\r\n  | Type.Primitive PrimitiveType.Unit -> \"unit\"\r\n  | Type.Object { Members = mem } ->  \r\n      let mems = mem |> Seq.truncate 5 |> Seq.map (fun m -> m.Name) |> String.concat \", \"\r\n      \"{ \" + if mem.Length > 5 then mems + \", ...\" else mems + \" }\"\r\n  | Type.Function(tin, tout) -> \"(\" + String.concat \", \" (List.map formatType tin) + \") -> \" + formatType tout\r\n  | Type.List t -> \"list<\" + formatType t + \">\"\r\n  | Type.Any -> \"any\"\r\n\r\n/// Return readable name of the top-level node in the type\r\nlet formatTypeInfo = function\r\n  | Type.Forall _ -> \"generic type\"\r\n  | Type.Parameter _ -> \"unresolved type parameter\"\r\n  | Type.App _ -> \"unresolved type application\"\r\n  | Type.Delayed _ -> \"delayed type\"\r\n  | Type.Primitive PrimitiveType.Bool -> \"boolean\"\r\n  | Type.Primitive PrimitiveType.Number -> \"number\"\r\n  | Type.Primitive PrimitiveType.String -> \"string\"\r\n  | Type.Primitive PrimitiveType.Unit -> \"unit\"\r\n  | Type.Object _ -> \"object type\"\r\n  | Type.Function _ -> \"function type\"\r\n  | Type.List _ -> \"list type\"\r\n  | Type.Any _ -> \"unknown\"\r\n\r\n/// When pattern matching using `ExprNode`, this function lets you rebuild\r\n/// the original node from the original expression, new expressions & names\r\nlet rebuildExprNode e es ns =\r\n  match e, es, ns with\r\n  | Expr.List(_), els, [] -> Expr.List(els)\r\n  | Expr.Function(_), [e], [n] -> Expr.Function(n, e)\r\n  | Expr.Property(_, _), [e], [n] -> Expr.Property(e, n)\r\n  | Expr.Binary(_, op, _), [e1; e2], [] -> Expr.Binary(e1, op, e2)\r\n  | Expr.Call(inst, _, args), e::es, n::ns ->\r\n      let e, es = if inst.IsSome then Some e, es else None, e::es\r\n      let rec rebuildArgs args es ns =\r\n        match args, es, ns with\r\n        | { Argument.Name = None }::args, e::es, ns -> { Value = e; Name = None }::(rebuildArgs args es ns)\r\n        | { Argument.Name = Some _ }::args, e::es, n::ns -> { Value = e; Name = Some n }::(rebuildArgs args es ns)\r\n        | [], [], [] -> []\r\n        | _ -> failwith \"rebuildExprNode: Wrong call length\"\r\n      Expr.Call(e, n, { args with Node = rebuildArgs args.Node es ns })\r\n  | Expr.Variable _, [], [n] -> Expr.Variable(n)\r\n  | Expr.Variable _, _, _ -> failwith \"rebuildExprNode: Wrong variable length\"\r\n  | Expr.Property _, _, _ -> failwith \"rebuildExprNode: Wrong property length\"\r\n  | Expr.Call _, _, _ -> failwith \"rebuildExprNode: Wrong call length\"\r\n  | Expr.List _, _, _ -> failwith \"rebuildExprNode: Wrong list length\"\r\n  | Expr.Function _, _, _ -> failwith \"rebuildExprNode: Wrong function length\"\r\n  | Expr.Binary _, _, _ -> failwith \"rebuildExprNode: Wrong binary operator argument length\"\r\n  | Expr.Number _, _, _\r\n  | Expr.Boolean _, _, _\r\n  | Expr.String _, _, _\r\n  | Expr.Empty, _, _ -> failwith \"rebuildExprNode: Not a node\"\r\n\r\n/// ExprNode matches when an expression contains nested expressions or names,\r\n/// ExprLeaf matches when an expression is a primitive (number, bool, etc..)\r\nlet (|ExprLeaf|ExprNode|) e = \r\n  match e with\r\n  | Expr.Property(e, n) -> ExprNode([e], [n])\r\n  | Expr.Call(Some e, n, args) -> ExprNode(e::[for a in args.Node -> a.Value ], n::(args.Node |> List.choose (fun a -> a.Name)))\r\n  | Expr.Call(None, n, args) -> ExprNode([for a in args.Node -> a.Value ], n::(args.Node |> List.choose (fun a -> a.Name)))\r\n  | Expr.Variable(n) -> ExprNode([], [n])\r\n  | Expr.List(els) -> ExprNode(els, [])\r\n  | Expr.Function(n, b) -> ExprNode([b], [n])\r\n  | Expr.Binary(l, op, r) -> ExprNode([l; r], [])\r\n  | Expr.Number _\r\n  | Expr.Boolean _\r\n  | Expr.String _\r\n  | Expr.Empty -> ExprLeaf()\r\n"]}