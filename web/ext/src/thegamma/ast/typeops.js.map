{"version":3,"sources":["../../../../src/thegamma/ast/typeops.fs"],"names":[],"mappings":"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","file":"typeops.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Types\r\nopen TheGamma.Common\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Helper functions for type equality and substitution\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype TypeContext = \r\n  { EquivalentVars : (TypeVar * TypeVar) list }\r\n\r\nlet rec listsEqual l1 l2 f = \r\n  match l1, l2 with\r\n  | [], [] -> true\r\n  | x::xs, y::ys when f x y -> listsEqual xs ys f\r\n  | _ -> false \r\n\r\nlet rec arraysEqual (l1:_[]) (l2:_[]) f = \r\n  let rec loop i =\r\n    if i = l1.Length && i = l2.Length then true\r\n    elif i < l1.Length && i < l2.Length then \r\n      f (l1.[i]) (l2.[i]) && loop (i+1)\r\n    else false\r\n  loop 0\r\n\r\nlet rec memberNamesEqual m1 m2 =\r\n  match m1, m2 with \r\n  | Member.Property(name=n1), Member.Property(name=n2)\r\n  | Member.Method(name=n1), Member.Method(name=n2) -> n1 = n2 \r\n  | _ -> false\r\n\r\nlet (|BoundTypeVariables|) t = \r\n  match t with \r\n  | Type.Forall(vars, _) -> vars, t\r\n  | _ -> [], t\r\n\r\nlet rec membersEqual ctx m1 m2 =\r\n  match m1, m2 with \r\n  | Member.Property(n1, t1, _, _), Member.Property(n2, t2, _, _) -> \r\n      n1 = n2 && typesEqualAux ctx t1 t2\r\n  | Member.Method(n1, a1, BoundTypeVariables (v1, r1), _, _), Member.Method(n2, a2, BoundTypeVariables (v2, r2), _, _) -> \r\n      let ctx = { ctx with EquivalentVars = List.append (List.zip v1 v2) ctx.EquivalentVars }\r\n      n1 = n2 && typesEqualAux ctx r1 r2 && \r\n        listsEqual a1 a2 (fun (s1, b1, t1) (s2, b2, t2) -> \r\n          s1 = s2 && b1 = b2 && typesEqualAux ctx t1 t2)\r\n  | _ -> false\r\n\r\nand typesEqualAux ctx t1 t2 = \r\n  match t1, t2 with\r\n  | Type.Any, _ | _, Type.Any -> true\r\n  | Type.Parameter(p1), Type.Parameter(p2) ->\r\n      ctx.EquivalentVars |> List.exists (fun (l, r) -> l = p1 && r = p2)\r\n  | Type.Delayed(g1, _), Type.Delayed(g2, _) -> g1 = g2\r\n  | Type.List t1, Type.List t2 -> typesEqualAux ctx t1 t2\r\n  | Type.Function(a1, r1), Type.Function(a2, r2) -> \r\n      listsEqual (r1::a1) (r2::a2) (typesEqualAux ctx)\r\n  | Type.Object(o1), Type.Object(o2) -> arraysEqual o1.Members o2.Members (membersEqual ctx)\r\n  | Type.Primitive n1, Type.Primitive n2 -> n1 = n2  \r\n  | Type.Forall(v1, t1), Type.Forall(v2, t2) when List.length v1 = List.length v2 ->\r\n      let ctx = { ctx with EquivalentVars = List.append (List.zip v1 v2) ctx.EquivalentVars }\r\n      typesEqualAux ctx t1 t2\r\n  | Type.App(t1, ts1), Type.App(t2, ts2) when List.length ts1 = List.length ts2 ->\r\n      (t1, t2)::(List.zip ts1 ts2) |> List.forall (fun (t1, t2) -> typesEqualAux ctx t1 t2)\r\n  | _ -> false\r\n\r\n/// Returns true when closed types have equivalent structure up to renaming of local type variables\r\nlet typesEqual = typesEqualAux { EquivalentVars = [] }\r\n\r\nlet rec substituteMembers assigns members = \r\n  members |> Array.map (function\r\n    | Member.Method(n,ars,BoundTypeVariables (vars, t),d,e) -> \r\n        // Generic methods are encoded as methods with forall return type\r\n        // but we need to avoid substituting in parameters too!\r\n        let assigns = vars |> List.fold (fun assigns var -> Map.remove var assigns) assigns\r\n        let ars = ars |> List.map (fun (n,o,t) -> n, o, substituteTypes assigns t)\r\n        Member.Method(n,ars,substituteTypes assigns t,d,e)\r\n    | Member.Property(n,t,m,e) -> Member.Property(n,substituteTypes assigns t,m,e))      \r\n\r\n/// Substitute types for type variables in a given type\r\nand substituteTypes assigns t =\r\n  match t with\r\n  | Type.Parameter s when Map.containsKey s assigns -> assigns.[s]\r\n  | Type.Parameter _ | Type.Any | Type.Primitive _ -> t\r\n  | Type.Function(ts, t) -> Type.Function(List.map (substituteTypes assigns) ts, substituteTypes assigns t)\r\n  | Type.List(t) -> Type.List(substituteTypes assigns t)\r\n  | Type.Object(o) -> { Members = substituteMembers assigns o.Members } |> Type.Object\r\n  | Type.Delayed(g, f) -> \r\n      let f = \r\n        { new Future<Type> with \r\n            member x.Then(g) =             \r\n              f.Then(fun t -> g (substituteTypes assigns t)) }\r\n      Type.Delayed(g, f)\r\n  | Type.App(t, ts) -> Type.App(substituteTypes assigns t, List.map (substituteTypes assigns) ts)\r\n  | Type.Forall(vars, t) ->\r\n      let assigns = vars |> List.fold (fun assigns var -> Map.remove var assigns) assigns\r\n      Type.Forall(vars, substituteTypes assigns t)\r\n\r\ntype UnifictionContext = \r\n  { FreeVars : Set<TypeVar>\r\n    Assignments : (TypeVar * Type) list\r\n    EquivalentVars : (TypeVar * TypeVar) list \r\n    Errors : (Type * Type) list }\r\n\r\nlet rec unifyTypesAux ctx ts1 ts2 =\r\n  match ts1, ts2 with\r\n  | Type.Parameter n::ts1, t::ts2 when \r\n        ( ctx.FreeVars.Contains n &&\r\n          match t with Type.Parameter _ -> false | _ -> true ) ->\r\n      unifyTypesAux { ctx with Assignments = (n, t)::ctx.Assignments } ts1 ts2\r\n  | Type.Function(tis1, to1)::ts1, Type.Function(tis2, to2)::ts2 ->\r\n      unifyTypesAux ctx (to1::tis1 @ ts1) (to2::tis2 @ ts2)\r\n  | Type.Object({ Members = m1 })::ts1, Type.Object({ Members = m2 })::ts2 \r\n      when arraysEqual m1 m2 memberNamesEqual ->\r\n        unifyTypesAux ctx ts1 ts2\r\n  | Type.List(t1)::ts1, Type.List(t2)::ts2 -> \r\n      unifyTypesAux ctx (t1::ts1) (t2::ts2)\r\n  | Type.Forall(v1, t1)::ts1, Type.Forall(v2, t2)::ts2 when List.length v1 = List.length v2 ->\r\n      let ctx = { ctx with UnifictionContext.EquivalentVars = List.append (List.zip v1 v2) ctx.EquivalentVars }\r\n      unifyTypesAux ctx (t1::ts1) (t2::ts2)\r\n  | Type.App(t1, ta1)::tb1, Type.App(t2, ta2)::tb2 when List.length ta1 = List.length ta2 ->\r\n      unifyTypesAux ctx (t1::(List.append ta1 tb1)) (t2::(List.append ta2 tb2))\r\n  | t1::ts1, t2::ts2 when typesEqualAux { EquivalentVars = ctx.EquivalentVars } t1 t2 ->\r\n      unifyTypesAux ctx ts1 ts2  \r\n  | t1::ts1, t2::ts2 -> \r\n      unifyTypesAux { ctx with Errors = (t1, t2)::ctx.Errors } ts1 ts2\r\n  | [], [] -> ctx\r\n  | _ -> failwith \"unifyTypesAux: The lists of types had mismatching lengths\"\r\n\r\n/// Unify a type with given free type variables with a given closed type\r\n/// and return assignments (possibly conflicting) with mismatching types \r\nlet unifyTypes free ts1 ts2 = \r\n  let ctx = { FreeVars = set free; Assignments = []; EquivalentVars = []; Errors = [] }\r\n  let ctx = unifyTypesAux ctx [ts1] [ts2]\r\n  ctx.Assignments, ctx.Errors\r\n\r\n/// Perform type applications \r\nlet rec reduceType t = \r\n  match t with\r\n  | Type.App(Type.Forall(vars, t), args) ->\r\n      if List.length vars <> List.length args then failwith \"reduceType: Invalid type application\"\r\n      let t = substituteTypes (Map.ofList (List.zip vars args)) t\r\n      reduceType t \r\n  | _ -> t"]}