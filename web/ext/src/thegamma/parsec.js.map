{"version":3,"sources":["../../../src/thegamma/parsec.fs"],"names":[],"mappings":"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","file":"parsec.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿// ------------------------------------------------------------------------------------------------\r\n// Minimal parser combinator library with a few optimized functions\r\n// that should hopefuly make it work decently when compiled to JavaScript\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nmodule TheGamma.Parsec\r\n\r\ntype ParseStream<'T> = int * list<'T>\r\n\r\n/// A parser takes a list of inputs and either fails or produces a list\r\n/// of unconsumed inputs together with the result of the parsing\r\ntype Parser<'T, 'R> = Parser of (ParseStream<'T> -> option<ParseStream<'T> * Error<Range> list * 'R>)\r\n\r\n/// Returned by the `slot` function to create a parser slot that is filled later\r\ntype ParserSetter<'T, 'R> = \r\n  { Set : Parser<'T, 'R> -> unit }\r\n\r\n/// Ignore the result of the parser\r\nlet ignore (Parser p) = Parser(fun input -> \r\n  p input |> Option.map (fun (i, e, r) -> i, e, ()))\r\n\r\n/// Creates a delayed parser whose actual parser is set later\r\nlet slot () = \r\n  let mutable slot = None\r\n  { Set = fun (Parser p) -> slot <- Some p },\r\n  Parser(fun input -> slot.Value input)\r\n\r\n/// If the input matches the specified prefix, produce the specified result\r\nlet prefix (prefix:list<'C>) result = Parser(fun (offset, input) ->\r\n  let rec loop (word:list<'C>) input =\r\n    match word, input with\r\n    | c::word, i::input when c = i -> loop word input\r\n    | [], input -> Some(input)\r\n    | _ -> None\r\n\r\n  match loop prefix input with\r\n  | Some(input) -> Some((offset+List.length prefix, input), [], result)\r\n  | _ -> None)\r\n\r\n/// Parser that succeeds when either of the two arguments succeed\r\nlet (<|>) (Parser p1) (Parser p2) = Parser(fun input ->\r\n  match p1 input with\r\n  | Some(input, err, res) -> Some(input, err, res)\r\n  | _ -> p2 input)\r\n\r\n/// Run two parsers in sequence and return the result as a tuple\r\nlet (<*>) (Parser p1) (Parser p2) = Parser(fun input ->\r\n  match p1 input with\r\n  | Some(input, e1, res1) ->\r\n      match p2 input with\r\n      | Some(input, e2, res2) -> Some(input, e1 @ e2, (res1, res2))\r\n      | _ -> None\r\n  | _ -> None)\r\n\r\n/// Transforms the result of the parser using the specified function\r\nlet map f (Parser p) = Parser(fun input -> \r\n  p input |> Option.map (fun (input, err, res) -> input, err, f res))\r\n\r\n/// Run two parsers in sequence and return the result of the second one\r\nlet (<*>>) p1 p2 = p1 <*> p2 |> map snd\r\n\r\n/// Run two parsers in sequence and return the result of the first one\r\nlet (<<*>) p1 p2 = p1 <*> p2 |> map fst\r\n\r\n/// Succeed without consuming input\r\nlet unit res = Parser(fun input -> Some(input, [], res))\r\n\r\n/// Report an error and succeed without consuming input\r\nlet error e = Parser(fun input -> Some(input, [e], ()))\r\n\r\n/// Parse using the first parser and then call a function to produce\r\n/// next parser and parse the rest of the input with the next parser\r\nlet bind f (Parser p) = Parser(fun input ->\r\n  match p input with\r\n  | Some(input, err1, res) ->\r\n      let (Parser g) = f res\r\n      match g input with\r\n      | Some(input, err2, res) -> Some(input, err1 @ err2, res)\r\n      | _ -> None\r\n  | _ -> None)       \r\n  \r\n/// Parser that tries to use a specified parser, but returns None if it fails\r\nlet optional (Parser p) = Parser(fun input ->\r\n  match p input with\r\n  | None -> Some(input, [], None)\r\n  | Some(input, err, res) -> Some(input, err, Some res) )\r\n\r\n/// Parser that succeeds if the input matches a predicate\r\nlet pred p = Parser(function\r\n  | offs, c::input when p c -> Some((offs+1, input), [], c)\r\n  | _ -> None)\r\n\r\n/// Parser that succeeds if the predicate returns Some value\r\nlet choose p = Parser(function\r\n  | offs, c::input -> p c |> Option.map (fun c -> (offs + 1, input), [], c)\r\n  | _ -> None)\r\n\r\n/// Parse zero or more repetitions using the specified parser\r\nlet zeroOrMore (Parser p) = \r\n  let rec loop acc errs input = \r\n    match p input with\r\n    | Some(input, e, res) -> loop (res::acc) (e @ errs) input\r\n    | _ -> Some(input, errs, List.rev acc)\r\n  Parser(loop [] [])     \r\n\r\n/// Parse one or more repetitions using the specified parser\r\nlet oneOrMore p = \r\n  (p <*> (zeroOrMore p)) \r\n  |> map (fun (c, cs) -> c::cs)\r\n\r\n/// Run the specified parser and annotate the result with range information\r\nlet range (Parser p) = Parser(fun ((offs1, _) as input) ->\r\n  p input |> Option.map (fun (((offs2, _) as input), errs, res) -> \r\n    input, errs, ({ Start = offs1; End = offs2 }, res) ))\r\n\r\n/// Parse a sequence of inputs recognized using the secified sequence\r\n/// of parsers. Calling `sequenceChoices [ p1 .. pn ]` is a like\r\n/// `zeroOrMore (p1 <|> .. <|> pn)` but faster and non-recursive.\r\nlet sequenceChoices parsers = Parser(fun input ->\r\n  let mutable input = input\r\n  let mutable running = true\r\n  let mutable results = []\r\n  let mutable errors = []\r\n  while running do\r\n    running <- false\r\n    let mutable parsers = parsers\r\n    while not (List.isEmpty parsers) do\r\n      let (Parser p) = List.head parsers\r\n      match p input with \r\n      | Some(newInput, err, res) ->\r\n          input <- newInput\r\n          running <- true\r\n          results <- res::results\r\n          parsers <- []\r\n          errors <- err @ errors\r\n      | None -> \r\n          parsers <- List.tail parsers\r\n  Some(input, errors, List.rev results))\r\n\r\n"]}