{"version":3,"sources":["../../../src/thegamma/editors.fs"],"names":[],"mappings":"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","file":"editors.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Editors\r\n\r\nopen Fable.Import\r\n\r\nopen TheGamma\r\nopen TheGamma.Ast\r\nopen TheGamma.TypeChecker\r\nopen TheGamma.Common\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Finding editor components in code\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype Property = \r\n  | Property of string * Metadata option * Type\r\n\r\ntype Editor = \r\n  | SingleChoice of Documentation * Node<Name> * Property[]\r\n  | NestedChoice of Documentation * Documentation * Node<Name> * Node<Name> * (Property * Property[])[]\r\n  | CreateList of Documentation * Node<Name> * Node<Name>[] * Property[]\r\n  member x.Range = \r\n    match x with\r\n    | SingleChoice(_, n, _) -> n.Range\r\n    | NestedChoice(_, _, n1, n2, _) -> Ast.unionRanges n1.Range n2.Range\r\n    | CreateList(_, n, n2, _) -> n2 |> Array.fold (fun r n -> Ast.unionRanges r n.Range) { n.Range with Start = n.Range.End }\r\n\r\nlet rec getMembers typ = async {\r\n  match typ with\r\n  | Type.Object(o) -> \r\n      return o.Members\r\n  | Type.Delayed(_, f) ->\r\n      let! typ = Async.AwaitFuture f\r\n      return! getMembers typ \r\n  | _ -> \r\n    Log.error(\"editors\", \"getMembers: Type %O is not an object\", typ)\r\n    return failwith \"getMembers: Not an object\" }\r\n\r\nlet extractMetadata m = \r\n  let doc = m |> Seq.tryPick (fun m -> \r\n    if m.Context = \"http://thegamma.net\" && m.Type = \"Documentation\" \r\n      then Some(unbox<Documentation> m.Data) else None)\r\n  let schema = m |> Seq.tryPick (fun m -> \r\n    if m.Context = \"http://schema.org\" then Some(m) else None)\r\n  schema, defaultArg doc Documentation.None\r\n\r\nlet getProperty (name:Name) members = \r\n  members |> Array.tryPick (function \r\n    | Member.Property(name=n; meta=m; typ=t) when n=name.Name -> \r\n        let schema, doc = extractMetadata m\r\n        Some(schema, t,  doc)\r\n    | _ -> None)\r\n\r\nlet filterProperties f members = \r\n  let filtered = members |> Array.choose (function \r\n    | Member.Property(name=n; meta=m; typ=t) ->\r\n        let schema, doc = extractMetadata m\r\n        if f (n, schema, t) then Some(Property.Property(n, schema, t))\r\n        else None\r\n    | _ -> None)\r\n  filtered \r\n\r\nlet dominant all subset =\r\n  let nall = Seq.length all\r\n  let nsub = Seq.length subset\r\n  nsub >= 2 && nsub >= nall * 2 / 3\r\n\r\nlet chooseableProperty equalTyp (name:Node<Name>) typ = async {\r\n  let! members = getMembers typ\r\n  match getProperty name.Node members with\r\n  | Some(Some propSchema, propTyp, _) ->\r\n      let alts = members |> filterProperties (function\r\n        | _, Some s, t -> s.Type = propSchema.Type && (not equalTyp || Types.typesEqual t propTyp)\r\n        | _ -> false )\r\n      if dominant members alts then return Some(name, alts)\r\n      else return None \r\n  | _ -> return None }\r\n\r\n/// Walk over expression and call 'f' with all property chain suffixes.\r\n/// Given `a.b.c`, it will be called with [c], [b;c], [a;b;c].\r\nlet pickChainSuffixes f expr = \r\n  let rec loop res suffix expr = async {\r\n    match expr.Node with\r\n    | Expr.Property(inst, name) ->\r\n        let! members = getMembers inst.Entity.Value.Type.Value\r\n        match getProperty name.Node members with\r\n        | Some(propSch, propTy, propDoc) ->\r\n            let suffix = (inst.Entity.Value.Type.Value, name, propSch, propTy, propDoc)::suffix\r\n            let! picked = f suffix\r\n            match picked with \r\n            | Some newRes -> return! loop (newRes::res) suffix inst\r\n            | _ -> return! loop res suffix inst \r\n        | None -> return! loop res suffix inst\r\n    | ExprNode(es, _) -> return! es |> Async.fold (fun st e -> loop st [] e) res \r\n    | ExprLeaf -> return res }\r\n  loop [] [] expr\r\n\r\n\r\nlet collectSingleChoiceEditors =\r\n  pickChainSuffixes (fun chain -> async {\r\n    match chain with\r\n    | (tyParent, name, _, _, doc)::_ -> \r\n        let! ed = chooseableProperty true name tyParent\r\n        return Option.map (fun (n, p) -> SingleChoice(doc, n, p)) ed\r\n    | _ -> return None })\r\n\r\nlet collectNestedChoiceEditors = \r\n  pickChainSuffixes (fun chain -> async {\r\n    match chain with\r\n    | (catParentTy, catName, catSch, catTy, catDoc)::\r\n          (valParentTy, valName, (Some valSch), valTy, valDoc)::_ ->\r\n        Log.trace(\"editors\", \"checking %s.%s\", catName.Node.Name, valName.Node.Name)\r\n        let! catp = chooseableProperty false catName catParentTy\r\n        let! valp = chooseableProperty true valName valParentTy\r\n        match catp, valp with\r\n        | Some(catName, catMembers), Some(valName, valMembers) ->\r\n            Log.trace(\"editors\", \"collecting %s nested members\", catMembers.Length)\r\n            let nestedMembers trunc = \r\n              catMembers |> trunc |> Async.Array.map (fun (Property(n, _, t) as p) -> async {\r\n              let! members = getMembers t\r\n              let filtered = members |> filterProperties (function\r\n                | (n, Some s, t) -> s.Type = valSch.Type && Types.typesEqual t valTy\r\n                | _ -> false )\r\n              return p, (members, filtered) })\r\n            let! checkMembers = nestedMembers (Seq.truncate 5 >> Array.ofSeq) (* take at most 5...  - Array.truncate TBD *) \r\n            if Seq.length checkMembers > 2 && dominant (Seq.collect (snd >> fst) checkMembers) (Seq.collect (snd >> snd) checkMembers) then\r\n              let! allMembers = nestedMembers id\r\n              let props = allMembers |> Array.map (fun (p, (_, filtered)) ->\r\n                p, filtered)\r\n              return Some(NestedChoice(catDoc, valDoc, catName, valName, props))\r\n            else return None\r\n        | _ -> return None\r\n    | _ -> return None })\r\n\r\ntype ItemListSchema = { name : string }\r\ntype CreateActionSchema = { result : ItemListSchema }\r\ntype AddActionSchema = { targetCollection : ItemListSchema }\r\n\r\nlet collectItemListEditors =\r\n  pickChainSuffixes (fun chain -> async {\r\n    match chain with\r\n    | (_, _, Some caSch1, _, _)::(_, _, Some caSch2, _, _)::_ when caSch1.Type = \"CreateAction\" && caSch2.Type = \"CreateAction\" ->\r\n        // Ad-hoc case when we have multiple keys in 'group by'\r\n        return None\r\n\r\n    | (caParentTy, caName, Some caSch, caTy, catDoc)::addActions when caSch.Type = \"CreateAction\" ->\r\n        let listName = (unbox<CreateActionSchema> caSch.Data).result.name\r\n\r\n        /// Collect all AddActions in the rest of the chain and return\r\n        /// the added options together with the type of the last member \r\n        let rec collectAdds added lastTy = function\r\n          | (addParentTy, addName, Some (addSch:Metadata), addTy, _)::addActions when \r\n                addSch.Type = \"AddAction\" &&\r\n                listName = (unbox<AddActionSchema> addSch.Data).targetCollection.name ->\r\n              collectAdds (addName::added) addTy addActions\r\n          | _ -> List.rev added, lastTy\r\n\r\n        // Collect add actions from the rest of the chain & get available\r\n        // actions of the last type in the chain (that can be added)\r\n        let adds, lastTy = collectAdds [] caTy addActions\r\n        let! members = getMembers lastTy\r\n        let availableAdds = members |> filterProperties (function\r\n          | (n, Some s, t) when s.Type = \"AddAction\" -> (unbox<AddActionSchema> s.Data).targetCollection.name = listName\r\n          | _ -> false )\r\n        return Some(CreateList(catDoc, caName, Array.ofList adds, availableAdds))\r\n    | _ -> return None })\r\n\r\nlet collectCmdEditors (cmd:Node<Command>) = async {\r\n  match cmd.Node with \r\n  | Command.Let(_, e)\r\n  | Command.Expr e -> \r\n      Log.trace(\"editors\", \"single choice\")\r\n      let! single = collectSingleChoiceEditors e\r\n      Log.trace(\"editors\", \"item list\")\r\n      let! itemList = collectItemListEditors e\r\n      Log.trace(\"editors\", \"multi choice\")\r\n      let! nested = collectNestedChoiceEditors e\r\n      //let nested = []\r\n      return single @ nested @ itemList  }  \r\n\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Editors user interface\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nopen TheGamma.Html\r\nopen TheGamma.TypeChecker\r\n\r\nlet replace (rng:Range) newValue (text:string) = \r\n  text.Substring(0, rng.Start) + newValue + text.Substring(rng.End+1)\r\n\r\nlet replaceNameWithValue (text:string) (n:Node<Name>) value =\r\n  let newValue = escapeIdent value\r\n  replace n.Range newValue text\r\n\r\n/// Replace the second string first, assuming it is later in the text\r\nlet replaceTwoNamesWithValues (text:string) (n1:Node<Name>, n2:Node<Name>) (s1, s2) =\r\n  replace n1.Range (escapeIdent s1) (replace n2.Range (escapeIdent s2) text) \r\n  \r\nlet removeRangeWithPrecendingDot (text:string) (rng:Range) = \r\n  // Once we have comments, we need to skip over them too\r\n  let mutable start = rng.Start\r\n  while start > 0 && text.[start] <> '.'  do start <- start - 1\r\n  text.Substring(0, start) + text.Substring(rng.End+1)\r\n  \r\nlet insertDotTextAfter (origText:string) (rng:Range) ins =\r\n  origText.Substring(0, rng.End+1) + \".\" + escapeIdent ins + origText.Substring(rng.End+1)\r\n\r\nlet renderDoc = function\r\n  | Documentation.Text(s) -> h?h3 [] [ text s ]\r\n  | Documentation.None -> h?span [] []\r\n  | Documentation.Details(title, details) -> \r\n      h?div [] [ \r\n        h?h3 [] [ text title ]\r\n        h?p [] [ text details ] ]\r\n\r\nlet renderNestedDoc = function\r\n  | Documentation.Details(_, d1), Documentation.Details(t2, d2) ->\r\n      h?h3 [] [ text t2 ], h?p [] [ text d1; text d2 ]\r\n  | _ ->\r\n      h?h3 [] [ text \"Choose a value\" ], h?p [] [text \"First choose a category, then choose a value.\"]\r\n    \r\nlet renderEditor typeCheck (setValue:string -> string -> string -> unit) origText = function\r\n  | SingleChoice(doc, n, ms) ->\r\n      h?div [\"class\" => \"ed-single\"] [\r\n        renderDoc doc\r\n        h?div [\"class\" => \"control\"] [ \r\n          h?chosen \r\n            [ \"change\" =!> fun el e -> \r\n                let value = (unbox<Browser.HTMLSelectElement> el).value\r\n                replaceNameWithValue origText n value |> setValue \"single\" value ] \r\n            [ for (Property.Property(name, _, _)) in ms ->\r\n                let sel = if name = n.Node.Name then [\"selected\" => \"selected\"] else []\r\n                h?option sel [ text name ] ]\r\n        ]\r\n      ]\r\n  | CreateList(doc, ca, ns, ms) ->\r\n      let edits = ns |> Array.map (fun n -> n, removeRangeWithPrecendingDot origText n.Range)\r\n      let trigger, render = h.part Set.empty (fun s n -> Set.add n s) \r\n      \r\n      edits |> Array.iter (fun (n, edited) -> \r\n        async { let! safe = typeCheck edited\r\n                if safe then trigger n.Node.Name } |> Async.StartImmediate)\r\n      \r\n      render <| fun safe ->\r\n        h?div [\"class\" => \"ed-list\"] [\r\n          renderDoc doc\r\n          h?div [\"class\" => \"control\"] [ \r\n            h?ul [] [\r\n              for n, edit in edits -> \r\n                h?li [] [ \r\n                  let dis = not (Set.contains n.Node.Name safe)\r\n                  yield text n.Node.Name \r\n                  yield text \" \"\r\n                  yield h?button [\r\n                    if dis then yield \"disabled\" => \"disabled\"\r\n                    yield \"click\" =!> fun el e -> setValue \"list-delete\" n.Node.Name edit ] \r\n                    [ h?i [\"class\" => if dis then \"fa fa-ban\" else \"fa fa-times\" ] [] ]\r\n                ]\r\n            ]\r\n            h?chosen\r\n              [ \"data-placeholder\" => \"add another item...\"\r\n                \"change\" =!> fun el e -> \r\n                  let sel = (el :?> Browser.HTMLSelectElement).value\r\n                  let last = if ns.Length = 0 then ca else ns.[ns.Length - 1]\r\n                  insertDotTextAfter origText last.Range sel |> setValue \"list-add\" sel\r\n              ] \r\n              [ yield h?option [] []\r\n                for (Property.Property(name, _, _)) in ms ->\r\n                  h?option [] [ text name ]\r\n              ]\r\n          ]\r\n        ]\r\n\r\n  | NestedChoice(doc1, doc2, n1, n2, props) ->\r\n      let update, render = h.part (n1.Node.Name, n2.Node.Name) (fun _ n -> n)\r\n      render <| fun (name1, name2) ->\r\n        let selected = \r\n          props \r\n          |> Array.tryFind (fun (Property.Property(name, _, _), nested) -> name = name1) \r\n          |> Option.map snd\r\n        let nested = defaultArg selected [||]\r\n\r\n        let heading, p = renderNestedDoc (doc1, doc2)\r\n        h?div [\"class\" => \"ed-nested\"] [\r\n          heading\r\n          p\r\n          h?div [\"class\" => \"control\"] [ \r\n            h?chosen \r\n              [ \"change\" =!> fun el e -> update ((unbox<Browser.HTMLSelectElement> el).value, \"\") ] \r\n              [ for (Property.Property(name, _, _), nested) in props ->\r\n                  let sel = if name = name1 then [\"selected\" => \"selected\"] else []\r\n                  h?option sel [ text name ] ]\r\n            h?chosen \r\n              [ \"data-placeholder\" => \"choose an item...\" \r\n                \"change\" =!> fun el e -> \r\n                    let name2 = (unbox<Browser.HTMLSelectElement> el).value\r\n                    replaceTwoNamesWithValues origText (n1, n2) (name1, name2) \r\n                    |> setValue \"nested\" name2  ] \r\n              [ if name2 = \"\" then yield h?option [] []\r\n                for Property.Property(name, _, _) in nested ->\r\n                  let sel = if name = name2 then [\"selected\" => \"selected\"] else []\r\n                  h?option sel [ text name ] ]\r\n          ]\r\n        ]"]}