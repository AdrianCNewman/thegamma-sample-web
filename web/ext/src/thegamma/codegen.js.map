{"version":3,"sources":["../../../src/thegamma/codegen.fs"],"names":[],"mappings":"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","file":"codegen.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.CodeGenerator\r\n\r\nopen TheGamma\r\nopen TheGamma.Babel\r\nopen Fable.Extensions\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Compiling code to Babel AST\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype CompilationContext =\r\n  { LineLengths : int list\r\n    Globals : Map<string, Expression> }\r\n\r\nlet rec offsetToLocation lines offs lengths =\r\n  match lengths with\r\n  | l::lengths when offs <= l -> { line = lines; column = offs }\r\n  | l::lengths -> offsetToLocation (lines+1) (offs-l-1) lengths\r\n  | [] -> { line = lines; column = offs  } // error? out of range\r\n\r\nlet rangeToLoc ctx rng = \r\n  Some { start = offsetToLocation 1 rng.Start ctx.LineLengths \r\n         ``end`` = offsetToLocation 1 rng.Start ctx.LineLengths }\r\n\r\nlet rec getEmitter name typ = async {\r\n  match typ with\r\n  | Type.Object(o) -> \r\n      return o.Members |> Seq.pick (function \r\n        Member.Method(name=n; emitter=e) | Member.Property(name=n; emitter=e) when n=name -> Some e | _ -> None) \r\n  | Type.Delayed(_, f) ->\r\n      let! typ = Async.AwaitFuture f\r\n      return! getEmitter name typ \r\n  | _ -> return failwith \"getEmitter: Not an object\" }\r\n\r\nlet rec compileExpression ctx (expr:Expr<Type>) = async {\r\n  match expr.Expr with \r\n  | ExprKind.Call(inst, n, args) ->\r\n      let! emitter = getEmitter n.Name inst.Type\r\n      let! inst = compileExpression ctx inst\r\n      let! args = args |> Async.map (fun a -> async {\r\n        let! r = compileExpression ctx a.Value\r\n        return (match a.Name with Some n -> n.Name | _ -> \"\"), r })          // TODO: Names ...???\r\n      return emitter.Emit(inst, args)\r\n  | ExprKind.Property(inst, n) ->\r\n      let! emitter = getEmitter n.Name inst.Type\r\n      let! inst = compileExpression ctx inst\r\n      return emitter.Emit(inst, [])\r\n  | ExprKind.Null ->\r\n      return NullLiteral(rangeToLoc ctx expr.Range)\r\n  | ExprKind.Number(n) ->\r\n      return NumericLiteral(n, rangeToLoc ctx expr.Range)\r\n  | ExprKind.String(s) ->\r\n      return StringLiteral(s, rangeToLoc ctx expr.Range)\r\n  | ExprKind.Boolean(b) ->\r\n      return BooleanLiteral(b, rangeToLoc ctx expr.Range)\r\n  | ExprKind.Variable(n) when ctx.Globals.ContainsKey(n.Name) ->\r\n      return ctx.Globals.[n.Name]\r\n  | ExprKind.Variable(n) ->\r\n      return IdentifierExpression(n.Name, rangeToLoc ctx n.Range) \r\n  | ExprKind.List(es) ->\r\n      let! es = Async.map (compileExpression ctx) es\r\n      return ArrayExpression(es, rangeToLoc ctx expr.Range)\r\n  | ExprKind.Function(n, e) ->\r\n      let var = IdentifierExpression(n.Name, rangeToLoc ctx n.Range)\r\n      let! ce = compileExpression { ctx with Globals = Map.add n.Name var ctx.Globals } e\r\n      let body = BlockStatement([ReturnStatement(ce, rangeToLoc ctx e.Range)], rangeToLoc ctx e.Range)\r\n      return FunctionExpression(None, [IdentifierPattern(n.Name, rangeToLoc ctx n.Range)], body, false, false, rangeToLoc ctx expr.Range)\r\n  | ExprKind.Unit\r\n  | ExprKind.Empty ->      \r\n      Fable.Import.Browser.console.log(\"compileExpression: %O\", expr.Expr) \r\n      return failwith \"!\" }\r\n    \r\n\r\nlet compileCommand ctx (cmd:Command<Type>) = async {\r\n  match cmd.Command with\r\n  | CommandKind.Let(n, e) ->\r\n      let! e = compileExpression ctx e\r\n      let name = IdentifierPattern(n.Name, rangeToLoc ctx n.Range)\r\n      let decl = VariableDeclarator(name, Some e, rangeToLoc ctx cmd.Range)\r\n      return VariableDeclaration(Var, [decl], rangeToLoc ctx cmd.Range)\r\n  | CommandKind.Expr(e) ->\r\n      let! e = compileExpression ctx e\r\n      return ExpressionStatement(e, rangeToLoc ctx cmd.Range) }\r\n\r\nlet compileProgram ctx (prog:Program<Type>) = async {\r\n  let! body = Async.map (compileCommand ctx) prog.Body\r\n  return { location = rangeToLoc ctx prog.Range; body = body } }\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Running compiled ASTs\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype BabelOptions = \r\n  { presets : string[] }\r\n\r\ntype BabelResult = \r\n  { code : string }\r\ntype Babel =\r\n  abstract transformFromAst : obj * string * BabelOptions -> BabelResult\r\n\r\n[<Emit(\"Babel\")>]\r\nlet babel : Babel = Unchecked.defaultof<_> \r\n\r\nlet compileAndRun globals (text:string) prog = async {\r\n  try\r\n    let! globals = Async.AwaitFuture globals\r\n    let ctx = { LineLengths = [ for l in text.Split('\\n') -> l.Length ]; Globals = globals }  \r\n    let! res = compileProgram ctx prog\r\n    let code = babel.transformFromAst(Serializer.serializeProgram res, text, { presets = [| \"es2015\" |] })\r\n    Log.trace(\"codegen\", \"Evaluating: %O\", code)\r\n    return code.code;\r\n  with e ->\r\n    Log.exn(\"codegen\", \"Evaluating code failed: %O\", e)\r\n    return \"\" }\r\n"]}