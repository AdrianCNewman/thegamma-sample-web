{"version":3,"sources":["../../../../src/thegamma/parser/parser.fs"],"names":[],"mappings":"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","file":"parser.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["﻿// ------------------------------------------------------------------------------------------------\r\n// Parser for TheGamma script langauge - turns Token[] into Program\r\n// ------------------------------------------------------------------------------------------------\r\nmodule TheGamma.Parser\r\n\r\nopen TheGamma\r\nopen TheGamma.Ast\r\nopen TheGamma.Common\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// This is mostly a recursive-descent parser with a lot of additional bookkeeping for decent\r\n// error recovery - this is indentation sensitive and parameters after `(` always have to be\r\n// indented further. The `nestedToken` function returns `None` if the currently nested block ends.\r\n// In erroneous case, we generally skip all errors within block, but terminate the current\r\n// syntactic structure at block end (and treat it as next thing) \r\n// ------------------------------------------------------------------------------------------------\r\n\r\n/// Parsing context is mutated, because we never backtrack (except for one case,\r\n/// in which case we clone the context explicitly using `clone`)\r\ntype Context = \r\n  { Tokens : Token[]\r\n    Whitespace : ResizeArray<Token>\r\n    Errors : ResizeArray<Error<Range>>\r\n    mutable TopLevel : bool\r\n    mutable Silent : bool\r\n    mutable StrictlyNested : bool\r\n    mutable IndentCurrent : int\r\n    mutable IndentStack : (int * bool) list\r\n    mutable Position : int }\r\n\r\n/// Lets us implement lookahead withot making the whole context immutable\r\n/// (this is only used in fairly limited scenarios - e.g. named arguments)\r\nlet clone ctx = \r\n  { Tokens = ctx.Tokens\r\n    Whitespace = ResizeArray(ctx.Whitespace)\r\n    Errors = ResizeArray(ctx.Errors)\r\n    TopLevel = ctx.TopLevel\r\n    Silent = ctx.Silent\r\n    StrictlyNested = ctx.StrictlyNested\r\n    IndentCurrent = ctx.IndentCurrent\r\n    IndentStack = ctx.IndentStack \r\n    Position = ctx.Position }\r\n\r\n/// Advance the position\r\nlet next ctx = \r\n  ctx.Position <- ctx.Position + 1\r\n\r\n/// Temporarilly silence all error reports (we're in wrong state anyway)\r\nlet usingSilentMode ctx = \r\n  let prev = ctx.Silent\r\n  ctx.Silent <- true\r\n  { new System.IDisposable with\r\n      member x.Dispose() = ctx.Silent <- prev }\r\n\r\n/// Report error if we are not in silent mode\r\nlet addError ctx e = \r\n  if not ctx.Silent then ctx.Errors.Add(e)\r\n\r\n/// Specify that all further tokens should be indented. If `current`, then\r\n/// we use indentation of the current line, otherwise, we use indentation\r\n/// of the next line (as set by `setLineIndent`).\r\nlet usingIndent current (tok:Token) ctx =\r\n  let started = \r\n    match ctx.IndentStack with\r\n    | (prev, true)::_ when prev > ctx.IndentCurrent -> \r\n        Errors.Parser.unindentedBlock tok.Range tok.Token |> addError ctx\r\n        false\r\n    | (prev, false)::_ when prev <> ctx.IndentCurrent -> \r\n        failwith \"usingIndent: We forgot to set the top-stack line indentation\"\r\n    | _ ->\r\n        ctx.IndentStack <- (ctx.IndentCurrent, current)::ctx.IndentStack\r\n        true\r\n  { new System.IDisposable with\r\n      member x.Dispose() =\r\n        match started, ctx.IndentStack with\r\n        | true, t::stack -> ctx.IndentStack <- stack\r\n        | false, _ -> ()\r\n        | _ -> failwith \"usingIndent: We lost item from an indentation stack\" }\r\n\r\n/// In this mode, we accept toknes that are not indented at line 0 \r\n/// (which is useful when parsing erroneously nested top-level commands)\r\nlet usingTopLevelNesting ctx = \r\n  let prev = ctx.StrictlyNested\r\n  ctx.StrictlyNested <- true\r\n  match ctx.IndentStack with\r\n  | x::xs -> ctx.IndentStack <- (0, true)::xs\r\n  | _ -> ()\r\n  { new System.IDisposable with\r\n      member x.Dispose() = ctx.StrictlyNested <- prev }\r\n\r\n/// When we are not at top-level, we can break indentation rules \r\n/// (and report an error)\r\nlet usingNonTopLevel ctx = \r\n  let prev = ctx.TopLevel\r\n  ctx.TopLevel <- false\r\n  { new System.IDisposable with\r\n      member x.Dispose() = ctx.TopLevel <- prev }\r\n\r\n/// Set current line indent after parsing a token\r\nlet setLineIndent ctx l = \r\n  ctx.IndentCurrent <- l\r\n  match ctx.IndentStack with\r\n  | (oldl, false)::stack when l <= oldl -> ctx.IndentStack <- (System.Int32.MaxValue, true)::stack\r\n  | (oldl, false)::stack -> ctx.IndentStack <- (l, true)::stack\r\n  | _ -> ()\r\n\r\n/// Parses next non-white token & accumulates whitespace\r\nlet rec justToken ctx = \r\n  let current ctx = ctx.Tokens.[ctx.Position]\r\n  match current ctx with\r\n  | { Token = TokenKind.Newline } as t ->\r\n      ctx.Whitespace.Add t\r\n      next ctx\r\n      match current ctx with\r\n      | { Token = TokenKind.White s } as t ->          \r\n          ctx.Whitespace.Add t\r\n          setLineIndent ctx s.Length\r\n          next ctx\r\n      | _ -> \r\n          setLineIndent ctx 0\r\n      justToken ctx\r\n  | { Token = TokenKind.Error _ | TokenKind.White _ } as t ->\r\n      ctx.Whitespace.Add t\r\n      next ctx\r\n      justToken ctx\r\n  | t -> \r\n      t\r\n\r\n/// Parses token and eats all whitespace before it\r\nlet token ctx = \r\n  let t = justToken ctx\r\n  let white = ctx.Whitespace |> Seq.toList\r\n  ctx.Whitespace.Clear()\r\n  white, t\r\n\r\n/// Parses nested token and eats all whitespace before it\r\nlet nestedToken ctx = \r\n  let white () =\r\n    let white = ctx.Whitespace |> Seq.toList\r\n    ctx.Whitespace.Clear()\r\n    white\r\n  let t = justToken ctx\r\n  match ctx.IndentStack with\r\n  | (indent, _)::_ when ctx.IndentCurrent > indent || (not ctx.StrictlyNested && ctx.IndentCurrent = indent) -> Some(white(), t)\r\n  | [] -> Some(white(), t)\r\n  | _ -> None\r\n\r\n/// Creates a node with a range and no whitespace\r\nlet node rng n = \r\n  { Node = n; Range = rng; WhiteBefore = []; WhiteAfter = []; Entity = None }\r\n\r\n/// Appends whitespace after node\r\nlet whiteAfter w n = { n with WhiteAfter = n.WhiteAfter @ w  }\r\n\r\n/// Preppends whitespace beforenode\r\nlet whiteBefore w n = { n with WhiteBefore = w @ n.WhiteBefore }\r\n\r\n/// Return range of the last element of call chain\r\nlet lastCallOrPropertyRange expr id =\r\n  match expr with\r\n  | { Node = Expr.Call(_, id, _) | Expr.Property(_, id) } -> id.Range \r\n  | _ -> expr.Range\r\n\r\n/// Parsed token is identifier or quoted identifier (with preceding whitespace)\r\nlet (|Identifier|_|) t = \r\n  match t with\r\n  | white, { Range = rng; Token = (TokenKind.Ident id | TokenKind.QIdent id) } ->\r\n      node rng { Name.Name = id } |> whiteBefore white |> Some\r\n  | _ -> None\r\n\r\n/// Pattern matching helper\r\nlet (|Let|) a b = a, b\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Operator precedence handling\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype Associativity = Left | Right\r\n\r\nlet precedence = function\r\n  | Operator.Equals -> 0, Left\r\n  | Operator.GreaterThan | Operator.GreaterThanOrEqual\r\n  | Operator.LessThan | Operator.LessThanOrEqual -> 1, Left\r\n  | Operator.Plus | Operator.Minus -> 2, Left\r\n  | Operator.Multiply | Operator.Divide -> 3, Left\r\n  | Operator.Power -> 4, Right\r\n  \r\n/// Represnts a sequence of expressions separated by binary operators\r\n/// (e.g. 'f x + 1 * 2 / g y' has 4 expressions separated by 3 operators)\r\ntype OpExpr = OpExpr of Node<Expr> * option<Node<Operator> * OpExpr>\r\n\r\n/// Turn 'OpExpr' into a parsed 'Expr' using the \"Precedence climbing method\"\r\n/// (see https://en.wikipedia.org/wiki/Operator-precedence_parser)\r\nlet rec precClimb minPrec (OpExpr(app, next)) =   \r\n  let rec loop result (next:(Node<Operator>*OpExpr) option) = \r\n    match next with \r\n    | Some(op, next) when fst (precedence op.Node) >= minPrec ->\r\n        let prec, assoc = precedence op.Node\r\n        let nextMinPrec = \r\n          if assoc = Left then prec + 1 else prec\r\n        let rhs, next = precClimb nextMinPrec next\r\n        let result = node (unionRanges result.Range rhs.Range) (Expr.Binary(result, op, rhs))\r\n        loop result next\r\n    | _ -> result, next      \r\n  loop app next\r\n\r\n/// The terms are passed in reverse order as accumulated\r\nlet buildExpression terms term =\r\n  terms \r\n  |> List.fold (fun oe (t, op) -> OpExpr(t, Some(op, oe))) (OpExpr(term, None))\r\n  |> precClimb 0\r\n  |> fst\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// The parser\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nlet makeCallOrProp optInst prevId prevArgs =\r\n  // Reconstruct previous bit of the chain from optInst/prevId/prevArgs\r\n  match optInst, prevArgs with\r\n  | Some inst, None -> node (unionRanges inst.Range prevId.Range) (Expr.Property(inst, prevId))\r\n  | None, None -> node prevId.Range (Expr.Variable(prevId))\r\n  | _, Some prevArgs -> \r\n      let fullRng = \r\n        match optInst with \r\n        | Some i -> unionRanges i.Range prevArgs.Range \r\n        | _ -> unionRanges prevId.Range prevArgs.Range\r\n      node fullRng (Expr.Call(optInst, prevId, prevArgs))\r\n\r\n/// Property access or method call after '.' in a nested block\r\nlet rec parseChain dotRng optInst prevId prevArgs prevWhite ctx = \r\n  let inst = makeCallOrProp optInst prevId prevArgs |> whiteAfter prevWhite\r\n  let emptyRng = { Start=dotRng.End + 1; End=dotRng.End + 1 }\r\n  let emptyMember = node emptyRng (Expr.Property(inst, node emptyRng { Name = \"\" })) \r\n\r\n  match nestedToken ctx with\r\n  | Some (Identifier id) ->\r\n      next ctx\r\n      parseMember (Some inst) id ctx\r\n\r\n  | Some(_, t) ->      \r\n      // Error: Expected identifier (after '.') but there was some other token\r\n      // at the correct level of nesting, so skip it & try prsing next thing\r\n      Errors.Parser.unexpectedTokenAfterDot t.Range t.Token |> addError ctx \r\n      if t.Token = TokenKind.EndOfFile then emptyMember\r\n      else \r\n        next ctx\r\n        use _silent = usingSilentMode ctx\r\n        parseMember (Some inst) (node emptyRng { Name = \"\" }) ctx\r\n      \r\n  | None ->\r\n  match token ctx with\r\n  | Identifier id ->\r\n      // Error: There is an identifier after '.' but it is not properly indented\r\n      let rng = lastCallOrPropertyRange inst\r\n      Errors.Parser.unindentedIdentifierAfterDot id.Range rng id.Node.Name |> addError ctx \r\n      // If we are at top-level, we stop (to avoid consuming next line). \r\n      // If we are inside expression list and not all the way to the left, \r\n      //  we continue - but for that, we unindent the current stack\r\n      match ctx.TopLevel, ctx.IndentStack with \r\n      | false, (sl, si)::stack when ctx.IndentCurrent > 0 ->\r\n          next ctx\r\n          ctx.IndentStack <- (ctx.IndentCurrent, si)::stack\r\n          parseMember (Some inst) id ctx\r\n      | _ -> emptyMember\r\n\r\n  | _, t ->      \r\n      // Error: Expected more after '.' but the nested scope ends here\r\n      // Just return what we got so far & end the current chain\r\n      let rng = lastCallOrPropertyRange inst\r\n      Errors.Parser.unexpectedScopeEndAfterDot t.Range rng t.Token |> addError ctx \r\n      emptyMember\r\n\r\n\r\n/// Helper used by 'parseMember' - parse '.' or '(...)' after ident in a chain\r\nand parseDotOrLParen optInst id ctx tok = \r\n  match tok with\r\n  | { Token = TokenKind.LParen } ->\r\n      next ctx\r\n      use _top = usingNonTopLevel ctx\r\n      let endRange, white, args = parseCallArgList false tok.Range [] ctx\r\n      let args = node (unionRanges tok.Range endRange) args |> whiteAfter white\r\n      \r\n      // Call can be followed by '.' or end of call chain\r\n      match nestedToken ctx with\r\n      | Some(whiteAfterArgs, { Token = TokenKind.Dot; Range = dotRng }) ->\r\n          next ctx\r\n          Some(parseChain dotRng optInst id (Some args) whiteAfterArgs ctx)\r\n      | _ ->\r\n          Some(makeCallOrProp optInst id (Some args))\r\n\r\n  | { Token = TokenKind.Dot } ->\r\n      next ctx\r\n      Some(parseChain tok.Range optInst id None [] ctx)\r\n\r\n  | _ -> None\r\n\r\n\r\n/// Call chain after name - either '.' & more or '(...)' or end of call chain\r\nand parseMember (optInst:option<_>) (id:Node<Name>) ctx : Node<_> = \r\n  let parsed = \r\n    // Token is correctly nested - parse '.' or '('\r\n    match nestedToken ctx with\r\n    | Some(white, res) -> parseDotOrLParen optInst (whiteAfter white id) ctx res\r\n    | _ ->\r\n    // Token is not nested, but it is '.' or '(', so we accept it with erorr\r\n    let white, after = token ctx    \r\n    match (use _silent = usingSilentMode ctx in parseDotOrLParen optInst (whiteAfter white id) ctx after) with\r\n    | Some res -> \r\n        Errors.Parser.unindentedDotAfterIdentifier id.Range after.Range |> addError ctx \r\n        Some res \r\n    // Otherwise, we end the call chain\r\n    | _ -> None\r\n  match parsed with\r\n  | Some res -> res\r\n  | None -> \r\n      // If we did not parse anything, create chain with what we have\r\n      match optInst with\r\n      | Some inst -> node (unionRanges inst.Range id.Range) (Expr.Property(inst, id))\r\n      | None -> node id.Range (Expr.Variable(id))\r\n\r\n\r\n/// We already parsed `fun`, parse the rest of the function, i.e. `<id> -> <expr>`\r\nand parseFunction ctx funRng = \r\n  match nestedToken ctx with\r\n  | Some(Identifier id) ->\r\n      next ctx\r\n      match nestedToken ctx with\r\n      | Some(whiteAfterId, { Token = TokenKind.Arrow; Range = rngEq }) ->\r\n          next ctx\r\n          let body = \r\n            match parseExpression [] ctx with\r\n            | Some body -> body\r\n            | _ -> \r\n                Errors.Parser.missingBodyOfFunc (unionRanges funRng rngEq) |> addError ctx\r\n                node { Start = rngEq.End; End = rngEq.End } Expr.Empty\r\n          let rng = unionRanges funRng body.Range\r\n          node rng (Expr.Function(whiteAfter whiteAfterId id, body)) |> Some\r\n      | nt ->\r\n          // Missing arrow - try parsing the body anyway\r\n          let errRng, whiteAfterId = \r\n            match nt with\r\n            | None -> unionRanges funRng id.Range, []\r\n            | Some(whiteAfterId, t) -> t.Range, whiteAfterId\r\n          Errors.Parser.missingArrowInFunc errRng |> addError ctx\r\n          let body = \r\n            match parseExpression [] ctx with \r\n            | Some e -> e \r\n            | _ -> node {Start=id.Range.End; End=id.Range.End} Expr.Empty\r\n          node (unionRanges funRng body.Range) (Expr.Function(id, whiteBefore whiteAfterId body)) |> Some            \r\n\r\n  // Unexpected token or end of scope - return empty function\r\n  | Some(white, t) ->\r\n      Errors.Parser.unexpectedTokenAfterFun t.Range t.Token |> addError ctx\r\n      let rng = { Start = funRng.End; End = funRng.End }\r\n      node rng (Expr.Function(node rng {Name=\"\"}, node rng Expr.Empty)) |> whiteBefore white |> Some\r\n  | None ->\r\n      Errors.Parser.unexpectedScopeEndInFunc funRng |> addError ctx\r\n      let rng = { Start = funRng.End; End = funRng.End }\r\n      node rng (Expr.Function(node rng {Name=\"\"}, node rng Expr.Empty)) |> Some\r\n  \r\n    \r\n/// A term is a single thing inside expression involving operators, i.e.\r\n///   <expression> := <term> <op> <term> <op> .. <op> <term>\r\nand parseTerm ctx = \r\n  match nestedToken ctx with\r\n  // Variable or call chain\r\n  | Some((Identifier id) & (_, tok)) ->\r\n      next ctx\r\n      use _indent = usingIndent false tok ctx\r\n      let varOrCall = parseMember None id ctx \r\n      Some varOrCall\r\n\r\n  // String, numeric and Boolean literals\r\n  | Some(white, { Token = TokenKind.Number(_, n); Range = r }) ->\r\n      next ctx\r\n      node r (Expr.Number n) |> whiteAfter white |> Some\r\n  | Some(white, { Token = TokenKind.String(s); Range = r }) ->\r\n      next ctx\r\n      node r (Expr.String s) |> whiteAfter white |> Some\r\n  | Some(white, { Token = TokenKind.Boolean(b); Range = r }) ->\r\n      next ctx\r\n      node r (Expr.Boolean b) |> whiteAfter white |> Some\r\n\r\n  // Parse nested expressions starting with `(` or list starting with `[`\r\n  | Some(white, ({ Token = TokenKind.LParen } as t)) ->\r\n      next ctx\r\n      parseParenTermEnd (t::List.rev white) [] (parseExpression [] ctx) ctx\r\n  | Some(white, ({ Token = TokenKind.LSquare } as t)) ->\r\n      next ctx\r\n      use _nest = usingNonTopLevel ctx\r\n      parseListElements false t.Range white t.Range [] ctx\r\n\r\n  | Some(white, ({ Token = TokenKind.Fun } as t)) ->\r\n      next ctx\r\n      parseFunction ctx t.Range\r\n\r\n  // Not a term, but that's fine\r\n  | _ -> None \r\n\r\n\r\n/// Parse list of elements and closing square bracket, after `[`\r\nand parseListElements expectMore lastRng whiteStart startRng acc ctx =\r\n  let parsed, acc =  \r\n    match parseExpression [] ctx with\r\n    | Some expr -> true, fun white -> (whiteAfter white expr)::acc\r\n    | _ -> false, fun _ -> acc\r\n\r\n  match nestedToken ctx with\r\n  | Some(white, { Token = TokenKind.RSquare; Range = endRng }) ->\r\n      next ctx\r\n      node (unionRanges startRng endRng) (Expr.List(List.rev (acc []))) |> whiteBefore white |> Some\r\n  | Some(white, { Token = TokenKind.Comma; Range = lastRng }) ->\r\n      next ctx\r\n      if not parsed && expectMore then\r\n        Errors.Parser.unexpectedTokenInList lastRng TokenKind.Comma |> addError ctx\r\n      parseListElements true lastRng whiteStart startRng (acc white) ctx\r\n  | Some(_, t) when t.Token <> TokenKind.EndOfFile ->\r\n      // Skip over unexpected, but correctly nested tokens\r\n      next ctx\r\n      Errors.Parser.unexpectedTokenInList t.Range t.Token |> addError ctx\r\n      parseListElements expectMore t.Range whiteStart startRng (acc []) ctx\r\n  | _ ->\r\n      // Unexpected end of nesting - end argument list now\r\n      Errors.Parser.unexpectedScopeEndInList lastRng |> addError ctx\r\n      node (unionRanges startRng lastRng) (Expr.List(List.rev (acc []))) |> Some\r\n\r\n\r\n/// Parse what follows after `(<expr>` - either `)` or some errors \r\nand parseParenTermEnd wb wa bodyOpt ctx =  \r\n  // Create parenthesized expression body, or return empty expression if missing\r\n  let makeBody wa =\r\n    let body = \r\n      match bodyOpt with\r\n      | Some body -> body\r\n      | None -> \r\n          let rng = List.append [List.head wb] wa |> List.map (fun t -> t.Range) |> List.reduce unionRanges\r\n          Errors.Parser.missingParenthesizedExpr rng |> addError ctx\r\n          node rng Expr.Empty\r\n    Some(body |> whiteBefore (List.rev wb) |> whiteAfter (List.rev wa))\r\n\r\n  // Wait for ')', ignoring other nested tokens & ending on end of nesting\r\n  match nestedToken ctx with\r\n  | Some(white, ({ Token = TokenKind.RParen } as t)) -> \r\n      next ctx\r\n      makeBody (t::(List.append (List.rev white) wa))\r\n  | Some(white, t) -> \r\n      next ctx\r\n      Errors.Parser.unexpectedTokenInParenthesizedExpr t.Range t.Token |> addError ctx\r\n      parseParenTermEnd wb (t::(List.append (List.rev white) wa)) bodyOpt ctx\r\n  | None ->\r\n      let rng = match bodyOpt with Some b -> b.Range | _ -> (List.head wb).Range\r\n      Errors.Parser.unindentedTokenInParenthesizedExpr rng |> addError ctx\r\n      makeBody wa\r\n            \r\n\r\n/// Parse expression consisting of multiple terms & operators\r\nand parseExpression terms ctx = \r\n  match terms, parseTerm ctx with\r\n  | terms, Some term -> \r\n      match nestedToken ctx with\r\n      // Followed by operator and more expressions\r\n      | Some(white, ({ Token = TokenKind.Equals } as t)) ->\r\n          next ctx\r\n          parseExpression ((term, whiteBefore white (node t.Range Operator.Equals))::terms) ctx\r\n      | Some(white, ({ Token = TokenKind.Operator op } as t)) ->\r\n          next ctx\r\n          parseExpression ((term, whiteBefore white (node t.Range op))::terms) ctx\r\n      | _ -> \r\n          Some(buildExpression terms term)  \r\n  // Not an expression, return None\r\n  | [], None -> None  \r\n  // Nothing after operator - ignore operator, but parse preceding terms\r\n  | (term, op)::terms, None -> \r\n      let next = justToken ctx\r\n      Errors.Parser.unexpectedTokenAfterOperator next.Range (TokenKind.Operator op.Node) next.Token |> addError ctx\r\n      Some(buildExpression terms term)\r\n\r\n\r\n/// Try parsing input as '<id> = <expr>', if that does not work, treat it as <expr>\r\nand parseExpressionOrNamedParam ctx = \r\n  let lookAheadCtx = clone ctx\r\n  match nestedToken lookAheadCtx with\r\n  | Some(Identifier id) ->\r\n      next lookAheadCtx\r\n      match nestedToken lookAheadCtx with\r\n      | Some(white, ({ Token = TokenKind.Equals } as t)) ->\r\n          // Replay what we did on lookahead context on the original context\r\n          ignore (nestedToken ctx); next ctx\r\n          ignore (nestedToken ctx); next ctx\r\n          match parseExpression [] ctx with\r\n          | Some expr -> Choice1Of2(whiteAfter white id, expr)\r\n          | None -> \r\n              Errors.Parser.unexpectedTokenInArgList t.Range t.Token |> addError ctx\r\n              Choice2Of2(Some(node id.Range (Expr.Variable(id))))\r\n      | _ -> Choice2Of2(parseExpression [] ctx)\r\n  | _ -> \r\n      Choice2Of2(parseExpression [] ctx)\r\n    \r\n\r\n/// Parse a comma separated list of expressions or named parameter assignments\r\nand parseCallArgList expectMore lastRng acc ctx = \r\n  let parsed, acc = \r\n    match parseExpressionOrNamedParam ctx with\r\n    | Choice2Of2(None) -> false, acc\r\n    | Choice2Of2(Some e) -> true, { Name = None; Value = e }::acc\r\n    | Choice1Of2(id, e) -> true, { Name = Some id; Value = e }::acc\r\n  match nestedToken ctx with\r\n  | Some(white, ({ Token = TokenKind.RParen } as t)) ->\r\n      next ctx\r\n      if expectMore && not parsed then        \r\n        Errors.Parser.unexpectedTokenInArgList lastRng TokenKind.RParen |> addError ctx\r\n      t.Range, white, List.rev acc\r\n\r\n  | Some(white, { Token = TokenKind.Comma; Range = lastRng }) when parsed ->\r\n      next ctx\r\n      parseCallArgList true lastRng acc ctx\r\n\r\n  | Some(_, t) when t.Token <> TokenKind.EndOfFile ->\r\n      // Skip over unexpected, but correctly nested tokens\r\n      next ctx\r\n      Errors.Parser.unexpectedTokenInArgList t.Range t.Token |> addError ctx\r\n      parseCallArgList expectMore t.Range acc ctx\r\n  | _ ->\r\n      // Unexpected end of nesting - end argument list now\r\n      Errors.Parser.unexpectedScopeEndInArgList lastRng |> addError ctx\r\n      lastRng, [], List.rev acc\r\n\r\n\r\n/// Parse a top-level expression, \r\nlet rec parseNestedExpressions wacc acc ctx = \r\n  match parseExpression [] ctx with\r\n  | Some expr ->  \r\n      if not (List.isEmpty acc) then \r\n        Errors.Parser.nestedExpressionInCommand expr.Range |> addError ctx\r\n        parseNestedExpressions [] ((whiteBefore (List.rev wacc) expr)::acc) ctx\r\n      else\r\n        use _strict = usingTopLevelNesting ctx\r\n        parseNestedExpressions [] ((whiteBefore (List.rev wacc) expr)::acc) ctx\r\n  | _ ->\r\n  match nestedToken ctx with\r\n  | Some(_, { Token = TokenKind.EndOfFile })\r\n  | None ->\r\n      match acc with\r\n      | x::xs -> (whiteAfter (List.rev wacc) x)::xs\r\n      | [] -> []\r\n  | Some(white, tok) ->\r\n      next ctx\r\n      parseNestedExpressions (tok::(List.rev white) @ wacc) acc ctx\r\n\r\n\r\n/// Parse the rest of the let binding after `let`, handling all sorts of errors\r\n/// This returns parsed command together with all nested expressions after the command\r\n/// (those should not be nested, but we accept them anyway & report error)\r\nlet parseLetBinding whiteBeforeLet rngLet ctx = \r\n  match nestedToken ctx with\r\n  | Some(Identifier id) ->\r\n      next ctx\r\n      match nestedToken ctx with\r\n      | Some (whiteAfterId, { Token = TokenKind.Equals; Range = rngEq }) ->\r\n          next ctx\r\n          match List.rev (parseNestedExpressions [] [] ctx) with\r\n          | body::rest ->\r\n              rest, \r\n              Command.Let(whiteAfter whiteAfterId id, body)\r\n              |> node (unionRanges rngLet body.Range) \r\n              |> whiteBefore whiteBeforeLet\r\n              \r\n          | [] ->\r\n              // Missing body - return let binding with empty expression\r\n              Errors.Parser.missingBodyInLetBinding (unionRanges rngLet rngEq) |> addError ctx\r\n              [],\r\n              Command.Let(whiteAfter whiteAfterId id, node { Start = rngEq.End; End = rngEq.End } Expr.Empty)\r\n              |> node (unionRanges rngLet rngEq) \r\n              |> whiteBefore whiteBeforeLet\r\n              \r\n      | Some (whiteAfterId, t) ->\r\n          // Unexpected token after ident - try to parse nested body as expression nevertheless\r\n          Errors.Parser.unexpectedTokenInLetBinding t.Range t.Token |> addError ctx\r\n          let body, rest = \r\n            match List.rev (parseNestedExpressions [] [] ctx) with\r\n            | body::rest -> body, rest\r\n            | [] -> node { Start = id.Range.End; End = id.Range.End } Expr.Empty, []\r\n          rest,\r\n          Command.Let(whiteAfter whiteAfterId id, body)\r\n          |> node (unionRanges rngLet id.Range) \r\n          |> whiteBefore whiteBeforeLet\r\n          \r\n      | None ->\r\n          // End of block after ident - return binding with empty expression\r\n          Errors.Parser.missingBodyInLetBinding id.Range |> addError ctx\r\n          let body = node { Start = id.Range.End; End = id.Range.End } Expr.Empty\r\n          [], node (unionRanges rngLet id.Range) (Command.Let(id, body)) |> whiteBefore whiteBeforeLet\r\n          \r\n  | Some(whiteAfterLet, t) ->\r\n      // Unexpected token after let - try to parse nested body as expression & assume emtpy identifier\r\n      //printfn \"Unexpected token after let: %A\" t\r\n      Errors.Parser.unexpectedTokenInLetBinding t.Range t.Token |> addError ctx\r\n      let letEndRng = { Start = rngLet.End; End = rngLet.End }\r\n      let body, rest = \r\n        match List.rev (parseNestedExpressions [] [] ctx) with\r\n        | body::rest -> body, rest\r\n        | [] -> node letEndRng Expr.Empty, []\r\n      rest,\r\n      Command.Let(whiteBefore whiteAfterLet (node letEndRng { Name = \"\" } ), body)\r\n      |> node (unionRanges rngLet body.Range) \r\n      |> whiteBefore whiteBeforeLet\r\n      \r\n  | None ->\r\n      // Missing body - return let binding with empty expression and empty identifier\r\n      Errors.Parser.missingBodyInLetBinding rngLet |> addError ctx\r\n      let rng = { Start = rngLet.End; End = rngLet.End }\r\n      [], node rng (Command.Let(node rng { Name = \"\" }, node rng Expr.Empty)) |> whiteBefore whiteBeforeLet\r\n\r\n      \r\n/// A command is either top-level expression or let binding\r\nlet rec parseCommands acc ctx = \r\n  let c = token ctx\r\n  match c with\r\n  | whiteBeforeLet, ({ Token = TokenKind.Let; Range = rngLet } as tok) ->\r\n      next ctx\r\n      let rest, parsed = \r\n        use _indent = usingIndent false tok ctx\r\n        parseLetBinding whiteBeforeLet rngLet ctx\r\n      let rest = rest |> List.map (fun e -> node e.Range (Command.Expr e))\r\n      parseCommands (rest @ (parsed::acc)) ctx\r\n\r\n  | white, { Token = TokenKind.EndOfFile } ->\r\n      // Return commands & store the whitespace\r\n      match acc with \r\n      | x::xs -> List.rev ({ x with WhiteAfter = white }::xs)\r\n      | [] -> []\r\n    \r\n  | white, tok -> \r\n      // Treat command as top-level expression\r\n      let cmds = \r\n        use _indent = usingIndent true tok ctx\r\n        parseNestedExpressions (List.rev white) [] ctx |> List.map (fun expr ->\r\n          node expr.Range (Command.Expr expr))\r\n      parseCommands (cmds @ acc) ctx\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// User friendly entry point\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nlet parseProgram (input:string) = \r\n  try\r\n    let tokens, errors = Tokenizer.tokenize input\r\n    let ctx = \r\n      { Tokens = tokens\r\n        TopLevel = true; Silent = false; StrictlyNested = false\r\n        Position = 0; IndentCurrent = 0; IndentStack = []\r\n        Errors = ResizeArray<_>(); Whitespace = ResizeArray<_>() }\r\n    let cmds = parseCommands [] ctx\r\n    let errors = Array.append errors (ctx.Errors.ToArray())\r\n    let rng = cmds |> List.fold (fun rng cmd -> unionRanges rng cmd.Range) { Start = 0; End = 0 }\r\n    { Body = node rng cmds }, errors\r\n  with e ->\r\n    Log.exn(\"parsing\", \"Exception while parsing program: %O\", e)\r\n    let rng = { Start=0; End=0 }\r\n    let error = Errors.Parser.exceptionWhileParsing rng (e.ToString())\r\n    { Body = node rng [] }, [| error |]\r\n"]}