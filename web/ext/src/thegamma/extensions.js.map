{"version":3,"sources":["../../../src/thegamma/extensions.fs"],"names":[],"mappings":"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","file":"extensions.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module Fable.Extensions\r\n\r\nopen Fable.Core\r\nopen Fable.Import.JS\r\nopen Fable.Import.Browser\r\n\r\n[<Emit(\"JSON.stringify($0)\")>]\r\nlet jsonStringify json : string = failwith \"JS Only\"\r\n\r\n[<Emit(\"JSON.parse($0)\")>]\r\nlet jsonParse<'R> (str:string) : 'R = failwith \"JS Only\"\r\n\r\n[<Emit(\"console.log.apply(console, $0)\")>]\r\nlet consoleLog (args:obj[]) : unit = failwith \"JS only\"\r\n\r\n[<Emit(\"logEvent($0, $1, $2, $3)\")>]\r\nlet logEvent (category:string) (evt:string) (article:string) (data:obj) : unit = failwith \"JS only\"\r\n\r\nlet isLocalHost() = \r\n  window.location.hostname = \"localhost\" || \r\n  window.location.hostname = \"127.0.0.1\"\r\n\r\nlet enabledCategories = \r\n  if not (isLocalHost ()) then set []\r\n  else set [ \"SYSTEM\"; \"COMPLETIONS\"; \"EDITORS\"; \"TYPECHECKER\"; \"SERVICE\"; \"CODEGEN\"; \"RUNTIME\" ]\r\n\r\ntype Log =\r\n  static member event(category:string, evt:string, article:string, data:obj) = \r\n    logEvent category evt article data\r\n\r\n  static member message(level:string, category:string, msg:string, [<System.ParamArray>] args) = \r\n    let args = if args = null then [| |] else args\r\n    let category = category.ToUpper()\r\n    if level = \"EXCEPTION\" then\r\n      logEvent \"system\" \"exception\" \"\" (JsInterop.createObj [\"category\", box category; \"msg\", box msg; \"args\", box args ])\r\n\r\n    if level = \"EXCEPTION\" || level = \"ERROR\" || enabledCategories.Contains category then\r\n      let dt = System.DateTime.Now\r\n      let p2 (s:int) = (string s).PadLeft(2, '0')\r\n      let p4 (s:int) = (string s).PadLeft(4, '0')\r\n      let prefix = sprintf \"[%s:%s:%s:%s] %s: \" (p2 dt.Hour) (p2 dt.Minute) (p2 dt.Second) (p4 dt.Millisecond) category\r\n      let color = \r\n        match level with\r\n        | \"TRACE\" -> \"color:#808080\"\r\n        | \"EXCEPTION\" -> \"color:#c00000\"\r\n        | \"ERROR\" -> \"color:#900000\"\r\n        | _ -> \"\"\r\n      consoleLog(FSharp.Collections.Array.append [|box (\"%c\" + prefix + msg); box color|] args)\r\n\r\n  static member trace(category:string, msg:string, [<System.ParamArray>] args) = \r\n    Log.message(\"TRACE\", category, msg, args)\r\n\r\n  static member exn(category:string, msg:string, [<System.ParamArray>] args) = \r\n    Log.message(\"EXCEPTION\", category, msg, args)\r\n\r\n  static member error(category:string, msg:string, [<System.ParamArray>] args) = \r\n    Log.message(\"ERROR\", category, msg, args)\r\n\r\ntype Http =\r\n  /// Send HTTP request asynchronously\r\n  /// (does not handle errors properly)\r\n  static member Request(meth, url, ?data, ?cookies) =\r\n    Async.FromContinuations(fun (cont, _, _) ->\r\n      let xhr = XMLHttpRequest.Create()\r\n      xhr.``open``(meth, url, true)\r\n      match cookies with \r\n      | Some cookies when cookies <> \"\" -> xhr.setRequestHeader(\"X-Cookie\", cookies)\r\n      | _ -> ()\r\n      xhr.onreadystatechange <- fun _ ->\r\n        if xhr.readyState > 3. && xhr.status = 200. then\r\n          cont(xhr.responseText)\r\n        obj()\r\n      xhr.send(defaultArg data \"\") )\r\n\r\ntype Future<'T> = \r\n  abstract Then : ('T -> unit) -> unit\r\n\r\ntype Microsoft.FSharp.Control.Async with\r\n  static member AwaitFuture (f:Future<'T>) = Async.FromContinuations(fun (cont, _, _) ->\r\n    f.Then(cont))\r\n\r\n  static member Future (n:string) op start = \r\n    let mutable res = Choice1Of3()\r\n    let mutable handlers = []\r\n    let mutable running = false\r\n\r\n    let trigger h = \r\n      match res with\r\n      | Choice1Of3 () -> handlers <- h::handlers \r\n      | Choice2Of3 v -> h v\r\n      | Choice3Of3 e -> raise e\r\n\r\n    let ensureStarted() = \r\n      if not running then \r\n        Log.trace(\"system\", \"Starting future '%s'....\", n)\r\n        running <- true\r\n        async { try \r\n                  let! r = op\r\n                  res <- Choice2Of3 r                  \r\n                with e ->\r\n                  Log.exn(\"system\", \"Evaluating future failed: %O\", e)\r\n                  res <- Choice3Of3 e\r\n                for h in handlers do trigger h } |> Async.StartImmediate\r\n    if start = true then ensureStarted()\r\n\r\n    { new Future<_> with\r\n        member x.Then(f) = \r\n          ensureStarted()\r\n          trigger f }\r\n\r\n  static member AsFuture n op = Async.Future n op false\r\n  static member StartAsFuture n op = Async.Future n op true\r\n\r\nmodule Async = \r\n  module Array =\r\n    module Parallel =\r\n      let rec map f (ar:_[]) = async {\r\n        let res = FSharp.Collections.Array.zeroCreate ar.Length\r\n        let work = \r\n          [ for i in 0 .. ar.Length-1 -> async {\r\n              let! v = f ar.[i]\r\n              res.[i] <- v } ] |> Async.Parallel\r\n        let! _ = work\r\n        return res }\r\n\r\n    let rec map f (ar:_[]) = async {\r\n      let res = FSharp.Collections.Array.zeroCreate ar.Length\r\n      for i in 0 .. ar.Length-1 do\r\n        let! v = f ar.[i]\r\n        res.[i] <- v\r\n      return res }\r\n\r\n  let rec collect f l = async {\r\n    match l with \r\n    | x::xs -> \r\n        let! y = f x\r\n        let! ys = collect f xs\r\n        return List.append y ys\r\n    | [] -> return [] }\r\n\r\n  let rec choose f l = async {\r\n    match l with \r\n    | x::xs -> \r\n        let! y = f x\r\n        let! ys = choose f xs\r\n        return match y with None -> ys | Some y -> y::ys \r\n    | [] -> return [] }\r\n\r\n  let rec map f l = async {\r\n    match l with \r\n    | x::xs -> \r\n        let! y = f x\r\n        let! ys = map f xs\r\n        return y::ys\r\n    | [] -> return [] }\r\n\r\n  let rec foldMap f st l = async {\r\n    match l with\r\n    | x::xs ->\r\n        let! y, st = f st x\r\n        let! st, ys = foldMap f st xs\r\n        return st, y::ys\r\n    | [] -> return st, [] }\r\n\r\n  let rec fold f st l = async {\r\n    match l with\r\n    | x::xs ->\r\n        let! st = f st x\r\n        return! fold f st xs \r\n    | [] -> return st }\r\n\r\n"]}