{"version":3,"sources":["../../../../src/thegamma/common/common.fs"],"names":[],"mappings":"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","file":"common.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Common\r\n\r\nopen Fable.Core\r\nopen Fable.Import.JS\r\nopen Fable.Import.Browser\r\nopen System.Collections.Generic\r\n\r\n[<Emit(\"JSON.stringify($0)\")>]\r\nlet jsonStringify json : string = failwith \"JS Only\"\r\n\r\n[<Emit(\"JSON.parse($0)\")>]\r\nlet jsonParse<'R> (str:string) : 'R = failwith \"JS Only\"\r\n\r\n[<Emit(\"console.log.apply(console, $0)\")>]\r\nlet consoleLog (args:obj[]) : unit = \r\n  let format = args.[0] :?> string\r\n  let mutable argIndex = 1\r\n  let mutable charIndex = 0\r\n  let mutable res = \"\"\r\n  while charIndex < format.Length do\r\n    if format.[charIndex] = '%' then\r\n      res <- res +\r\n        match format.[charIndex+1] with\r\n        | 'c' -> \"\"\r\n        | 's' -> args.[argIndex].ToString()\r\n        | 'O' -> sprintf \"%A\" (args.[argIndex])\r\n        | _ -> failwith \"consoleLog: Unsupported formatter\"\r\n      argIndex <- argIndex + 1\r\n      charIndex <- charIndex + 2\r\n    else \r\n      res <- res + format.[charIndex].ToString()\r\n      charIndex <- charIndex + 1\r\n  printfn \"%s\" res\r\n\r\n[<Emit(\"logEvent($0, $1, $2, $3)\")>]\r\nlet logEvent (category:string) (evt:string) (article:string) (data:obj) : unit = failwith \"JS only\"\r\n\r\n[<Emit(\"typeof window == 'undefined'\")>]\r\nlet windowUndefined () : bool = true\r\n\r\nlet isLocalHost() = \r\n  windowUndefined () ||\r\n  window.location.hostname = \"localhost\" || \r\n  window.location.hostname = \"127.0.0.1\"\r\n\r\nlet mutable enabledCategories = \r\n  if not (isLocalHost ()) then set []\r\n  //else set [ \"SYSTEM\"; \"PARSING\";(*\"BINDER\"; *)\"COMPLETIONS\"; \"EDITORS\"; \"TYPECHECKER\"; \"PROVIDERS\"; \"SERVICE\"; \"CODEGEN\"; \"INTERPRETER\"; \"RUNTIME\" ]\r\n  else set [\"INTERPRETER\"]\r\ntype Log =\r\n  static member setEnabled(cats) = enabledCategories <- cats\r\n\r\n  static member event(category:string, evt:string, article:string, data:obj) = \r\n    logEvent category evt article data\r\n\r\n  static member message(level:string, category:string, msg:string, [<System.ParamArray>] args) = \r\n    let args = if args = null then [| |] else args\r\n    let category = category.ToUpper()\r\n    if not (isLocalHost ()) && level = \"EXCEPTION\" then\r\n      logEvent \"system\" \"exception\" \"\" (JsInterop.createObj [\"category\", box category; \"msg\", box msg; \"args\", box args ])\r\n\r\n    if level = \"EXCEPTION\" || level = \"ERROR\" || enabledCategories.Contains category then\r\n      let dt = System.DateTime.Now\r\n      let p2 (s:int) = (string s).PadLeft(2, '0')\r\n      let p4 (s:int) = (string s).PadLeft(4, '0')\r\n      let prefix = sprintf \"[%s:%s:%s:%s] %s: \" (p2 dt.Hour) (p2 dt.Minute) (p2 dt.Second) (p4 dt.Millisecond) category\r\n      let color = \r\n        match level with\r\n        | \"TRACE\" -> \"color:#808080\"\r\n        | \"EXCEPTION\" -> \"color:#c00000\"\r\n        | \"ERROR\" -> \"color:#900000\"\r\n        | _ -> \"\"\r\n      consoleLog(FSharp.Collections.Array.append [|box (\"%c\" + prefix + msg); box color|] args)\r\n\r\n  static member trace(category:string, msg:string, [<System.ParamArray>] args) = \r\n    Log.message(\"TRACE\", category, msg, args)\r\n\r\n  static member exn(category:string, msg:string, [<System.ParamArray>] args) = \r\n    Log.message(\"EXCEPTION\", category, msg, args)\r\n\r\n  static member error(category:string, msg:string, [<System.ParamArray>] args) = \r\n    Log.message(\"ERROR\", category, msg, args)\r\n\r\ntype Http =\r\n  /// Send HTTP request asynchronously\r\n  /// (does not handle errors properly)\r\n  static member Request(meth, url, ?data, ?cookies) =\r\n    Async.FromContinuations(fun (cont, _, _) ->\r\n      let xhr = XMLHttpRequest.Create()\r\n      xhr.``open``(meth, url, true)\r\n      match cookies with \r\n      | Some cookies when cookies <> \"\" -> xhr.setRequestHeader(\"X-Cookie\", cookies)\r\n      | _ -> ()\r\n      xhr.onreadystatechange <- fun _ ->\r\n        if xhr.readyState > 3. && xhr.status = 200. then\r\n          cont(xhr.responseText)\r\n        obj()\r\n      xhr.send(defaultArg data \"\") )\r\n\r\ntype Future<'T> = \r\n  abstract Then : ('T -> unit) -> unit\r\n\r\ntype Microsoft.FSharp.Control.Async with\r\n  static member AwaitFuture (f:Future<'T>) = Async.FromContinuations(fun (cont, _, _) ->\r\n    f.Then(cont))\r\n\r\n  static member Future (n:string) op start = \r\n    let mutable res = Choice1Of3()\r\n    let mutable handlers = []\r\n    let mutable running = false\r\n\r\n    let trigger h = \r\n      match res with\r\n      | Choice1Of3 () -> handlers <- h::handlers \r\n      | Choice2Of3 v -> h v\r\n      | Choice3Of3 e -> raise e\r\n\r\n    let ensureStarted() = \r\n      if not running then \r\n        Log.trace(\"system\", \"Starting future '%s'....\", n)\r\n        running <- true\r\n        async { try \r\n                  let! r = op\r\n                  Log.trace(\"system\", \"Future '%s' evaluated to: %O\", n, r)\r\n                  res <- Choice2Of3 r                  \r\n                with e ->\r\n                  Log.exn(\"system\", \"Evaluating future failed: %O\", e)\r\n                  res <- Choice3Of3 e\r\n                for h in handlers do trigger h } |> Async.StartImmediate\r\n    if start = true then ensureStarted()\r\n\r\n    { new Future<_> with\r\n        member x.Then(f) = \r\n          ensureStarted()\r\n          trigger f }\r\n\r\n  static member AsFuture n op = Async.Future n op false\r\n  static member StartAsFuture n op = Async.Future n op true\r\n\r\nmodule Async = \r\n  module Array =\r\n    module Parallel =\r\n      let rec map f (ar:_[]) = async {\r\n        let res = FSharp.Collections.Array.zeroCreate ar.Length\r\n        let work = \r\n          [ for i in 0 .. ar.Length-1 -> async {\r\n              let! v = f ar.[i]\r\n              res.[i] <- v } ] |> Async.Parallel\r\n        let! _ = work\r\n        return res }\r\n\r\n    let rec map f (ar:_[]) = async {\r\n      let res = FSharp.Collections.Array.zeroCreate ar.Length\r\n      for i in 0 .. ar.Length-1 do\r\n        let! v = f ar.[i]\r\n        res.[i] <- v\r\n      return res }\r\n\r\n  let rec collect f l = async {\r\n    match l with \r\n    | x::xs -> \r\n        let! y = f x\r\n        let! ys = collect f xs\r\n        return List.append y ys\r\n    | [] -> return [] }\r\n\r\n  let rec choose f l = async {\r\n    match l with \r\n    | x::xs -> \r\n        let! y = f x\r\n        let! ys = choose f xs\r\n        return match y with None -> ys | Some y -> y::ys \r\n    | [] -> return [] }\r\n\r\n  let rec map f l = async {\r\n    match l with \r\n    | x::xs -> \r\n        let! y = f x\r\n        let! ys = map f xs\r\n        return y::ys\r\n    | [] -> return [] }\r\n\r\n  let rec foldMap f st l = async {\r\n    match l with\r\n    | x::xs ->\r\n        let! y, st = f st x\r\n        let! st, ys = foldMap f st xs\r\n        return st, y::ys\r\n    | [] -> return st, [] }\r\n\r\n  let rec fold f st l = async {\r\n    match l with\r\n    | x::xs ->\r\n        let! st = f st x\r\n        return! fold f st xs \r\n    | [] -> return st }\r\n\r\n/// Symbol is a unique immutable identiifer (we use JavaScript symbols)\r\ntype Symbol = interface end\r\n\r\n[<Emit(\"Symbol()\")>]\r\nlet createSymbol () = { new Symbol }\r\n\r\ntype ListDictionaryNode<'K, 'T> = \r\n  { mutable Result : 'T option\r\n    Nested : Dictionary<'K, ListDictionaryNode<'K, 'T>> }\r\n\r\ntype ListDictionary<'K, 'V> = Dictionary<'K, ListDictionaryNode<'K, 'V>>\r\n\r\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\r\nmodule ListDictionary = \r\n  let tryFind ks dict = \r\n    let rec loop ks node =\r\n      match ks, node with\r\n      | [], { Result = Some r } -> Some r\r\n      | k::ks, { Nested = d } when d.ContainsKey k -> loop ks (d.[k])\r\n      | _ -> None\r\n    loop ks { Nested = dict; Result = None }\r\n\r\n  let set ks v dict =\r\n    let rec loop ks (dict:ListDictionary<_, _>) = \r\n      match ks with\r\n      | [] -> failwith \"Empty key not supported\"\r\n      | k::ks ->\r\n          if not (dict.ContainsKey k) then dict.[k] <- { Nested = Dictionary<_, _>(); Result = None }\r\n          if List.isEmpty ks then dict.[k].Result <- Some v\r\n          else loop ks (dict.[k].Nested)\r\n    loop ks dict\r\n\r\n  let count (dict:ListDictionary<_, _>) = \r\n    let rec loop node = \r\n      let nest = node.Nested |> Seq.sumBy (fun kv -> loop kv.Value)\r\n      if node.Result.IsSome then 1 + nest else nest\r\n    dict |> Seq.sumBy (fun kv -> loop kv.Value)\r\n\r\nmodule List = \r\n  let groupWith f list = \r\n    let groups = ResizeArray<_ * ResizeArray<_>>()\r\n    for e in list do\r\n      let mutable added = false \r\n      let mutable i = 0\r\n      while not added && i < groups.Count do\r\n        if f e (fst groups.[i]) then \r\n          (snd groups.[i]).Add(e)\r\n          added <- true\r\n        i <- i + 1\r\n      if not added then \r\n        groups.Add(e, ResizeArray<_>([e]))\r\n    groups |> Seq.map (snd >> List.ofSeq) |> List.ofSeq\r\n\r\n  let unreduce f s = s |> Seq.unfold (fun s -> \r\n    f s |> Microsoft.FSharp.Core.Option.map (fun v -> v, v)) |> List.ofSeq\r\n"]}