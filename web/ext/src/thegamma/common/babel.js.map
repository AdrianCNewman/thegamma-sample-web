{"version":3,"sources":["../../../../src/thegamma/common/babel.fs"],"names":[],"mappings":"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","file":"babel.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿namespace TheGamma.Babel\r\n\r\nopen Fable\r\nopen Fable.Core\r\n\r\n/// Each Position object consists of a line number (1-indexed) and a column number (0-indexed):\r\ntype Position =\r\n  { line: int; column: int; }\r\n\r\ntype SourceLocation =\r\n  { start: Position; ``end``: Position; }\r\n\r\ntype AssignmentOperator =\r\n  | AssignEqual\r\n  | AssignMinus\r\n  | AssignPlus\r\n  | AssignMultiply\r\n  | AssignDivide\r\n  | AssignModulus\r\n  | AssignShiftLeft\r\n  | AssignShiftRightSignPropagating\r\n  | AssignShiftRightZeroFill\r\n  | AssignOrBitwise\r\n  | AssignXorBitwise\r\n  | AssignAndBitwise    \r\n\r\ntype BinaryOperator =\r\n  | BinaryEqual\r\n  | BinaryUnequal\r\n  | BinaryEqualStrict\r\n  | BinaryUnequalStrict\r\n  | BinaryLess\r\n  | BinaryLessOrEqual\r\n  | BinaryGreater\r\n  | BinaryGreaterOrEqual\r\n  | BinaryShiftLeft\r\n  | BinaryShiftRightSignPropagating\r\n  | BinaryShiftRightZeroFill\r\n  | BinaryMinus\r\n  | BinaryPlus\r\n  | BinaryMultiply\r\n  | BinaryDivide\r\n  | BinaryModulus\r\n  | BinaryExponent\r\n  | BinaryOrBitwise\r\n  | BinaryXorBitwise\r\n  | BinaryAndBitwise\r\n  | BinaryIn\r\n  | BinaryInstanceOf\r\n\r\ntype Pattern = \r\n  | IdentifierPattern of name:string * location:SourceLocation option\r\n\r\ntype VariableDeclarationKind = \r\n  | Var | Let | Const\r\n\r\ntype VariableDeclarator = \r\n  | VariableDeclarator of id:Pattern * init:Expression option * location:SourceLocation option\r\n\r\nand Expression = \r\n  | IdentifierExpression of name:string * location:SourceLocation option\r\n  | FunctionExpression of id:string option * ``params``:Pattern list * body:Statement * generator:bool * async:bool * location:SourceLocation option\r\n  | NullLiteral of location:SourceLocation option\r\n  | StringLiteral of value:string * location:SourceLocation option\r\n  | BooleanLiteral of value:bool * location:SourceLocation option\r\n  | NumericLiteral of value:float * location:SourceLocation option\r\n  | AssignmentExpression of operator:AssignmentOperator * left:Expression * right:Expression * location:SourceLocation option\r\n  | CallExpression of callee:Expression * args:Expression list * location:SourceLocation option\r\n  | ArrayExpression of elements:Expression list * location:SourceLocation option\r\n  | MemberExpression of obj:Expression * property:Expression * computed:bool * location:SourceLocation option\r\n  | NewExpression of callee:Expression * arguments:Expression list * location:SourceLocation option\r\n  | BinaryExpression of operator:BinaryOperator * left:Expression * right:Expression * location:SourceLocation option\r\n\r\nand Statement =\r\n  | ExpressionStatement of expression:Expression * location:SourceLocation option\r\n  | BlockStatement of body:Statement list * location:SourceLocation option\r\n  | EmptyStatement of location:SourceLocation option\r\n  | ReturnStatement of argument:Expression * location:SourceLocation option\r\n  | VariableDeclaration of kind:VariableDeclarationKind * declarations:VariableDeclarator list * location:SourceLocation option\r\n\r\ntype Program = \r\n  { location : SourceLocation option\r\n    body: Statement list }\r\n\r\nmodule Serializer = \r\n  let createObj props = JsInterop.createObj (List.concat props)\r\n  let inline (=>) k v = [ k, box v ]\r\n  let inline (=?>) k v = match v with Some v -> [ k, box v] | _ -> []\r\n\r\n  let serializeBinaryOperator = function\r\n    | BinaryEqual -> \"==\"\r\n    | BinaryUnequal -> \"!=\"\r\n    | BinaryEqualStrict -> \"===\"\r\n    | BinaryUnequalStrict -> \"!==\"\r\n    | BinaryLess -> \"<\"\r\n    | BinaryLessOrEqual -> \"<=\"\r\n    | BinaryGreater -> \">\"\r\n    | BinaryGreaterOrEqual -> \">=\"\r\n    | BinaryShiftLeft -> \"<<\"\r\n    | BinaryShiftRightSignPropagating -> \">>\"\r\n    | BinaryShiftRightZeroFill -> \">>>\"\r\n    | BinaryMinus -> \"-\"\r\n    | BinaryPlus -> \"+\"\r\n    | BinaryMultiply -> \"*\"\r\n    | BinaryDivide -> \"/\"\r\n    | BinaryModulus -> \"%\"\r\n    | BinaryExponent -> \"**\"\r\n    | BinaryOrBitwise -> \"|\"\r\n    | BinaryXorBitwise -> \"^\"\r\n    | BinaryAndBitwise -> \"&\"\r\n    | BinaryIn -> \"in\"\r\n    | BinaryInstanceOf -> \"instanceof\"\r\n\r\n  let serializeAssignOperator = function\r\n    | AssignEqual -> \"=\"\r\n    | AssignMinus -> \"-=\"\r\n    | AssignPlus -> \"+=\"\r\n    | AssignMultiply -> \"*=\"\r\n    | AssignDivide -> \"/=\"\r\n    | AssignModulus -> \"%=\"\r\n    | AssignShiftLeft -> \"<<=\"\r\n    | AssignShiftRightSignPropagating -> \">>=\"\r\n    | AssignShiftRightZeroFill -> \">>>=\"\r\n    | AssignOrBitwise -> \"|=\"\r\n    | AssignXorBitwise -> \"^=\"\r\n    | AssignAndBitwise -> \"&=\"\r\n\r\n  let serializePattern pat = \r\n    match pat with\r\n    | IdentifierPattern(name, loc) ->\r\n        createObj [ \"type\" => \"Identifier\"; \"name\" => name; \"loc\" =?> loc ]\r\n\r\n  let rec serializeDeclarator (VariableDeclarator(id, init, loc)) = \r\n    createObj [ \r\n      \"type\" => \"VariableDeclarator\"; \"id\" => serializePattern id; \r\n      \"init\" =?> Option.map serializeExpression init; \"loc\" =?> loc ]\r\n    \r\n  and serializeExpression expr = \r\n    match expr with\r\n    | IdentifierExpression(name, loc) ->\r\n        createObj [ \"type\" => \"Identifier\"; \"name\" => name; \"loc\" =?> loc ]\r\n    | NewExpression(callee, args, loc) ->\r\n        createObj [ \r\n          \"type\" => \"NewExpression\"; \"callee\" => serializeExpression callee\r\n          \"arguments\" => Array.ofList (List.map serializeExpression args); \"loc\" =?> loc ]\r\n    | FunctionExpression(id, pars, body, generator, async, loc) ->\r\n        createObj [ \r\n          \"type\" => \"FunctionExpression\"; \"id\" =?> id; \"params\" => Array.ofList (List.map serializePattern pars)\r\n          \"body\" => serializeStatement body; \"generator\" => generator; \"async\" => async; \"loc\" =?> loc ]\r\n    | AssignmentExpression(op, l, r, loc) ->\r\n        createObj [ \r\n          \"type\" => \"AssignmentExpression\"; \"left\" => serializeExpression l; \"right\" => serializeExpression r;\r\n          \"operator\" => serializeAssignOperator op; \"loc\" =?> loc ]\r\n    | CallExpression(callee, args, loc) ->\r\n        createObj [ \r\n          \"type\" => \"CallExpression\"; \"callee\" => serializeExpression callee\r\n          \"arguments\" => Array.ofSeq (List.map serializeExpression args); \"loc\" =?> loc ]\r\n    | MemberExpression(obj, prop, computed, loc) ->\r\n        createObj [\r\n          \"type\" => \"MemberExpression\"; \"object\" => serializeExpression obj;\r\n          \"property\" => serializeExpression prop; \"computed\" => computed; \"loc\" =?> loc ]\r\n    | BinaryExpression(op, l, r, loc) ->\r\n        createObj [ \r\n          \"type\" => \"BinaryExpression\"; \"left\" => serializeExpression l; \"right\" => serializeExpression r;\r\n          \"operator\" => serializeBinaryOperator op; \"loc\" =?> loc ]\r\n    \r\n    | ArrayExpression(elements, loc) ->\r\n        createObj [ \"type\" => \"ArrayExpression\"; \"elements\" => Array.ofSeq (List.map serializeExpression elements); \"loc\" =?> loc ]\r\n    | NullLiteral(loc) ->\r\n        createObj [ \"type\" => \"NullLiteral\"; \"loc\" =?> loc ]\r\n    | StringLiteral(v, loc) ->\r\n        createObj [ \"type\" => \"StringLiteral\"; \"value\" => v; \"loc\" =?> loc ]\r\n    | BooleanLiteral(v, loc) ->\r\n        createObj [ \"type\" => \"BooleanLiteral\"; \"value\" => v; \"loc\" =?> loc ]\r\n    | NumericLiteral(v, loc) ->\r\n        createObj [ \"type\" => \"NumericLiteral\"; \"value\" => v; \"loc\" =?> loc ]\r\n\r\n  and serializeStatement stm = \r\n    match stm with\r\n    | ExpressionStatement(e, loc) ->  \r\n        createObj [ \"type\" => \"ExpressionStatement\"; \"loc\" =?> loc; \"expression\" => serializeExpression e ]\r\n    | BlockStatement(b, loc) ->\r\n        createObj [ \"type\" => \"BlockStatement\"; \"loc\" =?> loc; \"body\" => Array.ofList (List.map serializeStatement b) ]\r\n    | EmptyStatement(loc) ->\r\n        createObj [ \"type\" => \"EmptyStatement\"; \"loc\" =?> loc  ]\r\n    | ReturnStatement(arg, loc) ->\r\n        createObj [ \"type\" => \"ReturnStatement\"; \"loc\" =?> loc; \"argument\" => serializeExpression arg ]\r\n    | VariableDeclaration(kind, decls, loc) ->\r\n        let kind = match kind with Var -> \"var\" | Let -> \"let\" | Const -> \"const\"\r\n        createObj [ \r\n          \"type\" => \"VariableDeclaration\"; \"kind\" => kind; \r\n          \"declarations\" => Array.ofList (List.map serializeDeclarator decls); \"loc\" =?> loc  ]\r\n\r\n  let serializeProgram prog = \r\n    createObj [\r\n      \"type\" => \"Program\"\r\n      \"loc\" =?> prog.location \r\n      \"sourceType\" => \"module\"\r\n      \"body\" => Array.ofList (List.map serializeStatement prog.body)\r\n      \"directives\" => box [||]\r\n    ]\r\n\r\n(*\r\ntype NumberKind =\r\n    | Int8 | UInt8 | Int16 | UInt16 | Int32 | UInt32 | Float32 | Float64\r\n\r\ntype RegexFlag =\r\n    | RegexGlobal | RegexIgnoreCase | RegexMultiline | RegexSticky\r\n\r\ntype UnaryOperator =\r\n    | UnaryMinus\r\n    | UnaryPlus\r\n    | UnaryNot\r\n    | UnaryNotBitwise\r\n    | UnaryTypeof\r\n    | UnaryVoid\r\n    | UnaryDelete\r\n    \r\ntype UpdateOperator =\r\n    | UpdateMinus\r\n    | UpdatePlus\r\n        \r\ntype LogicalOperator =\r\n    | LogicalOr\r\n    | LogicalAnd\r\n    \r\ntype AssignmentOperator =\r\n    | AssignEqual\r\n    | AssignMinus\r\n    | AssignPlus\r\n    | AssignMultiply\r\n    | AssignDivide\r\n    | AssignModulus\r\n    | AssignShiftLeft\r\n    | AssignShiftRightSignPropagating\r\n    | AssignShiftRightZeroFill\r\n    | AssignOrBitwise\r\n    | AssignXorBitwise\r\n    | AssignAndBitwise    \r\n*)\r\n(*\r\n/// The type field is a string representing the AST variant type. \r\n/// Each subtype of Node is documented below with the specific string of its type field. \r\n/// You can use this field to determine which interface a node implements.\r\n/// The loc field represents the source location information of the node. \r\n/// If the node contains no information about the source location, the field is null; \r\n/// otherwise it is an object consisting of a start position (the position of the first character of the parsed source region) \r\n/// and an end position (the position of the first character after the parsed source region):\r\n[<AbstractClass>]\r\ntype Node(typ, ?loc) =\r\n    member x.``type``: string = typ\r\n    member x.loc: SourceLocation option = loc\r\n\r\n/// Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.\r\n[<AbstractClass>] type Expression(typ, ?loc) = inherit Node(typ, ?loc = loc)\r\n\r\n[<AbstractClass>] type Literal(typ, ?loc) = inherit Expression(typ, ?loc = loc)\r\n\r\n[<AbstractClass>] type Statement(typ, ?loc) = inherit Node(typ, ?loc = loc)\r\n\r\n/// Note that declarations are considered statements; this is because declarations can appear in any statement context.\r\n[<AbstractClass>] type Declaration(typ, ?loc) = inherit Statement(typ, ?loc = loc)\r\n\r\n/// A module import or export declaration.\r\n[<AbstractClass>] type ModuleDeclaration(typ, ?loc) = inherit Node(typ, ?loc = loc)\r\n\r\ntype Pattern = interface end\r\n\r\n/// Placeholder, doesn't belong to Babel specs\r\ntype EmptyExpression() =\r\n    inherit Expression(\"EmptyExpression\")\r\n\r\n/// Not in Babel specs, disguised as StringLiteral    \r\ntype MacroExpression(value, args, ?loc) =\r\n    inherit Literal(\"StringLiteral\", ?loc = loc)\r\n    member x.value: string = value\r\n    member x.args: Node[] = args\r\n    member x.macro = true\r\n\r\n(** ##Template Literals *)\r\ntype TemplateElement(value: string, tail, ?loc) =\r\n    inherit Node(\"TemplateElement\", ?loc = loc)\r\n    member x.tail: bool = tail\r\n    member x.value = dict [ (\"raw\", value); (\"cooked\", value) ]\r\n\r\ntype TemplateLiteral(quasis, expressions, ?loc) =\r\n    inherit Literal(\"TemplateLiteral\", ?loc = loc)\r\n    member x.quasis: TemplateElement[] = quasis\r\n    member x.expressions: Expression[] = expressions\r\n    \r\ntype TaggedTemplateExpression(tag, quasi, ?loc) =\r\n    inherit Expression(\"TaggedTemplateExpression\", ?loc = loc)\r\n    member x.tag: Expression = tag\r\n    member x.quasi: TemplateLiteral = quasi\r\n\r\n(** ##Identifier *)\r\n/// Note that an identifier may be an expression or a destructuring pattern.\r\ntype Identifier(name, ?loc) =\r\n    inherit Expression(\"Identifier\", ?loc = loc)\r\n    member x.name: string = name\r\n    interface Pattern\r\n    override x.ToString() = x.name\r\n\r\n(** ##Literals *)\r\ntype RegExpLiteral(pattern, flags, ?loc) =\r\n    inherit Literal(\"RegExpLiteral\", ?loc = loc)\r\n    member x.pattern: string = pattern\r\n    member x.flags =\r\n        flags |> Seq.map (function\r\n            | RegexGlobal -> \"g\"\r\n            | RegexIgnoreCase -> \"i\"\r\n            | RegexMultiline -> \"m\"\r\n            | RegexSticky -> \"y\") |> Seq.fold (+) \"\"\r\n\r\ntype NullLiteral(?loc) =\r\n    inherit Literal(\"NullLiteral\", ?loc = loc)\r\n\r\ntype StringLiteral(value, ?loc) =\r\n    inherit Literal(\"StringLiteral\", ?loc = loc)\r\n    member x.value: string = value\r\n\r\ntype BooleanLiteral(value, ?loc) =\r\n    inherit Literal(\"BooleanLiteral\", ?loc = loc)\r\n    member x.value: bool = value\r\n\r\ntype NumericLiteral(value, ?loc) =\r\n    inherit Literal(\"NumericLiteral\", ?loc = loc)\r\n    member x.value: U2<int, float> = value    \r\n\r\n(** ##Misc *)\r\ntype Decorator(value, ?loc) =\r\n    inherit Node(\"Decorator\", ?loc = loc)\r\n    member x.value = value\r\n    \r\ntype DirectiveLiteral(?loc) =\r\n    inherit StringLiteral(\"DirectiveLiteral\", ?loc = loc)\r\n\r\n/// e.g. \"use strict\";\r\ntype Directive(value, ?loc) =\r\n    inherit Node(\"Directive\", ?loc = loc)\r\n    member x.value: DirectiveLiteral = value    \r\n\r\n(** ##Program *)\r\n/// A complete program source tree.\r\n/// Parsers must specify sourceType as \"module\" if the source has been parsed as an ES6 module. \r\n/// Otherwise, sourceType must be \"script\".\r\ntype Program(fileName, originalFileName, loc, body, ?directives) =\r\n    inherit Node(\"Program\", loc)\r\n    member x.sourceType = \"module\" // Don't use \"script\"\r\n    member x.body: U2<Statement, ModuleDeclaration>[] = body\r\n    member x.directives: Directive[] = defaultArg directives [||]\r\n    // Properties below don't belong to babel specs\r\n    member x.fileName: string = fileName\r\n    member x.originalFileName: string = originalFileName\r\n\r\n(** ##Statements *)\r\n/// An expression statement, i.e., a statement consisting of a single expression.\r\ntype ExpressionStatement(expression, ?loc) =\r\n    inherit Statement(\"ExpressionStatement\", ?loc = loc)\r\n    member x.expression: Expression = expression\r\n\r\n/// A block statement, i.e., a sequence of statements surrounded by braces.\r\ntype BlockStatement(body, ?directives, ?loc) =\r\n    inherit Statement(\"BlockStatement\", ?loc = loc)\r\n    member x.body: Statement[] = body\r\n    member x.directives: Directive[] = defaultArg directives [||]\r\n\r\n/// An empty statement, i.e., a solitary semicolon.\r\ntype EmptyStatement(?loc) =\r\n    inherit Statement(\"EmptyStatement\", ?loc = loc)\r\n\r\ntype DebuggerStatement(?loc) =\r\n    inherit Statement(\"DebuggerStatement\", ?loc = loc)\r\n    \r\n// type WithStatement\r\n\r\n(** ##Control Flow *)\r\ntype ReturnStatement(argument, ?loc) =\r\n    inherit Statement(\"ReturnStatement\", ?loc = loc)\r\n    member x.argument: Expression = argument\r\n\r\n// type LabeledStatement\r\n// type BreakStatement\r\n// type ContinueStatement\r\n\r\n(** ##Choice *)\r\ntype IfStatement(test, consequent, ?alternate, ?loc) =\r\n    inherit Statement(\"IfStatement\", ?loc = loc)\r\n    member x.test: Expression = test\r\n    member x.consequent: Statement = consequent\r\n    member x.alternate: Statement option = alternate    \r\n\r\n/// A case (if test is an Expression) or default (if test === null) clause in the body of a switch statement.\r\ntype SwitchCase(consequent, ?test, ?loc) =\r\n    inherit Node(\"SwitchCase\", ?loc = loc)\r\n    member x.test: Expression option = test\r\n    member x.consequent: Statement[] = consequent\r\n\r\ntype SwitchStatement(discriminant, cases, ?loc) =\r\n    inherit Statement(\"SwitchStatement\", ?loc = loc)\r\n    member x.discriminant: Expression = discriminant\r\n    member x.cases: SwitchCase[] = cases\r\n\r\n(** ##Exceptions *)\r\ntype ThrowStatement(argument, ?loc) =\r\n    inherit Statement(\"ThrowStatement\", ?loc = loc)\r\n    member x.argument: Expression = argument\r\n\r\n/// A catch clause following a try block.\r\ntype CatchClause(param, body, ?loc) =\r\n    inherit Node(\"CatchClause\", ?loc = loc)\r\n    member x.param: Pattern = param\r\n    member x.body: BlockStatement = body\r\n\r\n/// If handler is null then finalizer must be a BlockStatement.\r\ntype TryStatement(block, ?handler, ?finalizer, ?loc) =\r\n    inherit Statement(\"TryStatement\", ?loc = loc)\r\n    member x.block: BlockStatement = block\r\n    member x.handler: CatchClause option = handler\r\n    member x.finalizer: BlockStatement option = finalizer\r\n\r\n(** ##Declarations *)\r\ntype VariableDeclarator(id, ?init, ?loc) =\r\n    inherit Declaration(\"VariableDeclarator\", ?loc = loc)\r\n    member x.id: Pattern = id\r\n    member x.init: Expression option = init\r\n\r\ntype VariableDeclarationKind = Var | Let | Const\r\n\r\ntype VariableDeclaration(kind, declarations, ?loc) =\r\n    inherit Declaration(\"VariableDeclaration\", ?loc = loc)\r\n    new (var, ?init, ?loc) =\r\n        VariableDeclaration(Var, [|VariableDeclarator(var, ?init=init, ?loc=loc)|], ?loc=loc)\r\n    member x.declarations: VariableDeclarator[] = declarations\r\n    member x.kind =\r\n        match kind with Var -> \"var\" | Let -> \"let\" | Const -> \"const\"\r\n\r\n(** ##Loops *)\r\ntype WhileStatement(test, body, ?loc) =\r\n    inherit Statement(\"WhileStatement\", ?loc = loc)\r\n    member x.test: Expression = test\r\n    member x.body: BlockStatement = body\r\n\r\ntype DoWhileStatement(body, test, ?loc) =\r\n    inherit Statement(\"DoWhileStatement\", ?loc = loc)\r\n    member x.body: BlockStatement = body\r\n    member x.test: Expression = test\r\n\r\ntype ForStatement(body, ?init, ?test, ?update, ?loc) =\r\n    inherit Statement(\"ForStatement\", ?loc = loc)\r\n    member x.body: BlockStatement = body\r\n    member x.init: U2<VariableDeclaration, Expression> option = init\r\n    member x.test: Expression option = test\r\n    member x.update: Expression option = update\r\n\r\n/// When passing a VariableDeclaration, the bound value must go through\r\n/// the `right` parameter instead of `init` property in VariableDeclarator\r\ntype ForInStatement(left, right, body, ?loc) =\r\n    inherit Statement(\"ForInStatement\", ?loc = loc)\r\n    member x.body: BlockStatement = body\r\n    member x.left: U2<VariableDeclaration, Expression> = left\r\n    member x.right: Expression = right\r\n\r\n/// When passing a VariableDeclaration, the bound value must go through\r\n/// the `right` parameter instead of `init` property in VariableDeclarator\r\ntype ForOfStatement(left, right, body, ?loc) =\r\n    inherit Statement(\"ForOfStatement\", ?loc = loc)\r\n    member x.body: BlockStatement = body\r\n    member x.left: U2<VariableDeclaration, Expression> = left\r\n    member x.right: Expression = right\r\n\r\n/// A function declaration. Note that id cannot be null.\r\ntype FunctionDeclaration(id, args, body, ?generator, ?async, ?loc) =\r\n    inherit Declaration(\"FunctionDeclaration\", ?loc = loc)\r\n    member x.id: Identifier = id\r\n    member x.``params``: Pattern[] = args\r\n    member x.body: BlockStatement = body\r\n    member x.generator = defaultArg generator false\r\n    member x.async = defaultArg async false\r\n\r\n(** ##Expressions *)\r\n\r\n/// A super pseudo-expression.\r\ntype Super(?loc) =\r\n    inherit Expression(\"Super\", ?loc = loc)\r\n\r\ntype ThisExpression(?loc) =\r\n    inherit Expression(\"ThisExpression\", ?loc = loc)\r\n\r\n/// A fat arrow function expression, e.g., let foo = (bar) => { /* body */ }.\r\ntype ArrowFunctionExpression(args, body, isExpression, ?async, ?loc) =\r\n    inherit Expression(\"ArrowFunctionExpression\", ?loc = loc)\r\n    member x.expression = isExpression\r\n    member x.``params``: Pattern[] = args\r\n    member x.body: U2<BlockStatement, Expression> = body\r\n    member x.async: bool = defaultArg async false\r\n        \r\ntype FunctionExpression(args, body, ?generator, ?async, ?id, ?loc) =\r\n    inherit Expression(\"FunctionExpression\", ?loc = loc)\r\n    member x.id: Identifier option = id\r\n    member x.``params``: Pattern[] = args\r\n    member x.body: BlockStatement = body\r\n    member x.generator: bool = defaultArg generator false\r\n    member x.async: bool = defaultArg async false\r\n    \r\n/// e.g., x = do { var t = f(); t * t + 1 };\r\n/// http://wiki.ecmascript.org/doku.php?id=strawman:do_expressions\r\n/// Doesn't seem to work well with block-scoped variables (let, const)\r\ntype DoExpression(body, ?loc) =\r\n    inherit Expression(\"DoExpression\", ?loc = loc)\r\n    member x.body: BlockStatement = body\r\n    \r\ntype YieldExpression(argument, ``delegate``, ?loc) =\r\n    inherit Expression(\"YieldExpression\", ?loc = loc)\r\n    member x.argument: Expression option = argument\r\n    /// Delegates to another generator? (yield* )\r\n    member x.``delegate``: bool = ``delegate``    \r\n\r\ntype AwaitExpression(argument, ?loc) =\r\n    inherit Expression(\"AwaitExpression\", ?loc = loc)\r\n    member x.argument: Expression option = argument\r\n\r\ntype RestProperty(argument, ?loc) =\r\n    inherit Node(\"RestProperty\", ?loc = loc)\r\n    member x.argument: Expression = argument\r\n\r\n/// e.g., var z = { x: 1, ...y } // Copy all properties from y \r\ntype SpreadProperty(argument, ?loc) =\r\n    inherit Node(\"SpreadProperty\", ?loc = loc)\r\n    member x.argument: Expression = argument\r\n\r\ntype SpreadElement(argument, ?loc) =\r\n    inherit Node(\"SpreadElement\", ?loc = loc)\r\n    member x.argument: Expression = argument\r\n    \r\ntype ArrayExpression(elements, ?loc) =\r\n    inherit Expression(\"ArrayExpression\", ?loc = loc)\r\n    member x.elements: U2<Expression, SpreadElement> option[] = elements\r\n\r\n[<AbstractClass>]\r\ntype ObjectMember(typ, key, ?value, ?computed, ?loc) =\r\n    inherit Node(typ, ?loc = loc)\r\n    member x.key: Expression = key\r\n    member x.value: Expression option = value\r\n    member x.computed: bool = defaultArg computed false\r\n    // member x.decorators: Decorator[] = defaultArg decorators []\r\n    \r\ntype ObjectProperty(key, value, ?shorthand, ?computed, ?loc) =\r\n    inherit ObjectMember(\"ObjectProperty\", key, value, ?computed=computed, ?loc=loc)\r\n    member x.shorthand: bool = defaultArg shorthand false\r\n\r\ntype ObjectMethodKind = ObjectGetter | ObjectSetter | ObjectMeth\r\n\r\ntype ObjectMethod(kind, key, args, body, ?computed, ?generator, ?async, ?loc) =\r\n    inherit ObjectMember(\"ObjectMethod\", key, ?computed=computed, ?loc=loc)\r\n    member x.kind = match kind with ObjectGetter -> \"get\"\r\n                                  | ObjectSetter -> \"set\"\r\n                                  | ObjectMeth -> \"method\"\r\n    member x.``params``: Pattern[] = args\r\n    member x.body: BlockStatement = body\r\n    member x.generator: bool = defaultArg generator false\r\n    member x.async: bool = defaultArg async false\r\n\r\n/// If computed is true, the node corresponds to a computed (a[b]) member expression and property is an Expression. \r\n/// If computed is false, the node corresponds to a static (a.b) member expression and property is an Identifier.\r\ntype MemberExpression(``object``, property, ?computed, ?loc) =\r\n    inherit Expression(\"MemberExpression\", ?loc = loc)\r\n    member x.``object``: Expression = ``object``\r\n    member x.property: Expression = property\r\n    member x.computed: bool = defaultArg computed false\r\n    interface Pattern\r\n\r\ntype ObjectExpression(properties, ?loc) =\r\n    inherit Expression(\"ObjectExpression\", ?loc = loc)\r\n    member x.properties: U3<ObjectProperty, ObjectMethod, SpreadProperty>[] = properties\r\n\r\n/// A conditional expression, i.e., a ternary ?/: expression.\r\ntype ConditionalExpression(test, consequent, alternate, ?loc) =\r\n    inherit Expression(\"ConditionalExpression\", ?loc = loc)\r\n    member x.test: Expression = test\r\n    member x.consequent: Expression = consequent\r\n    member x.alternate: Expression = alternate\r\n\r\n/// A function or method call expression.  \r\ntype CallExpression(callee, args, ?loc) =\r\n    inherit Expression(\"CallExpression\", ?loc = loc)\r\n    member x.callee: Expression = callee\r\n    member x.arguments: U2<Expression, SpreadElement>[] = args\r\n\r\ntype NewExpression(callee, args, ?loc) =\r\n    inherit Expression(\"NewExpression\", ?loc = loc)\r\n    member x.callee: Expression = callee\r\n    member x.arguments: U2<Expression, SpreadElement>[] = args\r\n\r\n/// A comma-separated sequence of expressions.\r\ntype SequenceExpression(expressions, ?loc) =\r\n    inherit Expression(\"SequenceExpression\", ?loc = loc)\r\n    member x.expressions: Expression[] = expressions\r\n\r\n(** ##Unary Operations *)\r\ntype UnaryExpression(operator, argument, ?prefix, ?loc) =\r\n    inherit Expression(\"UnaryExpression\", ?loc = loc)\r\n    member x.prefix: bool = defaultArg prefix true\r\n    member x.argument: Expression = argument\r\n    member x.operator =\r\n        match operator with\r\n        | UnaryMinus -> \"-\"\r\n        | UnaryPlus -> \"+\"\r\n        | UnaryNot -> \"!\"\r\n        | UnaryNotBitwise -> \"~\"\r\n        | UnaryTypeof -> \"typeof\"\r\n        | UnaryVoid -> \"void\"\r\n        | UnaryDelete -> \"delete\"           \r\n\r\ntype UpdateExpression(operator, prefix, argument, ?loc) =\r\n    inherit Expression(\"UpdateExpression\", ?loc = loc)\r\n    member x.prefix: bool = prefix\r\n    member x.argument: Expression = argument\r\n    member x.operator =\r\n        match operator with\r\n        | UpdateMinus -> \"--\"\r\n        | UpdatePlus -> \"++\"\r\n    \r\n\r\ntype AssignmentExpression(operator, left, right, ?loc) =\r\n    inherit Expression(\"AssignmentExpression\", ?loc = loc)\r\n    member x.left: Expression = left\r\n    member x.right: Expression = right\r\n    member x.operator =\r\n        match operator with    \r\n        | AssignEqual -> \"=\"\r\n        | AssignMinus -> \"-=\"\r\n        | AssignPlus -> \"+=\"\r\n        | AssignMultiply -> \"*=\"\r\n        | AssignDivide -> \"/=\"\r\n        | AssignModulus -> \"%=\"\r\n        | AssignShiftLeft -> \"<<=\"\r\n        | AssignShiftRightSignPropagating -> \">>=\"\r\n        | AssignShiftRightZeroFill -> \">>>=\"\r\n        | AssignOrBitwise -> \"|=\"\r\n        | AssignXorBitwise -> \"^=\"\r\n        | AssignAndBitwise -> \"&=\"\r\n    \r\ntype LogicalExpression(operator, left, right, ?loc) =\r\n    inherit Expression(\"LogicalExpression\", ?loc = loc)\r\n    member x.left: Expression = left\r\n    member x.right: Expression = right\r\n    member x.operator =\r\n        match operator with\r\n        | LogicalOr -> \"||\"\r\n        | LogicalAnd-> \"&&\"\r\n        \r\n\r\n(** ##Patterns *)\r\n// type AssignmentProperty(key, value, ?loc) =\r\n//     inherit ObjectProperty(\"AssignmentProperty\", ?loc = loc)\r\n//     member x.value: Pattern = value\r\n\r\n// type ObjectPattern(properties, ?loc) =\r\n//     inherit Node(\"ObjectPattern\", ?loc = loc)\r\n//     member x.properties: U2<AssignmentProperty, RestProperty>[] = properties\r\n//     interface Pattern\r\n\r\ntype ArrayPattern(elements, ?loc) =\r\n    inherit Node(\"ArrayPattern\", ?loc = loc)\r\n    member x.elements: Pattern option[] = elements\r\n    interface Pattern\r\n\r\ntype AssignmentPattern(left, right, ?loc) =\r\n    inherit Node(\"AssignmentPattern\", ?loc = loc)\r\n    member x.left: Pattern = left\r\n    member x.right: Expression = right\r\n    interface Pattern\r\n\r\ntype RestElement(argument, ?loc) =\r\n    inherit Node(\"RestElement\", ?loc = loc)\r\n    member x.argument: Pattern = argument\r\n    interface Pattern        \r\n\r\n(** ##Classes *)\r\ntype ClassMethodKind =\r\n    | ClassConstructor | ClassFunction | ClassGetter | ClassSetter\r\n\r\ntype ClassMethod(kind, key, args, body, computed, ``static``, ?loc) =\r\n    inherit Node(\"ClassMethod\", ?loc = loc)\r\n    member x.kind = match kind with ClassConstructor -> \"constructor\"\r\n                                  | ClassGetter -> \"get\"\r\n                                  | ClassSetter -> \"set\"\r\n                                  | ClassFunction -> \"method\"\r\n    member x.key: Expression = key\r\n    member x.``params``: Pattern[] = args\r\n    member x.body: BlockStatement = body\r\n    member x.computed: bool = computed\r\n    member x.``static``: bool = ``static``\r\n    // member x.decorators: Decorator[] = defaultArg decorators []\r\n    // This appears in astexplorer.net but it's not documented\r\n    // member x.expression: bool = false\r\n\r\n/// ES Class Fields & Static Properties\r\n/// https://github.com/jeffmo/es-class-fields-and-static-properties\r\n/// e.g, class MyClass { static myStaticProp = 5; myProp /* = 10 */; }\r\ntype ClassProperty(key, value, ?loc) =\r\n    inherit Node(\"ClassProperty\", ?loc = loc)\r\n    member x.key: Identifier = key\r\n    member x.value: Expression = value\r\n\r\ntype ClassBody(body, ?loc) =\r\n    inherit Node(\"ClassBody\", ?loc = loc)\r\n    member x.body: U2<ClassMethod, ClassProperty>[] = body\r\n\r\ntype ClassDeclaration(body, id, ?super, ?loc) =\r\n    inherit Declaration(\"ClassDeclaration\", ?loc = loc)\r\n    member x.body: ClassBody = body\r\n    member x.id: Identifier = id\r\n    member x.superClass: Expression option = super\r\n    // member x.decorators: Decorator[] = defaultArg decorators []\r\n\r\n/// Anonymous class: e.g., var myClass = class { }\r\ntype ClassExpression(body, ?id, ?super, ?loc) =\r\n    inherit Expression(\"ClassExpression\", ?loc = loc)\r\n    member x.body: ClassBody = body\r\n    member x.id: Identifier option = id    \r\n    member x.superClass: Expression option = super\r\n    // member x.decorators: Decorator[] = defaultArg decorators []\r\n\r\n// type MetaProperty(meta, property, ?loc) =\r\n//     inherit Expression(\"MetaProperty\", ?loc = loc)\r\n//     member x.meta: Identifier = meta\r\n//     member x.property: Expression = property\r\n\r\n(** ##Modules *)\r\n/// A specifier in an import or export declaration.\r\n[<AbstractClass>]\r\ntype ModuleSpecifier(typ, local, ?loc) =\r\n    inherit Node(typ, ?loc = loc)\r\n    member x.local: Identifier = local\r\n\r\n/// An imported variable binding, e.g., {foo} in import {foo} from \"mod\" or {foo as bar} in import {foo as bar} from \"mod\". \r\n/// The imported field refers to the name of the export imported from the module. \r\n/// The local field refers to the binding imported into the local module scope. \r\n/// If it is a basic named import, such as in import {foo} from \"mod\", both imported and local are equivalent Identifier nodes; in this case an Identifier node representing foo. \r\n/// If it is an aliased import, such as in import {foo as bar} from \"mod\", the imported field is an Identifier node representing foo, and the local field is an Identifier node representing bar.\r\ntype ImportSpecifier(local, imported, ?loc) =\r\n    inherit ModuleSpecifier(\"ImportSpecifier\", local, ?loc = loc)\r\n    member x.imported: Identifier = imported\r\n\r\n/// A default import specifier, e.g., foo in import foo from \"mod\".\r\ntype ImportDefaultSpecifier(local, ?loc) =\r\n    inherit ModuleSpecifier(\"ImportDefaultSpecifier\", local, ?loc = loc)\r\n    \r\n/// A namespace import specifier, e.g., * as foo in import * as foo from \"mod\".\r\ntype ImportNamespaceSpecifier(local, ?loc) =\r\n    inherit ModuleSpecifier(\"ImportNamespaceSpecifier\", local, ?loc = loc)\r\n\r\n/// e.g., import foo from \"mod\";.\r\ntype ImportDeclaration(specifiers, source, ?loc) =\r\n    inherit ModuleDeclaration(\"ImportDeclaration\", ?loc = loc)\r\n    member x.specifiers: U3<ImportSpecifier, ImportDefaultSpecifier, ImportNamespaceSpecifier>[] = specifiers\r\n    member x.source: Literal = source\r\n\r\n/// An exported variable binding, e.g., {foo} in export {foo} or {bar as foo} in export {bar as foo}. \r\n/// The exported field refers to the name exported in the module. \r\n/// The local field refers to the binding into the local module scope. \r\n/// If it is a basic named export, such as in export {foo}, both exported and local are equivalent Identifier nodes; \r\n/// in this case an Identifier node representing foo. If it is an aliased export, such as in export {bar as foo}, \r\n/// the exported field is an Identifier node representing foo, and the local field is an Identifier node representing bar.\r\ntype ExportSpecifier(local, exported, ?loc) =\r\n    inherit ModuleSpecifier(\"ExportSpecifier\", local, ?loc = loc)\r\n    member x.exported: Identifier = exported\r\n    \r\n/// An export named declaration, e.g., export {foo, bar};, export {foo} from \"mod\"; or export var foo = 1;.\r\n/// Note: Having declaration populated with non-empty specifiers or non-null source results in an invalid state.\r\ntype ExportNamedDeclaration(?declaration, ?specifiers, ?source, ?loc) =\r\n    inherit ModuleDeclaration(\"ExportNamedDeclaration\", ?loc = loc)\r\n    member x.declaration: Declaration option = declaration\r\n    member x.specifiers: ExportSpecifier[] = defaultArg specifiers [||]\r\n    member x.source: Literal option = source\r\n\r\n/// An export default declaration, e.g., export default function () {}; or export default 1;. \r\ntype ExportDefaultDeclaration(declaration, ?loc) =\r\n    inherit ModuleDeclaration(\"ExportDefaultDeclaration\", ?loc = loc)\r\n    member x.declaration: U2<Declaration, Expression> = declaration\r\n\r\n/// An export batch declaration, e.g., export * from \"mod\";.\r\ntype ExportAllDeclaration(source, ?loc) =\r\n    inherit ModuleDeclaration(\"ExportAllDeclaration\", ?loc = loc)\r\n    member x.source: Literal = source\r\n*)"]}