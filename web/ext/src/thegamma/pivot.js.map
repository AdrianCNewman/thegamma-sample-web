{"version":3,"sources":["../../../src/thegamma/pivot.fs"],"names":[],"mappings":"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","file":"pivot.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.TypeProviders.Pivot\r\n\r\nopen TheGamma\r\nopen TheGamma.Babel\r\nopen Fable.Import\r\nopen Fable.Core\r\nopen Fable.Extensions\r\nopen TheGamma.TypePoviders\r\n\r\n// ----------------------------------------------------------------------------\r\n// Operations that we can do on the table\r\n// ----------------------------------------------------------------------------\r\n\r\ntype Aggregation = \r\n | GroupKey\r\n | CountAll\r\n | CountDistinct of string\r\n | ReturnUnique of string\r\n | ConcatValues of string\r\n | Sum of string\r\n | Mean of string\r\n\r\ntype SortDirection =\r\n  | Ascending\r\n  | Descending \r\n\r\ntype Paging =\r\n  | Take of string\r\n  | Skip of string\r\n  \r\ntype Transformation = \r\n  | DropColumns of string list\r\n  | SortBy of (string * SortDirection) list\r\n  | GroupBy of string list * Aggregation list\r\n  | FilterBy of (string * bool * string) list\r\n  | Paging of Paging list\r\n  | GetSeries of string * string\r\n  | Empty\r\n\r\ntype Field = \r\n  { Name : string \r\n    Type : string }\r\n\r\nmodule Transform = \r\n\r\n  let private formatAgg = function\r\n    | GroupKey -> [\"key\"]\r\n    | CountAll -> [\"count-all\"]\r\n    | CountDistinct(f) -> [\"count-dist\"; f]\r\n    | ReturnUnique(f) -> [\"unique\"; f]\r\n    | ConcatValues(f) -> [\"concat-vals\"; f]\r\n    | Sum(f) -> [\"sum\"; f]\r\n    | Mean(f) -> [\"mean\"; f]\r\n\r\n  let toUrl transforms = \r\n    [ for t in List.rev transforms ->\r\n        match t with\r\n        | FilterBy(conds) -> \"filter\"::(List.collect (fun (f,b,v) -> [f; (if b then \"eq\" else \"neq\"); v]) conds)\r\n        | DropColumns(columns) -> \"drop\"::columns\r\n        | SortBy(columns) -> \"sort\"::(List.collect (fun (c, o) -> [c; (if o = Ascending then \"asc\" else \"desc\")]) columns)\r\n        | GroupBy(flds, aggs) -> \"group\"::((List.map (fun f -> \"by-\" + f) flds) @ (List.collect formatAgg aggs))\r\n        | Paging(ops) -> \"page\"::(List.collect (function Take k -> [\"take\"; k] | Skip k -> [\"skip\"; k]) ops)\r\n        | GetSeries(k, v) -> \"series\"::k::v::[]\r\n        | Empty -> [] ]\r\n    |> List.mapi (fun i l -> if i = 0 then l else \"then\"::l)\r\n    |> List.concat\r\n    |> String.concat \"/\"\r\n\r\n  let singleTransformFields fields = function\r\n    | Empty -> fields\r\n    | SortBy _ -> fields\r\n    | Paging _ -> fields\r\n    | FilterBy _ -> fields\r\n    | GetSeries(k, v) -> \r\n        [ fields |> List.find (fun f -> f.Name = k)\r\n          fields |> List.find (fun f -> f.Name = v) ]\r\n    | DropColumns(drop) ->\r\n        let dropped = set drop\r\n        fields |> List.filter (fun f -> not(dropped.Contains f.Name))\r\n    | GroupBy(flds, aggs) ->\r\n        let oldFields = dict [ for f in fields -> f.Name, f ]\r\n        aggs \r\n        |> List.collect (function\r\n           | GroupKey -> List.map (fun f -> oldFields.[f]) flds\r\n           | ReturnUnique fld\r\n           | ConcatValues fld\r\n           | Sum fld -> [ oldFields.[fld] ]\r\n           | Mean fld -> [ oldFields.[fld] ]\r\n           | CountAll -> [ { Name = \"count\"; Type = \"num\" } ]\r\n           | CountDistinct fld -> [ { Name = oldFields.[fld].Name; Type = \"num\" } ])\r\n      \r\n  let transformFields fields tfs = \r\n    tfs |> List.fold singleTransformFields (List.ofSeq fields)\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Pivot provider\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nlet trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\r\nlet trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\r\n\r\nlet concatUrl (a:string) (b:string) =\r\n  (trimRight '/' a) + \"/\" + (trimLeft '/' b)\r\n\r\nlet withDocs title details membr = \r\n  match membr with\r\n  | Member.Method(n, tya, args, typ, _, emitter) ->\r\n      Member.Method(n, tya, args, typ, Documentation.Details(title, details), emitter)\r\n  | Member.Property(n, typ, schema, _, emitter) ->\r\n      Member.Property(n, typ, schema, Documentation.Details(title, details), emitter)\r\n\r\nlet withSchema actTyp fldName listName membr = \r\n  match membr with\r\n  | Member.Property(n, typ, _, docs, emitter) ->\r\n      let schema = \r\n        { Type = actTyp\r\n          JSON = \r\n            [ \"@context\", box \"http://schema.org/\"\r\n              \"@type\", box actTyp \r\n              fldName, JsInterop.createObj [ \"@type\", box \"ItemList\"; \"name\", box listName ] ]\r\n            |> JsInterop.createObj }\r\n      Member.Property(n, typ, Some schema, docs, emitter)\r\n  | _ -> failwith \"withSchema: expected property\"\r\n\r\nlet withCreateAction action membr = \r\n  membr\r\nlet withAddAction action membr = \r\n  membr\r\nlet withThingSchema name annotation membr = \r\n  membr\r\n\r\nlet makeObjectType members = \r\n  { Members = Array.ofSeq members\r\n    Typeargs = [] } |> Type.Object\r\n\r\nlet isNumeric fld = fld = \"num\"\r\nlet isConcatenable fld = fld = \"string\"\r\n\r\n// From providers.fs\r\nlet ident s = IdentifierExpression(s, None)\r\nlet str v = StringLiteral(v, None)\r\nlet arr l = ArrayExpression(l, None)\r\n\r\nlet (?) (e:Expression) (s:string) = MemberExpression(e, IdentifierExpression(s, None), false, None)\r\nlet (/?/) (e:Expression) a = MemberExpression(e, a, true, None)\r\n\r\nlet (/@/) (e:Expression) (args) = CallExpression(e, args, None)\r\nlet func v f = \r\n  let body = BlockStatement([ReturnStatement(f (ident v), None)], None)\r\n  FunctionExpression(None, [IdentifierPattern(v, None)], body, false, false, None)\r\n\r\nlet getTypeAndEmitter = function \r\n  | \"string\" -> Type.Primitive(\"string\"), id\r\n  | \"num\" -> Type.Primitive(\"num\"), fun e -> ident \"Number\" /@/ [e]\r\n  | _ -> failwith \"getTypeAndEmitter: Unknown primitive type\"\r\n\r\nlet propertyEmitter = \r\n  { Emit = fun (this, _) -> this }\r\n\r\nlet makeMethodEmitter callid pars =\r\n  { Emit = fun (this, args) -> \r\n      let args = arr [ for _, v in args -> v ]\r\n      this?addCall /@/ [str callid; args] }\r\n\r\nlet makeDataEmitter isSeries tfs = \r\n  { Emit = fun (this, _) -> \r\n      // TODO: This is not properly recursively transforming values, but they're just int/string, so it's OK\r\n      if isSeries then\r\n        ident(\"_series\")?series?create /@/ \r\n          [ this?getData /@/ [str (Transform.toUrl (List.rev tfs))]\r\n            str \"key\"; str \"value\"; str \"\" ]\r\n      else\r\n        ident(\"_series\")?series?ordinal /@/ \r\n          [ this?getData /@/ [str (Transform.toUrl (List.rev tfs))]\r\n            str \"key\"; str \"value\"; str \"\" ] }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Transformations\r\n// ----------------------------------------------------------------------------\r\n\r\ntype Context = \r\n  { Root : string\r\n    LookupNamed : string -> Type list -> Type\r\n    InputFields : Field list\r\n    Fields : Field list }\r\n\r\nlet rec makeProperty ctx name tfs = \r\n  Member.Property(name, makePivotType ctx tfs, None, Documentation.None, propertyEmitter)\r\n  \r\nand makeMethod ctx name tfs callid args = \r\n  Member.Method\r\n    ( name, [], [ for n, t in args -> n, false, Type.Primitive t ], makePivotType ctx tfs, \r\n      Documentation.None, makeMethodEmitter callid args )\r\n\r\nand makeDataMember ctx name tfs =\r\n  let fields = Transform.transformFields ctx.InputFields (List.rev tfs)\r\n  let dataTyp, isSeries = \r\n    match tfs with \r\n    | (GetSeries _)::_ -> \r\n        match ctx.Fields with\r\n        | [kf; vf] ->  \r\n            ctx.LookupNamed \"series\" [Type.Primitive kf.Type; Type.Primitive vf.Type], true\r\n        | _ -> failwith \"makeDataMember: Series should have key and value\"\r\n    | _ -> \r\n        let membs = \r\n          fields |> Array.ofSeq |> Array.map (fun fld ->\r\n            let memTy, memConv = getTypeAndEmitter fld.Type\r\n            let emitter = { Emit = fun (inst, _) -> memConv <| (inst /?/ str fld.Name) }\r\n            Member.Property(fld.Name, memTy, None, Documentation.Text \"\", emitter))\r\n        let recTyp = Type.Object { Members = membs; Typeargs = [] }\r\n        ctx.LookupNamed \"series\" [Type.Primitive \"num\"; recTyp ], false\r\n  Member.Property(name, dataTyp, None, Documentation.None, makeDataEmitter isSeries tfs)\r\n\r\nand handleGetSeriesRequest ctx rest k v = \r\n  match k, v with\r\n  | \"!\", \"!\" ->\r\n    [ for field in ctx.Fields ->\r\n        makeProperty ctx (\"with key \" + field.Name) (GetSeries(field.Name, \"!\")::rest)\r\n        |> withDocs \"Get the data\" \"Here, we select one of the attribute of the data set as the 'key' and one as a 'value'. In the first list, you can choose the key.\" \r\n        |> withThingSchema \"ListItem\" \"series key\" ]\r\n    |> makeObjectType\r\n  | k, \"!\" ->\r\n    [ for field in ctx.Fields ->\r\n        makeDataMember ctx (\"and value \" + field.Name) (GetSeries(k, field.Name)::rest) \r\n        |> withDocs \"Get the data\" \"In the second list, choose attribute that you want to use as the value.\"\r\n        |> withThingSchema \"ListItem\" \"series value\" ]\r\n    |> makeObjectType\r\n  | _ -> \r\n    failwith \"handleGetSeriesRequest: Should not happen\"\r\n  \r\nand handlePagingRequest ctx rest pgid ops =\r\n  let takeMemb = \r\n    makeMethod ctx \"take\" (Empty::Paging(List.rev (Take(pgid + \"-take\")::ops))::rest) (pgid + \"-take\") [\"count\", \"num\"] \r\n    |> withDocs \"\" \"Take the specified number of rows and drop the rest\"\r\n  let skipMemb = \r\n    makeMethod ctx \"skip\" (Paging(Skip(pgid + \"-skip\")::ops)::rest) (pgid + \"-skip\") [\"count\", \"num\"] \r\n    |> withDocs \"\" \"Skip the specified number of rows and keep the rest\"\r\n  let thenMemb = \r\n    makeProperty ctx \"then\" (Empty::Paging(List.rev ops)::rest)\r\n    |> withDocs \"\" \"Return the data\"\r\n  ( match ops with\r\n    | [] -> [skipMemb; takeMemb]\r\n    | [Skip _] -> [takeMemb; thenMemb]\r\n    | _ -> failwith \"handlePagingRequest: Shold not happen\" ) |> makeObjectType\r\n\r\nand handleDropRequest ctx rest dropped = \r\n  let droppedFields = set dropped\r\n  [ yield makeProperty ctx \"then\" (Empty::DropColumns(dropped)::rest) |> withDocs \"\" \"Return the data\"\r\n    for field in ctx.Fields do\r\n      if not (droppedFields.Contains field.Name) then\r\n        yield \r\n          makeProperty ctx (\"drop \" + field.Name) (DropColumns(field.Name::dropped)::rest) \r\n          |> withDocs \"\" (sprintf \"Removes the field '%s' from the returned data set\" field.Name)\r\n          |> withAddAction \"Dropped ctx.Fields\" ]\r\n  |> makeObjectType    \r\n\r\nand handleSortRequest ctx rest keys = \r\n  let usedKeys = set (List.map fst keys)\r\n  [ yield makeProperty ctx \"then\" (Empty::SortBy(keys)::rest) |> withDocs \"\" \"Return the data\"\r\n    for field in ctx.Fields do\r\n      if not (usedKeys.Contains field.Name) then\r\n        let doc = sprintf \"Use the field '%s' as the next sorting keys\" field.Name\r\n        let prefix = if keys = [] then \"by \" else \"and by \"\r\n        yield makeProperty ctx (prefix + field.Name) (SortBy((field.Name, Ascending)::keys)::rest) \r\n              |> withDocs \"\" doc \r\n              |> withAddAction \"Fields used for sorting\"\r\n        yield makeProperty ctx (prefix + field.Name + \" descending\") (SortBy((field.Name, Descending)::keys)::rest) \r\n              |> withDocs \"\" doc \r\n              |> withAddAction \"Fields used for sorting\" ]\r\n  |> makeObjectType    \r\n\r\n\r\nand aggregationMembers ctx rest keys aggs = \r\n  let containsCountAll = aggs |> Seq.exists ((=) CountAll)\r\n  let containsField fld = aggs |> Seq.exists (function \r\n    | CountDistinct f | ReturnUnique f | ConcatValues f | Sum f | Mean f -> f = fld | CountAll | GroupKey -> false)\r\n  let makeAggMember name agg doc = \r\n    makeProperty ctx name (GroupBy(keys,agg::aggs)::rest) |> withDocs \"\" doc\r\n    |> withAddAction \"Aggregation operations\"\r\n\r\n  [ yield makeProperty ctx \"then\" (Empty::GroupBy(keys, aggs)::rest) |> withDocs \"\" \"Get data or perform another transformation\"\r\n    if not containsCountAll then \r\n      yield makeAggMember \"count all\" CountAll \"Count the number of items in the group\"\r\n    for fld in ctx.Fields do\r\n      if not (containsField fld.Name) then\r\n        yield makeAggMember (\"count distinct \" + fld.Name) (CountDistinct fld.Name) \r\n                \"Count the number of distinct values of the field\"\r\n        yield makeAggMember (\"return unique \" + fld.Name) (ReturnUnique fld.Name) \r\n                \"Add the value of the field assuming it is unique in the group\"\r\n        if isConcatenable fld.Type then\r\n          yield makeAggMember (\"concatenate values of \" + fld.Name) (ConcatValues fld.Name)\r\n                  \"Concatenate all values of the field\"\r\n        if isNumeric fld.Type then\r\n          yield makeAggMember (\"average \" + fld.Name) (Mean fld.Name)\r\n                  \"Calculate the average value of the field in the group\" \r\n          yield makeAggMember (\"sum \" + fld.Name) (Sum fld.Name)\r\n                  \"Sum the values of the field in the group\" ]\r\n\r\nand handleGroupAggRequest ctx rest keys aggs =\r\n  aggregationMembers ctx rest keys aggs  \r\n  |> makeObjectType  \r\n  \r\nand handleGroupRequest ctx rest keys = \r\n  let prefix = if List.isEmpty keys then \"by \" else \"and \"\r\n  [ for field in ctx.Fields ->\r\n      makeProperty ctx (prefix + field.Name) (GroupBy(field.Name::keys, [])::rest) \r\n      |> withDocs (sprintf \"Group by %s\" (field.Name.ToLower()))\r\n          ( \"Creates groups based on the value of \" + field.Name + \" and calculte summary \" +\r\n            \"values for each group. You can specify a number of summary calculations in the \" + \r\n            \"following list:\")\r\n      |> withCreateAction \"Aggregation operations\" \r\n    if not (List.isEmpty keys) then\r\n      yield! aggregationMembers ctx rest keys [GroupKey] ]\r\n  |> makeObjectType  \r\n\r\nand handleFilterEqNeqRequest ctx rest (fld, eq) conds = async {\r\n  let url = concatUrl (concatUrl ctx.Root \"range\") (FilterBy(conds)::rest |> List.rev |> Transform.toUrl)\r\n  let! options = Http.Request(\"GET\", url + \"?\" + fld)\r\n  let options = jsonParse<string[]> options\r\n  return\r\n    [ for opt in options do\r\n        yield makeProperty ctx opt (FilterBy((fld, eq, opt)::conds)::rest) ] \r\n    |> makeObjectType }\r\n\r\nand handleFilterRequest ctx rest conds = \r\n  let prefix = if List.isEmpty conds then \"\" else \"and \"\r\n  [ for field in ctx.Fields do\r\n      yield makeProperty ctx (prefix + field.Name + \" is\") (FilterBy((field.Name, true, \"!\")::conds)::rest) \r\n      yield makeProperty ctx (prefix + field.Name + \" is not\") (FilterBy((field.Name, false, \"!\")::conds)::rest) \r\n      //|> withDocs (sprintf \"Group by %s\" (field.Name.ToLower()))\r\n      //    ( \"Creates groups based on the value of \" + field.Name + \" and calculte summary \" +\r\n      //      \"values for each group. You can specify a number of summary calculations in the \" + \r\n      //      \"following list:\")\r\n      //|> withCreateAction \"Aggregation operations\" \r\n    if not (List.isEmpty conds) then\r\n      yield makeProperty ctx \"then\" (Empty::FilterBy(conds)::rest) |> withDocs \"\" \"Return the data\" ]\r\n  |> makeObjectType  \r\n\r\nand makePivotTypeImmediate ctx tfs = async {\r\n  let last, rest = match tfs with last::rest -> last, rest | _ -> Empty, []\r\n  let ctx = { ctx with Fields = Transform.transformFields ctx.InputFields (List.rev rest) }\r\n  match last with\r\n  // Starting a new pivoting operation\r\n  | Empty ->\r\n    return\r\n      [ makeProperty ctx \"group data\" (GroupBy([], [])::rest) \r\n          |> withDocs \"\" \"Lets you perform pivot table aggregations.\"\r\n        makeProperty ctx \"filter data\" (FilterBy([])::rest) \r\n          |> withDocs \"\" \"Lets you filter data in the table.\"\r\n        makeProperty ctx \"sort data\" (SortBy([])::rest) \r\n          |> withDocs \"Sort the data\" (\"Specify how the data is sorted. You can choose one or more attributes \" +\r\n              \"to use for sorting in the following list. Choose 'descending' to sort the values from largest value \" +\r\n              \"to smallest value.\")\r\n          |> withCreateAction \"Fields used for sorting\"\r\n        makeProperty ctx \"drop columns\" (DropColumns([])::rest) \r\n          |> withDocs \"Filter returned attributes\" (\"Specify which attributes of the data sets should be returned. \" +\r\n              \"By default you'll get all available attributes, but you can drop uninteresting attributes by listing \" +\r\n              \"them in the following list:\")\r\n          |> withCreateAction \"Dropped ctx.Fields\"\r\n        makeProperty ctx \"paging\" (Paging([])::rest) |> withDocs \"\" \"Take a number of rows or skip a number of rows.\" \r\n        makeProperty ctx \"get series\" (GetSeries(\"!\",\"!\")::rest) |> withDocs \"\" \"Get a single key-value series from the data set.\" \r\n        makeDataMember ctx \"get the data\" rest |> withDocs \"\" \"Returns the transformed data\" ]\r\n      |> makeObjectType    \r\n  // \r\n  | GetSeries(k, v) ->\r\n      return handleGetSeriesRequest ctx rest k v\r\n  | Paging(ops) ->\r\n      let pgid = rest |> Seq.sumBy (function Paging _ -> 1 | _ -> 0) |> sprintf \"pgid-%d\"  \r\n      return handlePagingRequest ctx rest pgid ops\r\n  | SortBy(keys) ->\r\n      return handleSortRequest ctx rest keys\r\n  | DropColumns(dropped) ->\r\n      return handleDropRequest ctx rest dropped\r\n  | FilterBy((fld, eq, \"!\")::conds) ->\r\n      return! handleFilterEqNeqRequest ctx rest (fld, eq) conds\r\n  | FilterBy(conds) ->\r\n      return handleFilterRequest ctx rest conds\r\n  | GroupBy(flds, []) ->\r\n      return handleGroupRequest ctx rest flds\r\n  | GroupBy(flds, aggs) ->\r\n      return handleGroupAggRequest ctx rest flds aggs }\r\n\r\nand makePivotType ctx tfs = \r\n  let guid = Transform.toUrl tfs\r\n  Type.Delayed(\"pivot: \" + guid, Async.AsFuture guid (makePivotTypeImmediate ctx tfs))\r\n  \r\nlet providePivotType root name lookupNamed fields =\r\n  let fields = [ for f, t in fields -> { Name = f; Type = t }]\r\n  let typ = makePivotType { Fields = fields; InputFields = fields; LookupNamed = lookupNamed; Root = root } []\r\n  let ctx = ident(\"_restruntime\")?PivotContext\r\n  ProvidedType.GlobalValue\r\n    ( name, \r\n      NewExpression(ctx, [str (concatUrl root \"data\"); ArrayExpression([], None)], None), typ)\r\n"]}