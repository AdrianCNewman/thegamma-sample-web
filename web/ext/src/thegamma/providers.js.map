{"version":3,"sources":["../../../src/thegamma/providers.fs"],"names":[],"mappings":"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","file":"providers.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿namespace TheGamma.TypePoviders\r\n\r\nopen TheGamma\r\nopen TheGamma.Babel\r\nopen Fable.Import\r\nopen Fable.Extensions\r\n\r\ntype ProvidedType = \r\n  | NamedType of name:string * typars:string list * typ:Type\r\n  | GlobalValue of string * Expression * Type\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// F# provider\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nmodule FSharpProvider = \r\n  type AnyType = \r\n    { kind : string }\r\n\r\n  type GenericParameterType = \r\n    { kind : string \r\n      name : string }\r\n\r\n  type ArrayType = \r\n    { kind : string \r\n      element : AnyType }\r\n\r\n  type PrimitiveType = \r\n    { kind : string \r\n      name : string }\r\n\r\n  type FunctionType = \r\n    { kind : string \r\n      arguments : AnyType[]\r\n      returns : AnyType }\r\n\r\n  type NamedType = \r\n    { kind : string \r\n      name : string\r\n      typargs : AnyType[] }\r\n  \r\n  type Member = \r\n    { kind : string }\r\n\r\n  type Argument = \r\n    { name : string\r\n      optional : bool\r\n      ``type`` : AnyType }\r\n\r\n  type MethodMember = \r\n    { kind : string\r\n      name : string \r\n      typepars : AnyType[]\r\n      arguments:Argument[]\r\n      returns : AnyType }\r\n\r\n  type PropertyMember = \r\n    { kind : string\r\n      name : string \r\n      returns : AnyType }\r\n\r\n  type ExportedType = \r\n    { name : string\r\n      typepars : AnyType[]\r\n      ``static`` : bool \r\n      instance : string[]\r\n      members : Member[] }\r\n\r\n  let provideFSharpTypes lookupNamed url = \r\n\r\n    let rec mapType (t:AnyType) = \r\n      match t.kind with\r\n      | \"primitive\" -> \r\n          let name = (unbox<PrimitiveType> t).name\r\n          if name = \"object\" then Type.Any \r\n          elif name = \"int\" || name = \"float\" then Type.Primitive \"num\"\r\n          else Type.Primitive name\r\n      | \"function\"->\r\n          let t = unbox<FunctionType> t\r\n          Type.Function(List.ofSeq (Array.map mapType t.arguments),mapType t.returns)\r\n      | \"named\" -> \r\n          let t = (unbox<NamedType> t)\r\n          lookupNamed t.name (List.ofArray (Array.map mapType t.typargs))\r\n      | \"parameter\" -> Type.Parameter (unbox<GenericParameterType> t).name\r\n      | \"array\" -> Type.List(mapType (unbox<ArrayType> t).element)\r\n      | _ -> failwith \"provideFSharpType: Unexpected type\"\r\n\r\n    let getTypeParameters typars = \r\n      typars |> Array.map (fun t -> \r\n        match mapType t with\r\n        | Type.Parameter(n) -> n\r\n        | _ -> failwith \"importProvidedType: expected type parameter\") |> List.ofArray\r\n\r\n    // Needs to be delayed to avoid calling lookupNamed too early\r\n    let importProvidedType exp = async {\r\n      let mems = \r\n        exp.members |> Array.choose (fun m ->\r\n          if m.kind = \"method\" then\r\n            let m = unbox<MethodMember> m\r\n            let args = [ for a in m.arguments -> a.name, a.optional, mapType a.``type`` ]\r\n            let emitter = { Emit = fun (inst, args) ->\r\n              // TODO: match arguments based on name or something\r\n              CallExpression\r\n                ( MemberExpression(inst, IdentifierExpression(m.name, None), false, None), \r\n                  List.map snd args, None) }\r\n            Some(Member.Method(m.name, getTypeParameters m.typepars, args, mapType m.returns, Documentation.Text \"\", emitter))\r\n          else None)\r\n\r\n      return Type.Object { Typeargs = List.map Type.Parameter (getTypeParameters exp.typepars); Members = mems } } |> Async.AsFuture exp.name\r\n            \r\n    async {\r\n      let! json = Http.Request(\"GET\", url)\r\n      let expTys = jsonParse<ExportedType[]> json\r\n      return\r\n        [ for exp in expTys ->\r\n            let guid = url + \",\" + exp.name\r\n            let ty = Type.Delayed(guid, importProvidedType exp)\r\n            if exp.``static`` then           \r\n              let e = exp.instance |> Seq.fold (fun chain s -> \r\n                match chain with\r\n                | None -> Some(IdentifierExpression(s, None))\r\n                | Some e -> Some(MemberExpression(e, IdentifierExpression(s, None), false, None)) ) None |> Option.get\r\n              ProvidedType.GlobalValue(exp.name, e, ty)\r\n            else\r\n              ProvidedType.NamedType(exp.name, getTypeParameters exp.typepars, ty) ] }\r\n    \r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// REST provider\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nmodule RestProvider = \r\n\r\n  type AnyType = { kind:string }\r\n  type TypeNested = { kind:string (* = nested *); endpoint:string }\r\n  type TypePrimitive = { kind:string (* = primitive *); ``type``:obj; endpoint:string }\r\n\r\n  [<Fable.Core.Emit(\"typeof($0)\")>]\r\n  let jstypeof (o:obj) : string = failwith \"!\"\r\n\r\n  type Parameter = \r\n    { name : string \r\n      ``type`` : string }\r\n\r\n  type Documentation = \r\n    { title : string option\r\n      details : string option }\r\n\r\n  type Member =\r\n    { name : string\r\n      returns : AnyType\r\n      parameters : Parameter[] option\r\n      documentation : obj option // This can be Documentation or string or an endpoint\r\n      schema : obj option\r\n      trace : string[] }\r\n\r\n  type ResultType = \r\n    | Primitive of string\r\n    | Generic of string * ResultType[]\r\n    | Record of (string * ResultType)[]\r\n\r\n  type RawField = \r\n    { name : string\r\n      ``type`` : obj }\r\n\r\n  type RawResultType = \r\n    { name : string \r\n      fields : RawField[]\r\n      ``params`` : obj[] }\r\n\r\n  let parseDoc (json:obj option) =\r\n    if json.IsNone then Documentation.None\r\n    elif jstypeof json.Value = \"string\" then Documentation.Text(unbox json)\r\n    else \r\n      let doc = unbox<Documentation> json.Value\r\n      match doc.title, doc.details with \r\n      | Some title, Some dets -> Documentation.Details(title, dets)\r\n      | _ -> Documentation.None\r\n\r\n  let rec fromRawType (json:obj) =\r\n    if jstypeof json = \"string\" then Primitive(unbox json)\r\n    else\r\n      let res = unbox<RawResultType> json\r\n      if res.name = \"record\" then res.fields |> Array.map (fun f -> f.name, fromRawType f.``type``) |> Record\r\n      else Generic(res.name, res.``params`` |> Array.map fromRawType)\r\n \r\n  let load url cookies = async {\r\n    let! json = Http.Request(\"GET\", url, cookies=cookies)\r\n    let members = jsonParse<Member[]> json\r\n    return members }\r\n\r\n  let trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\r\n  let trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\r\n\r\n  let concatUrl (a:string) (b:string) =\r\n    (trimRight '/' a) + \"/\" + (trimLeft '/' b)\r\n\r\n  let addTraceCall inst trace =\r\n    if Seq.isEmpty trace then inst \r\n    else\r\n      let trace = StringLiteral(String.concat \"&\" trace, None)    \r\n      let mem = MemberExpression(inst, IdentifierExpression(\"addTrace\", None), false, None)\r\n      CallExpression(mem, [trace], None)\r\n\r\n  let propAccess trace = \r\n    { Emit = fun (inst, _args) -> addTraceCall inst trace }\r\n\r\n  let methCall trace =\r\n    { Emit = fun (inst, args) ->\r\n        let withTrace = addTraceCall inst trace\r\n        args |> Seq.fold (fun inst (name, value) ->\r\n          let trace = BinaryExpression(BinaryPlus, StringLiteral(name + \"=\", None), value, None)\r\n          let mem = MemberExpression(inst, IdentifierExpression(\"addTrace\", None), false, None)\r\n          CallExpression(mem, [trace], None) ) withTrace }\r\n\r\n  let dataCall parser trace endp = \r\n    { Emit = fun (inst, args) ->\r\n        let tr = (propAccess trace).Emit(inst, args) \r\n        let mem = MemberExpression(tr, IdentifierExpression(\"getValue\", None), false, None)\r\n        CallExpression(mem, [StringLiteral(endp, None)], None) |> parser }\r\n\r\n  let ident s = IdentifierExpression(s, None)\r\n  let str v = StringLiteral(v, None)\r\n  let (?) (e:Expression) (s:string) = MemberExpression(e, IdentifierExpression(s, None), false, None)\r\n  let (/@/) (e:Expression) (args) = CallExpression(e, args, None)\r\n  let func v f = \r\n    let body = BlockStatement([ReturnStatement(f (ident v), None)], None)\r\n    FunctionExpression(None, [IdentifierPattern(v, None)], body, false, false, None)\r\n\r\n\r\n  // Turn \"Async<string>\" into the required type\r\n  // I guess we should keep a flag whether the input is still async (or something)\r\n  let rec getTypeAndEmitter (lookupNamed:string -> TheGamma.Type list -> TheGamma.Type) ty = \r\n    match ty with\r\n    | Primitive(\"string\") -> Type.Primitive(\"string\"), id\r\n    | Primitive(\"int\") \r\n    | Primitive(\"float\") -> \r\n        Type.Primitive(\"num\"), \r\n        fun e -> CallExpression(IdentifierExpression(\"Number\", None), [e], None)\r\n    | Generic(\"seq\", [|Generic(\"tuple\", [|t1; t2|])|]) -> \r\n        let t1, e1 = getTypeAndEmitter lookupNamed t1\r\n        let t2, e2 = getTypeAndEmitter lookupNamed t2\r\n        let typ = lookupNamed \"series\" [t1; t2]\r\n        typ, \r\n        fun d -> \r\n          ident(\"_series\")?series?create /@/ \r\n            [ ident(\"_restruntime\")?convertTupleSequence /@/ [func \"v\" e1; func \"v\" e2; d] \r\n              str \"key\"; str \"value\"; str \"\" ] // TODO: We don't have any info - that sucks\r\n    | Generic(\"seq\", [|ty|]) ->\r\n        let elTy, emitter = getTypeAndEmitter lookupNamed ty\r\n        let serTy = lookupNamed \"series\" [Type.Primitive \"num\"; elTy]\r\n        serTy, \r\n        // This is over async, but the child `emitter` is not over async\r\n        fun d -> \r\n          ident(\"_series\")?series?ordinal /@/ \r\n            [ ident(\"_restruntime\")?convertSequence /@/ [func \"v\" emitter; d] \r\n              str \"key\"; str \"value\"; str \"\" ]\r\n    | Record(membs) ->\r\n        let membs = \r\n          membs |> Array.map (fun (name, ty) ->\r\n            let memTy, memConv = getTypeAndEmitter lookupNamed ty\r\n            let emitter = { Emit = fun (inst, _) -> memConv <| inst?(name) }\r\n            Member.Property(name, memTy, None, Documentation.Text \"\", emitter))\r\n        let obj = TheGamma.Type.Object { Members = membs; Typeargs = [] }\r\n        obj, id\r\n    | _ -> \r\n        Browser.console.log(\"getTypeAndEmitter: Cannot handle %O\", ty)\r\n        failwith \"getTypeAndEmitter: Cannot handle type\"\r\n\r\n  [<Fable.Core.Emit(\"$0[$1]\")>]\r\n  let getProperty<'T> (obj:obj) (name:string) : 'T = failwith \"never\"\r\n\r\n  let mapParamType = function\r\n    | \"int\" | \"float\" -> \"num\"\r\n    | _ -> failwith \"mapParamType: Unsupported parameter type\"\r\n\r\n  let restTypeCache = System.Collections.Generic.Dictionary<_, _>()\r\n\r\n  let rec createRestType lookupNamed root cookies url = \r\n    let guid = (concatUrl root url) + cookies\r\n    match restTypeCache.TryGetValue guid with\r\n    | true, res -> res\r\n    | _ ->\r\n      let future = async {\r\n        let! members = load (concatUrl root url) cookies \r\n        return \r\n          Type.Object\r\n            { Typeargs = []\r\n              Members = \r\n                members |> Array.map (fun m ->\r\n                  let schema = m.schema |> Option.map (fun s -> { Type = getProperty s \"@type\"; JSON = s })\r\n                  match m.returns.kind with\r\n                  | \"nested\" ->\r\n                      let returns = unbox<TypeNested> m.returns \r\n                      let retTyp = createRestType lookupNamed root cookies returns.endpoint\r\n                      match m.parameters with \r\n                      | Some parameters ->\r\n                          let args = [ for p in parameters -> p.name, false, Type.Primitive (mapParamType p.``type``)] // TODO: Check this is OK type\r\n                          let argNames = [ for p in parameters -> p.name ]\r\n                          Member.Method(m.name, [], args, retTyp, parseDoc m.documentation, methCall m.trace)\r\n                      | None -> \r\n                          Member.Property(m.name, retTyp, schema, parseDoc m.documentation, propAccess m.trace) \r\n                  | \"primitive\" ->  \r\n                      let returns = unbox<TypePrimitive> m.returns                      \r\n                      let ty = fromRawType returns.``type``\r\n                      let typ, parser = getTypeAndEmitter lookupNamed ty\r\n                      Member.Property(m.name, typ, schema, parseDoc m.documentation, dataCall parser m.trace returns.endpoint)\r\n                  | _ -> failwith \"?\" ) } }\r\n      let ty = Type.Delayed(guid, Async.AsFuture guid future)\r\n      restTypeCache.[guid] <- ty\r\n      ty\r\n\r\n  let rec provideRestType lookupNamed name root cookies = \r\n    let ctx = ident(\"_restruntime\")?RuntimeContext\r\n    ProvidedType.GlobalValue\r\n      ( name, \r\n        NewExpression(ctx, [str root; str cookies; str \"\"], None),\r\n        createRestType lookupNamed root cookies \"/\")\r\n\r\n  // ------------------------------------------------------------------------------------------------\r\n  //\r\n  // ------------------------------------------------------------------------------------------------\r\n  (*\r\n  let nada = { Emit = fun (inst, args) -> Babel.NullLiteral(None) }\r\n\r\n  let rec seriesTy() = \r\n    { new Future<_> with\r\n        member x.Then(f) = \r\n          Type.Object \r\n            { Members = \r\n              [ Member.Method(\"sortValues\", [\"reverse\", Type.Primitive \"bool\"], seriesTy (), nada)\r\n                Member.Method(\"take\", [\"count\", Type.Primitive \"num\"], seriesTy (), nada) ] } |> f } |> Type.Delayed\r\n\r\n  let worldTy = \r\n    Type.Object\r\n      { Members = \r\n          [ Member.Property(\"CO2 emissions (kt)\", seriesTy (), nada) ] }\r\n\r\n        *)"]}