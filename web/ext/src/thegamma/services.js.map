{"version":3,"sources":["../../../src/thegamma/services.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA,oDAgBK;AAAA;;AAAA;;AAAc;AAAS;AAC1B,2BAAoB,sBAApB;AAiBA,mBAAY,kCACV;AAAgC;AAAA;AAAA;AAAA,oCAC9B;AAAA,qCAAW,eAAX,EACM;AAAA,sDAMF,iDACE;AAAA;;AACA,wBAAG,4BAAH,EAA6B;AAAA,0EAAJ;AAAA;AAAA,uBAAI;AAAW,qBAAxC;AAAA;AAAwB;AAAgB,mBAF1C,GAIE;AAAA;;AAAA;AAA0C,mBAJ5C,kBAKA;AAAA,+CAAQ,8BAAR;AAAA,mBALA,EANE,8BAaF,iBAAG,aAAH,GACE,gCACE;AAAA;;AACA,wBAAG,4BAAH,EAA6B;AAAA,0EAAJ;AAAA;AAAA,uBAAI;AAAW,qBAAxC;AAAA;AAAwB;AAAgB,mBAF1C,GAIE;AAAA;;AAAA;AAA0C,mBAJ5C,CADF,mCAMA;AAAA,+CAAQ,sBAAW,WAAX,CAAR;AAAA,mBANA,EAbE,GAEF;AAAA,qBACsC;AAAA;AAAoB,qBAD1D;AAAA,8CAAQ;AAAA,+CAAI,6BAAJ,EACA;AAAA,qCAAW,qDAAX;AAAA;AAAwB,yBADxB;AAAA,uBAAR;AAAA;;AAEA,+CAAQ,eAAe,WAAf,CAAR;AAAiC,mBAFjC,EAFE;AAAA,iBADN;AAAA,eAD8B;AAAA;AAAA;AAAA;;AAsBhC;AAAS,OAvBC,CAAZ;AAlBgB;;;;sDA4Cd;AAAA,YAAG,yCAAH,EAAgC;AAAA,0BAAW,4CAAX;AAA0B,SAA1D,MACK;AAAA,0BAAW,yCAAX;AAAuB;AAAA;;;mCA3CZ;AAAA;;AAAA;AAAA,gCAChB;AAAA;;AACA,iCAAqB,oBAArB,EAEA;AAAA;;AACA,mCAAW,0BAAc;AAAA;AAAA,eAAd,gBAAX,EACI;AAAa;AAAA;AAAA;;AAKZ,sDAAS;AAAA;AAAA,iBAAT,EAFA,uBAC6F;AAAA,0BAArF,sBAA6B;AAAA,6DAAU,oEAAV;AAAA,mBAA7B,MAAqF;AAAA,iBAD7F,MAEA;;AAEL;;AACA;;AAAA;AARO,eADP;AASiC,aAZjC;AAYiC,WAdjB;AAAA;AAAK;;;;;;;;;;;;;;AAlBzB;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AA6EQ;AAAA;AAAA,oCAGE,yBAHF,GAEU,iBAAkB,SAAlB,EAA4B,uBAA5B,eAFV;AAAA;;AAAA;AAAA,UACY,oBADZ,EACY;AADZ;AAAA;AACyB;AAAJ,OADrB,MACY;AAAA;AAAS;AADd,KAAP;AAAA;AAAO;AAAA;;AAMb;AAAA,yBAAU,uCAAV,EACQ,uCADR;AAC8C;;;AApFhD,+CAsFK;AAAA;;AAAA;;AACH,4BAAqB,sBAArB;AAEA,mBAAY,kCACV;AAAmC;AAAA;AAAA;AAAA,oCACjC;AAAA,qCAAW,eAAX,EACM;AAAA,sDAWuB,4BAXvB,GAWuB;AAXvB;AAAA;AAYF;AAAA;;AACA;AACA,iDAAQ,0BAAR;AAAgC;AAHQ,mBAAf,EAXvB,gCAiBF;AAAA;;AACA,yCAAe,sDAAf,EACA;AAAA,6DACE;AAAA;;AACA,6CAAsB,mDAAtB,EACA;AAAA;;AAEkD,4DAAmB;AAAA;AAAA,2BAAnB,EAAhB,sBAApB,2BAAoB,CAAgB;;AAC3B,2DACrB;AAAA,uEAAkD,4BAAlD;AAAA,2BADqB;;AAGvB;;AANA,wCAOc,mBAPd;;AAQA;;AACA,qDAAQ,6BAAR;AAAwB,yBAVxB;AAUwB,uBAZ1B,GAcE;AAAA;;AACA,sDAAmB,kBAAnB;;AACA,mDAAQ,0BAAR;AAAgC,uBAhBlC;AAAA,qBADA;AAiBkC,mBAlBlC,EAjBE;AAAA;AAAG,mBAAH;AAAA;AAAA;AAEF,yCAAe,sDAAf,EACA;AAAA,8EACE;AAAA,6CAAsB,wCAAtB,EACA;AAAA,qCAAW,qBAAX;AAAA;AAA0B,yBAD1B;AAAA,uBADF,GAIE;AAAA;;AACA;AAAA;AAAiB,uBALnB,kBAMA;AAAA,mDAAQ,0BAAR;AAAA,uBANA;AAAA,qBADA;AAFK,mBAAH;AAAA,iBADN;AAAA,eADiC;AAAA;AAAA;AAAA;;AAsCnC,gCAAgB,kBAAhB;AAA0B,OAvChB,CAAZ;AAHkB;;;;sCA6CS;AAAA,4CAAkC;AAAA;AAAA,SAAlC;AAAsD;;;wCACpD;AAAA,4CAAkC;AAAA;AAAA,SAAlC;AAAwD;;;kCA5CrE;AAAA,gCAAS,qBAAT,EAAqB,oBAArB;AAA6C","file":"services.js","sourceRoot":"c:/tomas/public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Services\r\n\r\nopen Fable.Import\r\nopen Fable.Extensions\r\nopen TheGamma.Html\r\nopen TheGamma.Editors\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Editors\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype EditorWorkerMessage = \r\n  | Update of string\r\n  | UpdateNow of string\r\n  | Refersh of string\r\n\r\ntype EditorService(article, checker, delay) = \r\n  let renderEditors = Control.Event<_>()\r\n  let update text = async {\r\n    Log.event(\"options\", \"update\", article, text)\r\n    let! (_:bool), prg = checker text \r\n        \r\n    Log.trace(\"service\", \"Collecting editors\")\r\n    let! eds = Async.collect collectCmdEditors prg.Body \r\n    let eds = eds |> List.mapi (fun i v -> i, v)\r\n    let filteredEds = \r\n      eds \r\n      |> List.filter (fun (i, ed1) ->\r\n          eds |> List.exists (fun (j, ed2) -> j <> i && Ranges.strictSubRange ed1.Range ed2.Range) |> not)\r\n      |> List.map snd\r\n\r\n    Log.trace(\"service\", \"Rendering %s out of %s\", filteredEds.Length, eds.Length)\r\n    renderEditors.Trigger filteredEds }\r\n\r\n  let agent = MailboxProcessor.Start(fun inbox ->\r\n    let rec loop lastText pending = async {\r\n      let! msg = inbox.Receive()\r\n      match msg with\r\n      | Update text -> \r\n          async { do! Async.Sleep(delay)\r\n                  inbox.Post(Refersh text) } |> Async.StartImmediate\r\n          return! loop lastText (pending+1)\r\n      | UpdateNow text ->\r\n          try\r\n            Log.trace(\"editors\", \"updating...\")\r\n            if text <> lastText then do! update text\r\n          with e -> \r\n            Log.exn(\"editors\", \"update failed: %O\", e)\r\n          return! loop text pending\r\n      | Refersh text ->\r\n          if pending = 1 then \r\n            try\r\n              Log.trace(\"editors\", \"updating...\")\r\n              if text <> lastText then do! update text\r\n            with e -> \r\n              Log.exn(\"editors\", \"update failed: %O\", e)\r\n          return! loop text (pending-1) }\r\n    loop \"\" 0)\r\n\r\n  member x.UpdateSource(text, ?immediately) = \r\n    if immediately = Some true then agent.Post(UpdateNow text)\r\n    else agent.Post(Update text)\r\n  member x.EditorsUpdated = renderEditors.Publish\r\n\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Type checker\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype CheckingMessage = \r\n  | TypeCheck of code:string * AsyncReplyChannel<bool * Program<Type>>\r\n  | IsWellTyped of code:string * AsyncReplyChannel<bool>\r\n\r\ntype Position = { Line:int; Column:int }\r\ntype LineRange = { Start:Position; End:Position }\r\n\r\nlet rec offsetToLocation lines offs lengths =\r\n  match lengths with\r\n  | l::lengths when offs <= l -> { Line = lines; Column = offs }\r\n  | l::lengths -> offsetToLocation (lines+1) (offs-l-1) lengths\r\n  | [] -> { Line = lines; Column = offs  } // error? out of range\r\n\r\nlet rangeToLoc lengths (rng:Range) = \r\n  { Start = offsetToLocation 1 rng.Start lengths\r\n    End = offsetToLocation 1 rng.Start lengths }\r\n\r\ntype CheckingService(article, globals) =\r\n  let errorsReported = Control.Event<_>()\r\n  let emptyProg = { Body = []; Range = { Start = 0; End = 0 } }\r\n  let agent = MailboxProcessor.Start(fun inbox ->\r\n    let rec loop lastCode lastResult = async {\r\n      let! msg = inbox.Receive()\r\n      match msg with\r\n      | IsWellTyped(code, repl) ->\r\n          let! globals = Async.AwaitFuture globals\r\n          try\r\n            let! errors, result = TypeChecker.typeCheck globals code\r\n            repl.Reply(errors.IsEmpty)\r\n          with e ->\r\n            Log.exn(\"service\", \"Type checking failed: %O\", e)\r\n            repl.Reply(false)\r\n          return! loop lastCode lastResult\r\n\r\n      | TypeCheck(code, repl) when code = lastCode ->\r\n          Log.trace(\"service\", \"Returning previous result\")\r\n          repl.Reply(lastResult)\r\n          return! loop lastCode lastResult\r\n\r\n      | TypeCheck(code, repl) ->\r\n          Log.trace(\"service\", \"Type checking source code\")\r\n          let! globals = Async.AwaitFuture globals\r\n          try\r\n            Log.event(\"compiler\", \"check-source\", article, code)\r\n            let! errors, result = TypeChecker.typeCheck globals code\r\n            Log.trace(\"service\", \"Type checking completed\")\r\n\r\n            let lengths = code.Split('\\n') |> Array.toList |> List.map (fun l -> l.Length)\r\n            let errors = errors |> List.map (fun e -> \r\n              { Number = e.Number; Message = e.Message; Range = rangeToLoc lengths e.Range })\r\n\r\n            errorsReported.Trigger(code, errors)\r\n            let result = (List.isEmpty errors, result)\r\n            repl.Reply(result) \r\n            return! loop code result\r\n          with e ->\r\n            Log.exn(\"service\", \"Type checking failed: %O\", e)\r\n            repl.Reply((false, emptyProg))\r\n            return! loop lastCode lastResult }\r\n    loop \"\" (false, emptyProg))\r\n\r\n  member x.ErrorsReported = errorsReported.Publish\r\n  member x.TypeCheck(code) = agent.PostAndAsyncReply(fun ch -> TypeCheck(code, ch))\r\n  member x.IsWellTyped(code) = agent.PostAndAsyncReply(fun ch -> IsWellTyped(code, ch))\r\n\r\n"]}