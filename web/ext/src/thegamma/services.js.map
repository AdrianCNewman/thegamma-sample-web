{"version":3,"sources":["../../../src/thegamma/services.fs"],"names":[],"mappings":"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","file":"services.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Services\r\n\r\nopen Fable.Import\r\n\r\nopen TheGamma.Html\r\nopen TheGamma.Editors\r\nopen TheGamma.Common\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Editors\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype EditorWorkerMessage = \r\n  | Update of string\r\n  | UpdateNow of string\r\n  | Refersh of string\r\n\r\ntype EditorService(article, checker:string -> Async<bool * Binder.BindingResult * Program>, delay) = \r\n  let renderEditors = Control.Event<_>()\r\n  let update text = async {\r\n    Log.event(\"options\", \"update\", article, text)\r\n    let! _, _, prg = checker text \r\n        \r\n    Log.trace(\"service\", \"Collecting editors\")\r\n    let! eds = Async.collect collectCmdEditors prg.Body.Node\r\n    let eds = eds |> List.mapi (fun i v -> i, v)\r\n    let filteredEds = \r\n      eds \r\n      |> List.filter (fun (i, ed1) ->\r\n          eds |> List.exists (fun (j, ed2) -> j <> i && Ast.strictSubRange ed1.Range ed2.Range) |> not)\r\n      |> List.map snd\r\n\r\n    Log.trace(\"service\", \"Rendering %s out of %s\", filteredEds.Length, eds.Length)\r\n    renderEditors.Trigger filteredEds }\r\n\r\n  let agent = MailboxProcessor.Start(fun inbox ->\r\n    let rec loop lastText pending = async {\r\n      let! msg = inbox.Receive()\r\n      match msg with\r\n      | Update text -> \r\n          async { do! Async.Sleep(delay)\r\n                  inbox.Post(Refersh text) } |> Async.StartImmediate\r\n          return! loop lastText (pending+1)\r\n      | UpdateNow text ->\r\n          try\r\n            Log.trace(\"editors\", \"updating...\")\r\n            if text <> lastText then do! update text\r\n          with e -> \r\n            Log.exn(\"editors\", \"update failed: %O\", e)\r\n          return! loop text pending\r\n      | Refersh text ->\r\n          if pending = 1 then \r\n            try\r\n              Log.trace(\"editors\", \"updating...\")\r\n              if text <> lastText then do! update text\r\n            with e -> \r\n              Log.exn(\"editors\", \"update failed: %O\", e)\r\n          return! loop text (pending-1) }\r\n    loop \"\" 0)\r\n\r\n  member x.UpdateSource(text, ?immediately) = \r\n    if immediately = Some true then agent.Post(UpdateNow text)\r\n    else agent.Post(Update text)\r\n  member x.EditorsUpdated = renderEditors.Publish\r\n\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Type checker\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype CheckingMessage = \r\n  | TypeCheck of code:string * AsyncReplyChannel<bool * Binder.BindingResult * Program>\r\n  | IsWellTyped of code:string * AsyncReplyChannel<bool>\r\n\r\ntype Position = { Line:int; Column:int }\r\ntype LineRange = { Start:Position; End:Position }\r\n\r\nlet rec offsetToLocation lines offs lengths =\r\n  match lengths with\r\n  | l::lengths when offs <= l -> { Line = lines; Column = offs }\r\n  | l::lengths -> offsetToLocation (lines+1) (offs-l-1) lengths\r\n  | [] -> { Line = lines; Column = offs  } // error? out of range\r\n\r\nlet rangeToLoc lengths (rng:Range) = \r\n  { Start = offsetToLocation 1 rng.Start lengths\r\n    End = offsetToLocation 1 rng.Start lengths }\r\n\r\ntype CheckingService(article, globals:Future<Entity list>) =\r\n  let errorsReported = Control.Event<_>()\r\n  let emptyProg = { Body = Ast.node { Start = 0; End = 0 } [] }\r\n  let bindingContext =  \r\n    async { \r\n      let! globals = globals |> Async.AwaitFuture\r\n      return Binder.createContext globals article } |> Async.StartAsFuture\r\n\r\n  let errorsToLineCol (code:string) errors = \r\n    let lengths = code.Split('\\n') |> Array.toList |> List.map (fun l -> l.Length)\r\n    errors |> Array.map (fun e -> \r\n      { Number = e.Number; Message = e.Message; Range = rangeToLoc lengths e.Range })\r\n\r\n  let typeCheck code = async {\r\n    let! globals = Async.AwaitFuture globals\r\n    try\r\n      let progSyntax, parseErrors = Parser.parseProgram code\r\n      let! bindingContext = bindingContext |> Async.AwaitFuture\r\n      let progEntity, boundEntities = Binder.bindProgram bindingContext progSyntax\r\n      do! TypeChecker.typeCheckProgram globals boundEntities progEntity\r\n      let typeErrors = TypeChecker.collectTypeErrors progEntity\r\n      Log.trace(\"service\", \"Type checking completed\")\r\n      let errors = errorsToLineCol code (Array.append parseErrors typeErrors)\r\n      return Some(progSyntax, boundEntities, errors)\r\n    with e ->\r\n      Log.exn(\"service\", \"Type checking failed: %O\", e)\r\n      return None }\r\n\r\n  let agent = MailboxProcessor.Start(fun inbox ->\r\n    let rec loop lastCode lastResult = async {\r\n      let! msg = inbox.Receive()\r\n      match msg with\r\n      | IsWellTyped(code, repl) ->\r\n          let! tc = typeCheck code\r\n          match tc with \r\n          | Some(_, _, errs) when errs.Length = 0 -> repl.Reply(true)\r\n          | _ -> repl.Reply(false)\r\n          return! loop lastCode lastResult\r\n\r\n      | TypeCheck(code, repl) when code = lastCode ->\r\n          Log.trace(\"service\", \"Returning previous result\")\r\n          repl.Reply(lastResult)\r\n          return! loop lastCode lastResult\r\n\r\n      | TypeCheck(code, repl) ->\r\n          Log.trace(\"service\", \"Type checking source code\")\r\n          let! tc = typeCheck code\r\n          match tc with \r\n          | Some(prog, ents, errors) ->\r\n              errorsReported.Trigger(code, errors)            \r\n              let result = (errors.Length = 0, ents, prog)\r\n              repl.Reply(result)\r\n              return! loop code result\r\n          | None -> \r\n              repl.Reply((false, Binder.BindingResult [||], emptyProg))\r\n              return! loop lastCode lastResult }\r\n    \r\n    loop \"\" (false, Binder.BindingResult [||], emptyProg))\r\n\r\n  member x.ErrorsReported = errorsReported.Publish\r\n  member x.TypeCheck(code) = agent.PostAndAsyncReply(fun ch -> TypeCheck(code, ch))\r\n  member x.IsWellTyped(code) = agent.PostAndAsyncReply(fun ch -> IsWellTyped(code, ch))\r\n\r\n"]}