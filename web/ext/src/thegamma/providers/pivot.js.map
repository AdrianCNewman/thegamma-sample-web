{"version":3,"sources":["../../../../src/thegamma/providers/pivot.fs"],"names":[],"mappings":"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","file":"pivot.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.TypeProviders.Pivot\r\n\r\nopen Fable.Core\r\nopen Fable.Import\r\n\r\nopen TheGamma\r\nopen TheGamma.Babel\r\nopen TheGamma.Common\r\nopen TheGamma.TypePoviders\r\n\r\n// ----------------------------------------------------------------------------\r\n// Operations that we can do on the table\r\n// ----------------------------------------------------------------------------\r\n\r\ntype Aggregation = \r\n  | GroupKey\r\n  | CountAll\r\n  | CountDistinct of string\r\n  | ReturnUnique of string\r\n  | ConcatValues of string\r\n  | Sum of string\r\n  | Mean of string\r\n\r\ntype SortDirection =\r\n  | Ascending\r\n  | Descending \r\n\r\ntype Paging =\r\n  | Take of string\r\n  | Skip of string\r\n  \r\ntype Transformation = \r\n  | DropColumns of string list\r\n  | SortBy of (string * SortDirection) list\r\n  | GroupBy of string list * Aggregation list\r\n  | FilterBy of (string * bool * string) list\r\n  | Paging of Paging list\r\n  | GetSeries of string * string\r\n  | GetTheData\r\n  | Empty\r\n\r\ntype Field = \r\n  { Name : string \r\n    Type : PrimitiveType }\r\n\r\nmodule Transform = \r\n\r\n  let private formatAgg = function\r\n    | GroupKey -> [\"key\"]\r\n    | CountAll -> [\"count-all\"]\r\n    | CountDistinct(f) -> [\"count-dist\"; f]\r\n    | ReturnUnique(f) -> [\"unique\"; f]\r\n    | ConcatValues(f) -> [\"concat-vals\"; f]\r\n    | Sum(f) -> [\"sum\"; f]\r\n    | Mean(f) -> [\"mean\"; f]\r\n\r\n  let toUrl transforms = \r\n    [ for t in List.rev transforms ->\r\n        match t with\r\n        | GetTheData -> [\"data\"]\r\n        | FilterBy(conds) -> \"filter\"::(List.collect (fun (f,b,v) -> [f; (if b then \"eq\" else \"neq\"); v]) conds)\r\n        | DropColumns(columns) -> \"drop\"::columns\r\n        | SortBy(columns) -> \"sort\"::(List.collect (fun (c, o) -> [c; (if o = Ascending then \"asc\" else \"desc\")]) columns)\r\n        | GroupBy(flds, aggs) -> \"group\"::((List.map (fun f -> \"by-\" + f) flds) @ (List.collect formatAgg aggs))\r\n        | Paging(ops) -> \"page\"::(List.collect (function Take k -> [\"take\"; k] | Skip k -> [\"skip\"; k]) ops)\r\n        | GetSeries(k, v) -> \"series\"::k::v::[]\r\n        | Empty -> [] ]\r\n    |> List.mapi (fun i l -> if i = 0 then l else \"then\"::l)\r\n    |> List.concat\r\n    |> String.concat \"/\"\r\n\r\n  let singleTransformFields fields = function\r\n    | Empty -> fields\r\n    | GetTheData -> fields\r\n    | SortBy _ -> fields\r\n    | Paging _ -> fields\r\n    | FilterBy _ -> fields\r\n    | GetSeries(k, v) -> \r\n        [ fields |> List.find (fun f -> f.Name = k)\r\n          fields |> List.find (fun f -> f.Name = v) ]\r\n    | DropColumns(drop) ->\r\n        let dropped = set drop\r\n        fields |> List.filter (fun f -> not(dropped.Contains f.Name))\r\n    | GroupBy(flds, aggs) ->\r\n        let oldFields = dict [ for f in fields -> f.Name, f ]\r\n        aggs \r\n        |> List.collect (function\r\n           | GroupKey -> List.map (fun f -> oldFields.[f]) flds\r\n           | ReturnUnique fld\r\n           | ConcatValues fld\r\n           | Sum fld -> [ oldFields.[fld] ]\r\n           | Mean fld -> [ oldFields.[fld] ]\r\n           | CountAll -> [ { Name = \"count\"; Type = PrimitiveType.Number } ]\r\n           | CountDistinct fld -> [ { Name = oldFields.[fld].Name; Type = PrimitiveType.Number } ])\r\n      \r\n  let transformFields fields tfs = \r\n    tfs |> List.fold singleTransformFields (List.ofSeq fields)\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Pivot provider\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nopen TheGamma.TypePoviders.ProviderHelpers\r\n\r\nlet trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\r\nlet trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\r\n\r\nlet concatUrl (a:string) (b:string) =\r\n  (trimRight '/' a) + \"/\" + (trimLeft '/' b)\r\n\r\nlet makeObjectType members = \r\n  { Members = Array.ofSeq members } |> Type.Object\r\n\r\nlet isNumeric fld = fld = PrimitiveType.Number\r\nlet isConcatenable fld = fld = PrimitiveType.String\r\n\r\n// From providers.fs\r\nlet ident s = IdentifierExpression(s, None)\r\nlet str v = StringLiteral(v, None)\r\nlet bool v = BooleanLiteral(v, None)\r\nlet arr l = ArrayExpression(l, None)\r\n\r\nlet (?) (e:Expression) (s:string) = MemberExpression(e, IdentifierExpression(s, None), false, None)\r\nlet (/?/) (e:Expression) a = MemberExpression(e, a, true, None)\r\n\r\nlet (/@/) (e:Expression) (args) = CallExpression(e, args, None)\r\nlet func v f = \r\n  let body = BlockStatement([ReturnStatement(f (ident v), None)], None)\r\n  FunctionExpression(None, [IdentifierPattern(v, None)], body, false, false, None)\r\n\r\nlet getTypeAndEmitter = function \r\n  | PrimitiveType.String -> Type.Primitive(PrimitiveType.String), id\r\n  | PrimitiveType.Number -> Type.Primitive(PrimitiveType.Number), fun e -> ident \"Number\" /@/ [e]\r\n  | PrimitiveType.Bool -> Type.Primitive(PrimitiveType.Number), fun e -> ident \"Boolean\" /@/ [e]\r\n  | PrimitiveType.Unit -> Type.Primitive(PrimitiveType.Unit), fun e -> NullLiteral(None)\r\n\r\nlet propertyEmitter = \r\n  { Emit = fun (this, _) -> this }\r\n\r\nlet makeMethodEmitter callid pars =\r\n  { Emit = fun (this, args) -> \r\n      let args = arr [ for v in args -> v ]\r\n      this?addCall /@/ [str callid; args] }\r\n\r\nlet makeDataEmitter isPreview isSeries tfs = \r\n  { Emit = fun (this, _) -> \r\n      // TODO: This is not properly recursively transforming values, but they're just int/string, so it's OK\r\n      if isSeries then\r\n        ident(\"_series\")?series?create /@/ \r\n          [ this?getData /@/ [str (Transform.toUrl (List.rev tfs)); bool isPreview]\r\n            str \"key\"; str \"value\"; str \"\" ]\r\n      else\r\n        ident(\"_series\")?series?ordinal /@/ \r\n          [ this?getData /@/ [str (Transform.toUrl (List.rev tfs)); bool isPreview]\r\n            str \"key\"; str \"value\"; str \"\" ] }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Transformations\r\n// ----------------------------------------------------------------------------\r\n\r\ntype Context = \r\n  { Root : string\r\n    LookupNamed : string -> Type list -> Type\r\n    InputFields : Field list\r\n    Fields : Field list }\r\n\r\nlet rec makeProperty ctx name tfs = \r\n  let meta1 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box tfs  }\r\n  let meta2 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box ctx.Fields  }\r\n  Member.Property(name, makePivotType ctx tfs, [meta1; meta2], propertyEmitter)\r\n  \r\nand makeMethod ctx name tfs callid args = \r\n  let meta1 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box tfs  }\r\n  let meta2 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box ctx.Fields  }\r\n  Member.Method\r\n    ( name, [ for n, t in args -> n, false, Type.Primitive t ], makePivotType ctx tfs, \r\n      [meta1; meta2], makeMethodEmitter callid args )\r\n\r\nand makeDataMember ctx name isPreview tfs =\r\n  let fields = Transform.transformFields ctx.InputFields (List.rev tfs)\r\n  let dataTyp, isSeries = \r\n    match tfs with \r\n    | (GetSeries _)::_ -> \r\n        match ctx.Fields with\r\n        | [kf; vf] ->  \r\n            ctx.LookupNamed \"series\" [Type.Primitive kf.Type; Type.Primitive vf.Type], true\r\n        | _ -> failwith \"makeDataMember: Series should have key and value\"\r\n    | _ -> \r\n        let membs = \r\n          fields |> Array.ofSeq |> Array.map (fun fld ->\r\n            let memTy, memConv = getTypeAndEmitter fld.Type\r\n            let emitter = { Emit = fun (inst, _) -> memConv <| (inst /?/ str fld.Name) }\r\n            Member.Property(fld.Name, memTy, [docMeta (Documentation.Text \"\")], emitter))\r\n        let recTyp = Type.Object { Members = membs }\r\n        ctx.LookupNamed \"series\" [Type.Primitive PrimitiveType.Number; recTyp ], false\r\n\r\n  let meta1 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box (GetTheData::tfs ) }\r\n  let meta2 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box ctx.Fields  }\r\n  Member.Property(name, dataTyp, [meta1; meta2], makeDataEmitter isPreview isSeries tfs)\r\n\r\nand handleGetSeriesRequest ctx rest k v = \r\n  match k, v with\r\n  | \"!\", \"!\" ->\r\n    [ for field in ctx.Fields ->\r\n        makeProperty ctx (\"with key \" + field.Name) (GetSeries(field.Name, \"!\")::rest) ]\r\n    |> makeObjectType\r\n  | k, \"!\" ->\r\n    [ for field in ctx.Fields ->\r\n        makeDataMember ctx (\"and value \" + field.Name) false (GetSeries(k, field.Name)::rest) ]\r\n    |> makeObjectType\r\n  | _ -> \r\n    failwith \"handleGetSeriesRequest: Should not happen\"\r\n  \r\nand handlePagingRequest ctx rest pgid ops =\r\n  let takeMemb = \r\n    makeMethod ctx \"take\" (Empty::Paging(List.rev (Take(pgid + \"-take\")::ops))::rest) (pgid + \"-take\") [\"count\", PrimitiveType.Number] \r\n  let skipMemb = \r\n    makeMethod ctx \"skip\" (Paging(Skip(pgid + \"-skip\")::ops)::rest) (pgid + \"-skip\") [\"count\", PrimitiveType.Number] \r\n  let thenMemb = \r\n    makeProperty ctx \"then\" (Empty::Paging(List.rev ops)::rest)\r\n  ( match ops with\r\n    | [] -> [skipMemb; takeMemb; thenMemb]\r\n    | [Skip _] -> [takeMemb; thenMemb]\r\n    | _ -> failwith \"handlePagingRequest: Shold not happen\" ) |> makeObjectType\r\n\r\nand handleDropRequest ctx rest dropped = \r\n  let droppedFields = set dropped\r\n  [ yield makeProperty ctx \"then\" (Empty::DropColumns(dropped)::rest)\r\n    for field in ctx.Fields do\r\n      if not (droppedFields.Contains field.Name) then\r\n        yield \r\n          makeProperty ctx (\"drop \" + field.Name) (DropColumns(field.Name::dropped)::rest) ]\r\n  |> makeObjectType    \r\n\r\nand handleSortRequest ctx rest keys = \r\n  let usedKeys = set (List.map fst keys)\r\n  [ yield makeProperty ctx \"then\" (Empty::SortBy(keys)::rest)\r\n    for field in ctx.Fields do\r\n      if not (usedKeys.Contains field.Name) then\r\n        let doc = sprintf \"Use the field '%s' as the next sorting keys\" field.Name\r\n        let prefix = if keys = [] then \"by \" else \"and by \"\r\n        yield makeProperty ctx (prefix + field.Name) (SortBy((field.Name, Ascending)::keys)::rest) \r\n        yield makeProperty ctx (prefix + field.Name + \" descending\") (SortBy((field.Name, Descending)::keys)::rest) ]\r\n  |> makeObjectType    \r\n\r\n\r\nand aggregationMembers ctx rest keys aggs = \r\n  let containsCountAll = aggs |> Seq.exists ((=) CountAll)\r\n  let containsField fld = aggs |> Seq.exists (function \r\n    | CountDistinct f | ReturnUnique f | ConcatValues f | Sum f | Mean f -> f = fld | CountAll | GroupKey -> false)\r\n  let makeAggMember name agg = \r\n    makeProperty ctx name (GroupBy(keys,agg::aggs)::rest) \r\n\r\n  [ yield makeProperty ctx \"then\" (Empty::GroupBy(keys, aggs)::rest) \r\n    if not containsCountAll then \r\n      yield makeAggMember \"count all\" CountAll\r\n    for fld in ctx.Fields do\r\n      if not (containsField fld.Name) then\r\n        yield makeAggMember (\"count distinct \" + fld.Name) (CountDistinct fld.Name) \r\n        yield makeAggMember (\"return unique \" + fld.Name) (ReturnUnique fld.Name) \r\n        if isConcatenable fld.Type then\r\n          yield makeAggMember (\"concatenate values of \" + fld.Name) (ConcatValues fld.Name)\r\n        if isNumeric fld.Type then\r\n          yield makeAggMember (\"average \" + fld.Name) (Mean fld.Name)\r\n          yield makeAggMember (\"sum \" + fld.Name) (Sum fld.Name) ]\r\n\r\nand handleGroupAggRequest ctx rest keys aggs =\r\n  aggregationMembers ctx rest keys aggs  \r\n  |> makeObjectType  \r\n  \r\nand handleGroupRequest ctx rest keys = \r\n  let prefix = if List.isEmpty keys then \"by \" else \"and \"\r\n  [ for field in ctx.Fields ->\r\n      makeProperty ctx (prefix + field.Name) (GroupBy(field.Name::keys, [])::rest) \r\n    if not (List.isEmpty keys) then\r\n      yield! aggregationMembers ctx rest keys [GroupKey] ]\r\n  |> makeObjectType  \r\n\r\nand handleFilterEqNeqRequest ctx rest (fld, eq) conds = async {\r\n  let url = concatUrl (concatUrl ctx.Root \"range\") (FilterBy(conds)::rest |> List.rev |> Transform.toUrl)\r\n  let! options = Http.Request(\"GET\", url + \"?\" + fld)\r\n  let options = jsonParse<string[]> options\r\n  return\r\n    [ for opt in options do\r\n        yield makeProperty ctx opt (FilterBy((fld, eq, opt)::conds)::rest) ] \r\n    |> makeObjectType }\r\n\r\nand handleFilterRequest ctx rest conds = \r\n  let prefix = if List.isEmpty conds then \"\" else \"and \"\r\n  [ for field in ctx.Fields do\r\n      yield makeProperty ctx (prefix + field.Name + \" is\") (FilterBy((field.Name, true, \"!\")::conds)::rest) \r\n      yield makeProperty ctx (prefix + field.Name + \" is not\") (FilterBy((field.Name, false, \"!\")::conds)::rest) \r\n      //|> withDocs (sprintf \"Group by %s\" (field.Name.ToLower()))\r\n      //    ( \"Creates groups based on the value of \" + field.Name + \" and calculte summary \" +\r\n      //      \"values for each group. You can specify a number of summary calculations in the \" + \r\n      //      \"following list:\")\r\n      //|> withCreateAction \"Aggregation operations\" \r\n    if not (List.isEmpty conds) then\r\n      yield makeProperty ctx \"then\" (Empty::FilterBy(conds)::rest) ]\r\n  |> makeObjectType  \r\n\r\nand makePivotTypeImmediate ctx tfs = async {\r\n  let last, rest = match tfs with last::rest -> last, rest | _ -> Empty, []\r\n  let ctx = { ctx with Fields = Transform.transformFields ctx.InputFields (List.rev rest) }\r\n  match last with\r\n  // Starting a new pivoting operation\r\n  | Empty ->\r\n    return\r\n      [ makeProperty ctx \"group data\" (GroupBy([], [])::rest) \r\n        makeProperty ctx \"filter data\" (FilterBy([])::rest) \r\n        makeProperty ctx \"sort data\" (SortBy([])::rest) \r\n        makeProperty ctx \"drop columns\" (DropColumns([])::rest) \r\n        makeProperty ctx \"paging\" (Paging([])::rest) \r\n        makeProperty ctx \"get series\" (GetSeries(\"!\",\"!\")::rest) \r\n        makeDataMember ctx \"get the data\" false rest ]\r\n      |> makeObjectType    \r\n  // \r\n  | GetSeries(k, v) ->\r\n      return handleGetSeriesRequest ctx rest k v\r\n  | Paging(ops) ->\r\n      let pgid = rest |> Seq.sumBy (function Paging _ -> 1 | _ -> 0) |> sprintf \"pgid-%d\"  \r\n      return handlePagingRequest ctx rest pgid ops\r\n  | SortBy(keys) ->\r\n      return handleSortRequest ctx rest keys\r\n  | DropColumns(dropped) ->\r\n      return handleDropRequest ctx rest dropped\r\n  | FilterBy((fld, eq, \"!\")::conds) ->\r\n      return! handleFilterEqNeqRequest ctx rest (fld, eq) conds\r\n  | FilterBy(conds) ->\r\n      return handleFilterRequest ctx rest conds\r\n  | GroupBy(flds, []) ->\r\n      return handleGroupRequest ctx rest flds\r\n  | GroupBy(flds, aggs) ->\r\n      return handleGroupAggRequest ctx rest flds aggs \r\n  | GetTheData ->\r\n      return failwith \"makePivotTypeImmediate: Get the data shouldn't be of pivot type\" }\r\n\r\nand adjustForPreview tfs = \r\n  match tfs with\r\n  | GroupBy([], _)::tfs -> tfs // We do not yet know the grouping key, so return original data\r\n  | GroupBy(k, [])::tfs -> GroupBy(k, [GroupKey])::tfs // We do not have any aggregations yet\r\n  | _ -> tfs\r\n\r\nand withPreview ctx tfs typ = \r\n  match typ with\r\n  | Type.Object(o) -> \r\n      let preview = makeDataMember ctx \"preview\" true (adjustForPreview tfs)\r\n      Type.Object { o with Members = Array.append [| preview |] o.Members }\r\n  | typ -> failwith \"withPreview: Expected object type\"\r\n\r\nand makePivotType ctx tfs = \r\n  let guid = Transform.toUrl tfs\r\n  let typ = async {\r\n    let! typ = makePivotTypeImmediate ctx tfs\r\n    return withPreview ctx tfs typ }\r\n  Type.Delayed(\"pivot: \" + guid, Async.CreateNamedFuture guid typ)\r\n  \r\nlet providePivotType root name lookupNamed fields =\r\n  let fields = [ for f, t in fields -> { Name = f; Type = t }]\r\n  let typ = makePivotType { Fields = fields; InputFields = fields; LookupNamed = lookupNamed; Root = root } []\r\n  let ctx = ident(\"_runtime\")?PivotContext\r\n  let meta1 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box []  }\r\n  let meta2 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box fields  }\r\n  ProvidedType.GlobalValue\r\n    ( name, [meta1; meta2],\r\n      NewExpression(ctx, [str (concatUrl root \"data\"); ArrayExpression([], None)], None), typ)\r\n"]}