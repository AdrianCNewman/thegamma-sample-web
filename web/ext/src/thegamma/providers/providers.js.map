{"version":3,"sources":["../../../../src/thegamma/providers/providers.fs"],"names":[],"mappings":"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","file":"providers.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿namespace TheGamma.TypePoviders\r\n\r\nopen TheGamma\r\nopen TheGamma.Babel\r\nopen TheGamma.Common\r\nopen Fable.Import\r\n\r\ntype ProvidedType = \r\n  | NamedType of name:string * typars:string list * typ:Type\r\n  | GlobalValue of string * Metadata list * Expression * Type\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// F# provider\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nmodule ProviderHelpers = \r\n  let docMeta doc = \r\n    { Context = \"http://thegamma.net\"\r\n      Type = \"Documentation\"\r\n      Data = box doc }\r\n\r\nopen ProviderHelpers\r\n\r\nmodule FSharpProvider = \r\n  type AnyType = \r\n    { kind : string }\r\n\r\n  type GenericParameterType = \r\n    { kind : string \r\n      name : string }\r\n\r\n  type ArrayType = \r\n    { kind : string \r\n      element : AnyType }\r\n\r\n  type PrimitiveType = \r\n    { kind : string \r\n      name : string }\r\n\r\n  type FunctionType = \r\n    { kind : string \r\n      arguments : AnyType[]\r\n      returns : AnyType }\r\n\r\n  type NamedType = \r\n    { kind : string \r\n      name : string\r\n      typargs : AnyType[] }\r\n  \r\n  type Member = \r\n    { kind : string }\r\n\r\n  type Argument = \r\n    { name : string\r\n      optional : bool\r\n      ``type`` : AnyType }\r\n\r\n  type MethodMember = \r\n    { kind : string\r\n      name : string \r\n      typepars : AnyType[]\r\n      arguments:Argument[]\r\n      returns : AnyType }\r\n\r\n  type PropertyMember = \r\n    { kind : string\r\n      name : string \r\n      returns : AnyType }\r\n\r\n  type ExportedType = \r\n    { name : string\r\n      typepars : AnyType[]\r\n      ``static`` : bool \r\n      instance : string[]\r\n      members : Member[] }\r\n\r\n  let provideFSharpTypes lookupNamed url = \r\n\r\n    let rec mapType (t:AnyType) = \r\n      match t.kind with\r\n      | \"primitive\" -> \r\n          match (unbox<PrimitiveType> t).name with\r\n          | \"object\" -> Type.Any \r\n          | \"int\" | \"float\" -> Type.Primitive PrimitiveType.Number\r\n          | \"string\" -> Type.Primitive PrimitiveType.String\r\n          | \"bool\" -> Type.Primitive PrimitiveType.Bool\r\n          | \"unit\" -> Type.Primitive PrimitiveType.Unit\r\n          | t -> failwith (\"provideFSharpType: Unsupported type: \" + t)\r\n      | \"function\"->\r\n          let t = unbox<FunctionType> t\r\n          Type.Function(List.ofSeq (Array.map mapType t.arguments),mapType t.returns)\r\n      | \"named\" -> \r\n          let t = (unbox<NamedType> t)\r\n          lookupNamed t.name (List.ofArray (Array.map mapType t.typargs))\r\n      | \"parameter\" -> Type.Parameter (unbox<GenericParameterType> t).name\r\n      | \"array\" -> Type.List(mapType (unbox<ArrayType> t).element)\r\n      | _ -> failwith \"provideFSharpType: Unexpected type\"\r\n\r\n    let getTypeParameters typars = \r\n      typars |> Array.map (fun t -> \r\n        match mapType t with\r\n        | Type.Parameter(n) -> n\r\n        | _ -> failwith \"importProvidedType: expected type parameter\") |> List.ofArray\r\n\r\n    // Needs to be delayed to avoid calling lookupNamed too early\r\n    let importProvidedType exp = async {\r\n      let mems = \r\n        exp.members |> Array.choose (fun m ->\r\n          if m.kind = \"method\" then\r\n            let m = unbox<MethodMember> m\r\n            let args = [ for a in m.arguments -> a.name, a.optional, mapType a.``type`` ]\r\n            let emitter = { Emit = fun (inst, args) ->\r\n              CallExpression\r\n                ( MemberExpression(inst, IdentifierExpression(m.name, None), false, None), \r\n                  args, None) }\r\n            \r\n            let typ = \r\n              match getTypeParameters m.typepars with\r\n              | [] -> mapType m.returns\r\n              | pars -> Type.Forall(pars, mapType m.returns)\r\n\r\n            Some(Member.Method(m.name, args, typ, [docMeta (Documentation.Text \"\")], emitter))\r\n          else None)\r\n\r\n      match getTypeParameters exp.typepars with\r\n      | [] -> return Type.Object { Members = mems }\r\n      | typars ->\r\n          let obj = Type.Object { Members = mems }\r\n          return Type.Forall(typars, obj) } |> Async.CreateNamedFuture exp.name\r\n            \r\n    async {\r\n      let! json = Http.Request(\"GET\", url)\r\n      let expTys = jsonParse<ExportedType[]> json\r\n      return\r\n        [ for exp in expTys ->\r\n            let guid = url + \",\" + exp.name\r\n            let ty = Type.Delayed(guid, importProvidedType exp)\r\n            if exp.``static`` then           \r\n              let e = exp.instance |> Seq.fold (fun chain s -> \r\n                match chain with\r\n                | None -> Some(IdentifierExpression(s, None))\r\n                | Some e -> Some(MemberExpression(e, IdentifierExpression(s, None), false, None)) ) None |> Option.get\r\n              let ty = \r\n                match getTypeParameters exp.typepars with \r\n                | [] -> ty\r\n                | tya -> Type.App(ty, [for v in tya -> Type.Any])\r\n              ProvidedType.GlobalValue(exp.name, [], e, ty)\r\n            else\r\n              ProvidedType.NamedType(exp.name, getTypeParameters exp.typepars, ty) ] }\r\n    \r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// REST provider\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nmodule RestProvider = \r\n\r\n  type AnyType = { kind:string }\r\n  type TypeNested = { kind:string (* = nested *); endpoint:string }\r\n  type TypePrimitive = { kind:string (* = primitive *); ``type``:obj; endpoint:string }\r\n\r\n  [<Fable.Core.Emit(\"typeof($0)\")>]\r\n  let jstypeof (o:obj) : string = failwith \"!\"\r\n\r\n  type Parameter = \r\n    { name : string \r\n      ``type`` : string }\r\n\r\n  type Documentation = \r\n    { title : string option\r\n      details : string option }\r\n\r\n  type Member =\r\n    { name : string\r\n      returns : AnyType\r\n      parameters : Parameter[] option\r\n      documentation : obj option // This can be Documentation or string or an endpoint\r\n      schema : obj option\r\n      trace : string[] }\r\n\r\n  type ResultType = \r\n    | Primitive of string\r\n    | Generic of string * ResultType[]\r\n    | Record of (string * ResultType)[]\r\n\r\n  type RawField = \r\n    { name : string\r\n      ``type`` : obj }\r\n\r\n  type RawResultType = \r\n    { name : string \r\n      fields : RawField[]\r\n      ``params`` : obj[] }\r\n\r\n  let parseDoc (json:obj option) =\r\n    if json.IsNone then Documentation.None\r\n    elif jstypeof json.Value = \"string\" then Documentation.Text(unbox json)\r\n    else \r\n      let doc = unbox<Documentation> json.Value\r\n      match doc.title, doc.details with \r\n      | Some title, Some dets -> Documentation.Details(title, dets)\r\n      | _ -> Documentation.None\r\n\r\n  let rec fromRawType (json:obj) =\r\n    if jstypeof json = \"string\" then Primitive(unbox json)\r\n    else\r\n      let res = unbox<RawResultType> json\r\n      if res.name = \"record\" then res.fields |> Array.map (fun f -> f.name, fromRawType f.``type``) |> Record\r\n      else Generic(res.name, res.``params`` |> Array.map fromRawType)\r\n \r\n  let load url cookies = async {\r\n    let! json = Http.Request(\"GET\", url, cookies=cookies)\r\n    let members = jsonParse<Member[]> json\r\n    return members }\r\n\r\n  let trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\r\n  let trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\r\n\r\n  let concatUrl (a:string) (b:string) =\r\n    (trimRight '/' a) + \"/\" + (trimLeft '/' b)\r\n\r\n  let addTraceCall inst trace =\r\n    if Seq.isEmpty trace then inst \r\n    else\r\n      let trace = StringLiteral(String.concat \"&\" trace, None)    \r\n      let mem = MemberExpression(inst, IdentifierExpression(\"addTrace\", None), false, None)\r\n      CallExpression(mem, [trace], None)\r\n\r\n  let propAccess trace = \r\n    { Emit = fun (inst, _args) -> addTraceCall inst trace }\r\n\r\n  let methCall argNames trace =\r\n    { Emit = fun (inst, args) ->\r\n        let withTrace = addTraceCall inst trace\r\n        Seq.zip argNames args |> Seq.fold (fun inst (name, value) ->\r\n          let trace = BinaryExpression(BinaryPlus, StringLiteral(name + \"=\", None), value, None)\r\n          let mem = MemberExpression(inst, IdentifierExpression(\"addTrace\", None), false, None)\r\n          CallExpression(mem, [trace], None) ) withTrace }\r\n\r\n  let dataCall parser trace endp = \r\n    { Emit = fun (inst, args) ->\r\n        let tr = (propAccess trace).Emit(inst, args) \r\n        let mem = MemberExpression(tr, IdentifierExpression(\"getValue\", None), false, None)\r\n        CallExpression(mem, [StringLiteral(endp, None)], None) |> parser }\r\n\r\n  let ident s = IdentifierExpression(s, None)\r\n  let str v = StringLiteral(v, None)\r\n  let (?) (e:Expression) (s:string) = MemberExpression(e, IdentifierExpression(s, None), false, None)\r\n  let (/@/) (e:Expression) (args) = CallExpression(e, args, None)\r\n  let func v f = \r\n    let body = BlockStatement([ReturnStatement(f (ident v), None)], None)\r\n    FunctionExpression(None, [IdentifierPattern(v, None)], body, false, false, None)\r\n\r\n\r\n  // Turn \"Async<string>\" into the required type\r\n  // I guess we should keep a flag whether the input is still async (or something)\r\n  let rec getTypeAndEmitter (lookupNamed:string -> TheGamma.Type list -> TheGamma.Type) ty = \r\n    match ty with\r\n    | Primitive(\"string\") -> Type.Primitive(PrimitiveType.String), id\r\n    | Primitive(\"int\") \r\n    | Primitive(\"float\") -> \r\n        Type.Primitive(PrimitiveType.Number), \r\n        fun e -> CallExpression(IdentifierExpression(\"Number\", None), [e], None)\r\n    | Generic(\"seq\", [|Generic(\"tuple\", [|t1; t2|])|]) -> \r\n        let t1, e1 = getTypeAndEmitter lookupNamed t1\r\n        let t2, e2 = getTypeAndEmitter lookupNamed t2\r\n        let typ = lookupNamed \"series\" [t1; t2]\r\n        typ, \r\n        fun d -> \r\n          ident(\"_series\")?series?create /@/ \r\n            [ ident(\"_runtime\")?convertTupleSequence /@/ [func \"v\" e1; func \"v\" e2; d] \r\n              str \"key\"; str \"value\"; str \"\" ] // TODO: We don't have any info - that sucks\r\n    | Generic(\"seq\", [|ty|]) ->\r\n        let elTy, emitter = getTypeAndEmitter lookupNamed ty\r\n        let serTy = lookupNamed \"series\" [Type.Primitive PrimitiveType.Number; elTy]\r\n        serTy, \r\n        // This is over async, but the child `emitter` is not over async\r\n        fun d -> \r\n          ident(\"_series\")?series?ordinal /@/ \r\n            [ ident(\"_runtime\")?convertSequence /@/ [func \"v\" emitter; d] \r\n              str \"key\"; str \"value\"; str \"\" ]\r\n    | Record(membs) ->\r\n        let membs = \r\n          membs |> Array.map (fun (name, ty) ->\r\n            let memTy, memConv = getTypeAndEmitter lookupNamed ty\r\n            let emitter = { Emit = fun (inst, _) -> memConv <| inst?(name) }\r\n            Member.Property(name, memTy, [docMeta(Documentation.Text \"\")], emitter))\r\n        let obj = TheGamma.Type.Object { Members = membs }\r\n        obj, id\r\n    | _ -> \r\n        Browser.console.log(\"getTypeAndEmitter: Cannot handle %O\", ty)\r\n        failwith \"getTypeAndEmitter: Cannot handle type\"\r\n\r\n  [<Fable.Core.Emit(\"$0[$1]\")>]\r\n  let getProperty<'T> (obj:obj) (name:string) : 'T = failwith \"never\"\r\n\r\n  let mapParamType = function\r\n    | \"int\" | \"float\" -> PrimitiveType.Number\r\n    | _ -> failwith \"mapParamType: Unsupported parameter type\"\r\n\r\n  let restTypeCache = System.Collections.Generic.Dictionary<_, _>()\r\n\r\n  let rec createRestType lookupNamed root cookies url = \r\n    let guid = (concatUrl root url) + cookies\r\n    match restTypeCache.TryGetValue guid with\r\n    | true, res -> res\r\n    | _ ->\r\n      let future = async {\r\n        let! members = load (concatUrl root url) cookies \r\n        return \r\n          Type.Object\r\n            { Members = \r\n                members |> Array.map (fun m ->\r\n                  let schema = \r\n                    match m.schema with\r\n                    | Some s -> [{ Type = getProperty s \"@type\"; Context = \"http://schema.org\"; Data = s }]\r\n                    | _ -> []\r\n                  match m.returns.kind with\r\n                  | \"nested\" ->\r\n                      let returns = unbox<TypeNested> m.returns \r\n                      let retTyp = createRestType lookupNamed root cookies returns.endpoint\r\n                      match m.parameters with \r\n                      | Some parameters ->\r\n                          let args = [ for p in parameters -> p.name, false, Type.Primitive (mapParamType p.``type``)] // TODO: Check this is OK type\r\n                          let argNames = [ for p in parameters -> p.name ]\r\n                          Member.Method(m.name, args, retTyp, [docMeta (parseDoc m.documentation)], methCall argNames m.trace)\r\n                      | None -> \r\n                          Member.Property(m.name, retTyp, (docMeta (parseDoc m.documentation))::schema, propAccess m.trace) \r\n                  | \"primitive\" ->  \r\n                      let returns = unbox<TypePrimitive> m.returns                      \r\n                      let ty = fromRawType returns.``type``\r\n                      let typ, parser = getTypeAndEmitter lookupNamed ty\r\n                      Member.Property(m.name, typ, (docMeta (parseDoc m.documentation))::schema, dataCall parser m.trace returns.endpoint)\r\n                  | _ -> failwith \"?\" ) } }\r\n      let ty = Type.Delayed(guid, Async.CreateNamedFuture guid future)\r\n      restTypeCache.[guid] <- ty\r\n      ty\r\n\r\n  let rec provideRestType lookupNamed name root cookies = \r\n    let ctx = ident(\"_runtime\")?RuntimeContext\r\n    ProvidedType.GlobalValue\r\n      ( name, [],\r\n        NewExpression(ctx, [str root; str cookies; str \"\"], None),\r\n        createRestType lookupNamed root cookies \"/\")\r\n\r\n  // ------------------------------------------------------------------------------------------------\r\n  //\r\n  // ------------------------------------------------------------------------------------------------\r\n  (*\r\n  let nada = { Emit = fun (inst, args) -> Babel.NullLiteral(None) }\r\n\r\n  let rec seriesTy() = \r\n    { new Future<_> with\r\n        member x.Then(f) = \r\n          Type.Object \r\n            { Members = \r\n              [ Member.Method(\"sortValues\", [\"reverse\", Type.Primitive \"bool\"], seriesTy (), nada)\r\n                Member.Method(\"take\", [\"count\", Type.Primitive \"num\"], seriesTy (), nada) ] } |> f } |> Type.Delayed\r\n\r\n  let worldTy = \r\n    Type.Object\r\n      { Members = \r\n          [ Member.Property(\"CO2 emissions (kt)\", seriesTy (), nada) ] }\r\n\r\n        *)"]}