{"version":3,"sources":["../../../../src/thegamma/codegen/runtime.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIoC;AAAA;AAAA,4BAClC;AAAA,mCACA;AAAA,iCAAiB;AAAA,oBAAyB,eAAzB,EAA8B,eAA9B;AAAA,YAAjB;AAAA,SADA;AAAA,OADkC;AAAA;AAAK;;AAIZ;AAAA;AAAA,4BAC3B;AAAA,mCACA;AAAA,iCAAiB;AAAA;AAAA,WAAV,OAAP;AAAA,SADA;AAAA,OAD2B;AAAA;AAAK;;AAIwC;AAAA,WAA3B,oCAAkB;AAAA;AAAA,KAAlB,EAAnB,WAAmB,EAA2B;AAAa;;AACc;AAAA,WAAxC,oCAAkB;AAAA;AAAA,KAAlB,EAAhC,WAAmB,UAAa,EAA2B,UAAa;AAAa;;AAGhH;AAAA,WAAC,iBAAD,SAA2B,gBAA3B;AAA0C;;;AAhB5C,kDAkBK;AAAA;;AAAe;AAAa;AAAgB;AAA9B;;kEAKX;AAAA;;AACF,yCAAE;AAAA,qCAAG,CAAK,kDAAR,GAAyC,2CAAzC,2BACA;AAAA,iBAAG,CAAK,uCAAR,GAA0C,gCAA1C;AAAA,UADA;AAAA,QAAF;;AAEF,+DAA8B,mCAA9B;AAHU,K;;oEAMV;AAAA;;AAAA;AAAA,8BACE;AAAA,+BAAW,6BAAqB,sCAArB,qCAAX,EAEA;AAAA;AAAA,WAFA;AAAA,SADF;AAAA;AAAK,K;;;;;;;;;;;;;;;;;;;;AA7BT,uCAkCK;AAAA;;AAAa;AAAM;AAAP;;sEAEb;AAAA,yCAAmB,qCAAnB;AAA2D,K;;sEACnB;AAAA;;AAAA;AAAA,8BACpC;AAAM,oBAAS;AACjB;AAAA;AAAA,oBAAG,yBAAH,EAAyB;AAAA;AAAsD;;AAC/E,sEAAgB,yCAAhB;AAAgC,eADhC;AAAA;;AADiB;AAAA;AAAA;AAAA;AAAA;AAEoB,WAFpB,EAAT;;AAGV,oDAAkC,2BAAlC;;AACU,kCAAmB,2BAAD,aAAlB,GAAyD,2BAAzD;AACV,+BAAW,kCAAX,EACA;AAAA;AAAA,WADA;AALO,SADiC;AAAA;AAAK,K","file":"runtime.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.TypePovidersRuntime\r\nopen System\r\nopen TheGamma.Common\r\n\r\nlet convertTupleSequence f g data = async {\r\n  let! values = data\r\n  return values |> Array.map (fun (a, b) -> f a, g b) }\r\n\r\nlet convertSequence f data = async {\r\n  let! values = data\r\n  return values |> Array.map f }\r\n\r\nlet trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\r\nlet trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\r\n\r\nlet concatUrl (a:string) (b:string) =\r\n  (trimRight '/' a) + \"/\" + (trimLeft '/' b)\r\n\r\ntype RuntimeContext(root:string, cookies:string, trace:string) = \r\n  member x.root = root\r\n  member x.trace = trace\r\n  \r\n  member x.addTrace(suffix) = \r\n    let traces = \r\n      [ if not (String.IsNullOrEmpty trace) then yield trace\r\n        if not (String.IsNullOrEmpty suffix) then yield suffix ]\r\n    RuntimeContext(root, cookies, String.concat \"&\" traces)\r\n  \r\n  member x.getValue(endpoint:string) =     \r\n    async { \r\n      let! res = Http.Request(\"POST\", concatUrl root endpoint, trace, cookies)\r\n      // TODO: This is wrong - it may return an integer too!\r\n      return jsonParse<obj> res }\r\n\r\ntype PivotContext(root, calls) = \r\n  member x.addCall(callid:string, values:obj[]) =\r\n    PivotContext(root, Array.append [| callid, values |] calls)\r\n  member x.getData(tfs:string, isPreview) = async {\r\n    let url = calls |> Array.fold (fun (tfs:string) (id, vals) -> \r\n      if vals.Length <> 1 then failwith \"PivotContext.getData: Expected one argument\"\r\n      tfs.Replace(id, string vals.[0])) tfs\r\n    Log.trace(\"runtime\", \"Pivot: %s\", concatUrl root url)\r\n    let url = if isPreview then (concatUrl root url) + \"?preview\" else concatUrl root url\r\n    let! res = Http.Request(\"GET\", url)\r\n    return jsonParse<obj> res }\r\n"]}