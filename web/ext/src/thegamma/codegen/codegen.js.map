{"version":3,"sources":["../../../../src/thegamma/codegen/codegen.fs"],"names":[],"mappings":"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","file":"codegen.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.CodeGenerator\r\n\r\nopen TheGamma\r\nopen TheGamma.Babel\r\nopen TheGamma.Common\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Compiling code to Babel AST\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype CompilationContext =\r\n  { LineLengths : int list\r\n    Globals : Map<string, Expression> }\r\n\r\nlet rec offsetToLocation lines offs lengths =\r\n  match lengths with\r\n  | l::lengths when offs <= l -> { line = lines; column = offs }\r\n  | l::lengths -> offsetToLocation (lines+1) (offs-l-1) lengths\r\n  | [] -> { line = lines; column = offs  } // error? out of range\r\n\r\nlet rangeToLoc ctx rng = \r\n  Some { start = offsetToLocation 1 rng.Start ctx.LineLengths \r\n         ``end`` = offsetToLocation 1 rng.Start ctx.LineLengths }\r\n\r\nlet rec getEmitterAndParams name typ = \r\n  match Types.reduceType typ with\r\n  | Type.Object(o) -> \r\n      o.Members |> Seq.pick (function \r\n        | Member.Method(name=n; arguments=args; emitter=e) when n = name -> Some(e, args)\r\n        | Member.Property(name=n; emitter=e) when n=name -> Some(e, []) \r\n        | _ -> None) \r\n  | t -> \r\n    Log.exn(\"codegen\", \"getEmitterAndParams: Not an object %O\", t)\r\n    failwith \"getEmitterAndParams: Not an object\" \r\n\r\nlet rec compileExpression ctx (expr:Node<Expr>) = \r\n  match expr.Node with \r\n  | Expr.Binary(l, { Node = Operator.Power }, r) ->\r\n      let l = compileExpression ctx l\r\n      let r = compileExpression ctx r\r\n      let rng = rangeToLoc ctx expr.Range\r\n      let pow = MemberExpression(IdentifierExpression(\"pow\", rng), IdentifierExpression(\"Math\", rng), false, rng)\r\n      CallExpression(pow, [l; r], rangeToLoc ctx expr.Range)\r\n\r\n  | Expr.Binary(l, op, r) ->\r\n      let l = compileExpression ctx l\r\n      let r = compileExpression ctx r\r\n      let op = \r\n        match op.Node with\r\n        | Operator.Equals -> BinaryEqualStrict\r\n        | Operator.Plus -> BinaryPlus\r\n        | Operator.Minus -> BinaryMinus\r\n        | Operator.Multiply -> BinaryMultiply\r\n        | Operator.Divide -> BinaryDivide\r\n        | Operator.GreaterThan -> BinaryGreater\r\n        | Operator.LessThan -> BinaryLess\r\n        | Operator.GreaterThanOrEqual -> BinaryGreaterOrEqual\r\n        | Operator.LessThanOrEqual -> BinaryLessOrEqual\r\n        | Operator.Power -> failwith \"compileExpression: Power is not a binary operation\"\r\n      BinaryExpression(op, l, r, rangeToLoc ctx expr.Range)\r\n      \r\n  | Expr.Call(Some inst, n, args) ->\r\n      // Split arguments between position & name based\r\n      let compiledArgs = args.Node |> List.map (fun a -> a.Name, compileExpression ctx a.Value)\r\n      let positionArgs = compiledArgs |> Seq.takeWhile (fun (n, _) -> n.IsNone) |> Seq.map snd |> Array.ofSeq\r\n      let namedArgs = compiledArgs |> Seq.choose (function (Some n, a) -> Some(n.Node.Name, a) | _ -> None) |> dict\r\n\r\n      // Compile the instance\r\n      let emitter, pars = getEmitterAndParams n.Node.Name inst.Entity.Value.Type.Value\r\n      let inst = compileExpression ctx inst\r\n      let pars = pars |> List.mapi (fun i (name, _, _) ->\r\n        if i < positionArgs.Length then positionArgs.[i]\r\n        elif namedArgs.ContainsKey name then namedArgs.[name]\r\n        else NullLiteral(rangeToLoc ctx args.Range))\r\n      emitter.Emit(inst, pars)\r\n\r\n  | Expr.Call(None, n, args) ->\r\n      failwith \"compileExpression: Call without instance is not supported\"\r\n\r\n  | Expr.Property(inst, n) ->\r\n      let emitter, _ = getEmitterAndParams n.Node.Name inst.Entity.Value.Type.Value\r\n      let inst = compileExpression ctx inst\r\n      emitter.Emit(inst, [])\r\n      \r\n  //| Expr.Null ->\r\n    //  NullLiteral(rangeToLoc ctx expr.Range)\r\n  | Expr.Number(n) ->\r\n      NumericLiteral(n, rangeToLoc ctx expr.Range)\r\n  | Expr.String(s) ->\r\n      StringLiteral(s, rangeToLoc ctx expr.Range)\r\n  | Expr.Boolean(b) ->\r\n      BooleanLiteral(b, rangeToLoc ctx expr.Range)\r\n  | Expr.Variable(n) when ctx.Globals.ContainsKey(n.Node.Name) ->\r\n      ctx.Globals.[n.Node.Name]\r\n  | Expr.Variable(n) ->\r\n      IdentifierExpression(n.Node.Name, rangeToLoc ctx n.Range) \r\n  | Expr.List(es) ->\r\n      let es = List.map (compileExpression ctx) es\r\n      ArrayExpression(es, rangeToLoc ctx expr.Range)\r\n  | Expr.Function(n, e) ->\r\n      let var = IdentifierExpression(n.Node.Name, rangeToLoc ctx n.Range)\r\n      let ce = compileExpression { ctx with Globals = Map.add n.Node.Name var ctx.Globals } e\r\n      let body = BlockStatement([ReturnStatement(ce, rangeToLoc ctx e.Range)], rangeToLoc ctx e.Range)\r\n      FunctionExpression(None, [IdentifierPattern(n.Node.Name, rangeToLoc ctx n.Range)], body, false, false, rangeToLoc ctx expr.Range)\r\n  | Expr.Empty ->      \r\n      Fable.Import.Browser.console.log(\"compileExpression: %O\", expr.Node) \r\n      failwith \"!\" \r\n    \r\n\r\nlet compileCommand ctx (cmd:Node<Command>) = \r\n  match cmd.Node with\r\n  | Command.Let(n, e) ->\r\n      let e = compileExpression ctx e\r\n      let name = IdentifierPattern(n.Node.Name, rangeToLoc ctx n.Range)\r\n      let decl = VariableDeclarator(name, Some e, rangeToLoc ctx cmd.Range)\r\n      VariableDeclaration(Var, [decl], rangeToLoc ctx cmd.Range)\r\n  | Command.Expr(e) ->\r\n      let e = compileExpression ctx e\r\n      ExpressionStatement(e, rangeToLoc ctx cmd.Range)\r\n\r\nlet compileProgram ctx (prog:TheGamma.Program) = \r\n  let body = List.map (compileCommand ctx) prog.Body.Node\r\n  { location = rangeToLoc ctx prog.Body.Range; body = body }\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Running compiled ASTs\r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype BabelOptions = \r\n  { presets : string[] }\r\n\r\ntype BabelResult = \r\n  { code : string }\r\ntype Babel =\r\n  abstract transformFromAst : obj * string * BabelOptions -> BabelResult\r\n\r\n[<Emit(\"Babel\")>]\r\nlet babel : Babel = Unchecked.defaultof<_> \r\n\r\nlet compileAndRun globals (text:string) prog = async {\r\n  try\r\n    let! globals = Async.AwaitFuture globals\r\n    let ctx = { LineLengths = [ for l in text.Split('\\n') -> l.Length ]; Globals = globals }  \r\n    let res = compileProgram ctx prog\r\n    let code = babel.transformFromAst(Serializer.serializeProgram res, text, { presets = [| \"es2015\" |] })\r\n    Log.trace(\"codegen\", \"Evaluating: %O\", code)\r\n    return code.code;\r\n  with e ->\r\n    Log.exn(\"codegen\", \"Evaluating code failed: %O\", e)\r\n    return \"\" }\r\n"]}