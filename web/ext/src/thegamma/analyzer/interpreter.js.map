{"version":3,"sources":["../../../../src/thegamma/analyzer/interpreter.fs"],"names":[],"mappings":"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","file":"interpreter.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.Interpreter\r\n\r\nopen TheGamma\r\nopen TheGamma.Ast\r\nopen TheGamma.Common\r\nopen TheGamma.Babel\r\nopen System.Collections.Generic\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// \r\n// ------------------------------------------------------------------------------------------------\r\n\r\n[<Emit(\"eval($0)\")>]\r\nlet eval (s:string) : RuntimeValue = failwith \"JS only\"\r\n\r\ntype BabelOptions = \r\n  { presets : string[] }\r\n\r\ntype BabelResult = \r\n  { code : string }\r\ntype Babel =\r\n  abstract transformFromAst : obj * string * BabelOptions -> BabelResult\r\n\r\n[<Emit(\"Babel\")>]\r\nlet babel : Babel = Unchecked.defaultof<_> \r\n\r\n\r\n\r\n\r\n// Above copy paste from CodeGen\r\n\r\ntype EvaluationContext =\r\n  { Globals : IDictionary<string, Entity> }\r\n\r\nlet (|FindProperty|_|) (name:Name) { Members = membs } = \r\n  membs |> Seq.tryPick (function \r\n    Member.Property(name=n; emitter=e) when n = name.Name -> Some(e) | _ -> None) \r\n\r\nlet (|FindMethod|_|) (name:Name) { Members = membs } = \r\n  membs |> Seq.tryPick (function \r\n    Member.Method(name=n; arguments=args; emitter=e) when n = name.Name -> Some(args, e) | _ -> None) \r\n\r\nlet storeArguments values =\r\n  values |> Array.ofList, \r\n  values |> List.mapi (fun i _ ->\r\n    MemberExpression\r\n      ( IdentifierExpression(\"_stored\", None),\r\n        NumericLiteral(float i, None), true, None ))\r\n\r\nlet evaluateExpression (_stored:RuntimeValue[]) (expr:Expression) =\r\n  let prog = { Babel.Program.location = None; Babel.Program.body = [ExpressionStatement(expr, None)] }\r\n  let code = babel.transformFromAst(Serializer.serializeProgram prog, \"\", { presets = [| \"es2015\" |] })\r\n  Log.trace(\"interpreter\", \"Interpreter evaluating: %O\", code.code)\r\n  try\r\n    // Get fable to reference everything\r\n    let s = TheGamma.Series.series<int, int>.create(async { return [||] }, \"\", \"\", \"\") \r\n    TheGamma.TypePovidersRuntime.RuntimeContext(\"lol\", \"\", \"troll\") |> ignore\r\n    TheGamma.TypePovidersRuntime.trimLeft |> ignore\r\n    TheGamma.GoogleCharts.chart.bar |> ignore\r\n    TheGamma.table<int, int>.create(s) |> ignore\r\n    TheGamma.Maps.timeline<int, int>.create(s) |> ignore\r\n    TheGamma.Series.series<int, int>.values([| 1 |]) |> ignore    \r\n    \r\n    // The name `_stored` may appear in the generated code!\r\n    _stored.Length |> ignore\r\n\r\n    eval(code.code)\r\n  with e ->\r\n    Log.exn(\"interpreter\", \"Evaluation failed: %O\", e)\r\n    reraise()\r\n\r\nlet evaluateExpr args exprBuilder =\r\n  let _stored, args = storeArguments args\r\n  evaluateExpression _stored (exprBuilder args)\r\n\r\nlet evaluateCall emitter inst args =\r\n  let _stored, args = storeArguments (inst::args)\r\n  evaluateExpression _stored (emitter.Emit(List.head args, List.tail args))\r\n\r\nlet evaluatePreview typ value = \r\n  let previewName = {Name.Name=\"preview\"}\r\n  match typ with\r\n  | Some(Type.Object(FindProperty previewName e)) -> Some(evaluateCall e value [])\r\n  | _ -> None\r\n\r\nlet rec ensureValue ctx (e:Entity) = \r\n  if e.Value.IsNone then\r\n    match evaluateEntity ctx e with\r\n    | Some value ->\r\n        e.Value <- Some { Value = value; Preview = evaluatePreview e.Type value }\r\n    | _ -> ()\r\n\r\nand getValue ctx (e:Entity) = \r\n  if e.Value.IsNone then Log.error(\"interpreter\", \"getValue: Value of entity %O has not been evaluated.\", e)\r\n  e.Value.Value.Value\r\n\r\nand evaluateEntity ctx (e:Entity) = \r\n  match e.Kind with\r\n  | EntityKind.Constant(Constant.Boolean b) -> Some(unbox b)\r\n  | EntityKind.Constant(Constant.Number n) -> Some(unbox n)\r\n  | EntityKind.Constant(Constant.String s) -> Some(unbox s)\r\n  | EntityKind.Constant(Constant.Empty) -> Some(unbox null)\r\n\r\n  | EntityKind.GlobalValue(name, expr) ->\r\n      match expr with\r\n      | Some expr -> Some(evaluateExpression [| |] expr)\r\n      | _ -> None\r\n      \r\n  | EntityKind.ChainElement(isProperty=true; name=name; instance=Some inst) ->\r\n      match Types.reduceType inst.Type.Value with \r\n      | Type.Object(FindProperty name e) -> \r\n          Some(evaluateCall e (getValue ctx inst) [])\r\n      | _ -> None\r\n\r\n  | EntityKind.ChainElement\r\n      ( isProperty=false; name=name; instance=Some inst; \r\n        arguments=Some { Kind = EntityKind.ArgumentList(args) }) ->\r\n      let pb = args |> List.takeWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \r\n      let nb = args |> List.skipWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \r\n      let positionBased = pb |> List.map (getValue ctx) |> Array.ofList\r\n      let nameBased = \r\n        nb |> List.choose(function \r\n          | { Kind = EntityKind.NamedParam(name, value) } -> Some(name.Name, getValue ctx value)\r\n          | _ -> None) |> dict\r\n\r\n      match Types.reduceType inst.Type.Value with \r\n      | Type.Object(FindMethod name (pars, e)) -> \r\n          let args = pars |> List.mapi (fun i (name, _, _) ->\r\n            if i < positionBased.Length then positionBased.[i]\r\n            elif nameBased.ContainsKey(name) then nameBased.[name]\r\n            else (unbox null) )\r\n          Some(evaluateCall e (getValue ctx inst) args)\r\n      | _ -> None\r\n\r\n  | EntityKind.Operator(l, Operator.Power, r) ->\r\n      evaluateExpr [getValue ctx l; getValue ctx r] (function \r\n        | [l; r] -> \r\n            let pow = MemberExpression(IdentifierExpression(\"pow\", None), IdentifierExpression(\"Math\", None), false, None)\r\n            CallExpression(pow, [l; r], None)\r\n        | _ -> failwith \"evaluateEntity: Expected two arguments\") |> Some      \r\n\r\n  | EntityKind.Operator(l, op, r) ->\r\n      evaluateExpr [getValue ctx l; getValue ctx r] (function \r\n        | [l; r] -> \r\n            let op = \r\n              match op with\r\n              | Operator.Equals -> BinaryEqualStrict\r\n              | Operator.Plus -> BinaryPlus\r\n              | Operator.Minus -> BinaryMinus\r\n              | Operator.Multiply -> BinaryMultiply\r\n              | Operator.Divide -> BinaryDivide\r\n              | Operator.GreaterThan -> BinaryGreater\r\n              | Operator.LessThan -> BinaryLess\r\n              | Operator.GreaterThanOrEqual -> BinaryGreaterOrEqual\r\n              | Operator.LessThanOrEqual -> BinaryLessOrEqual\r\n              | Operator.Power -> failwith \"evaluateEntity: Power is not a binary operation\"\r\n            BinaryExpression(op, l, r, None)\r\n        | _ -> failwith \"evaluateEntity: Expected two arguments\") |> Some            \r\n\r\n  | EntityKind.Variable(_, value) ->\r\n      value.Value |> Option.map (fun v -> v.Value)\r\n\r\n  | EntityKind.ArgumentList _\r\n  | EntityKind.NamedMember _ ->\r\n      Some(unbox null)\r\n\r\n  | _ -> \r\n    Log.error(\"interpreter\", \"Cannot evaluate entity: %O\", e)\r\n    None\r\n\r\nlet evaluateEntityTree ctx (e:Entity) = \r\n  let visited = Dictionary<Symbol, bool>()\r\n  let rec loop (e:Entity) = \r\n    if not (visited.ContainsKey(e.Symbol)) && e.Value.IsNone then\r\n      visited.[e.Symbol] <- true\r\n      for e in e.Antecedents do loop e\r\n      ensureValue ctx e\r\n  loop e\r\n  e.Value \r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// \r\n// ------------------------------------------------------------------------------------------------\r\n\r\nlet globalEntity name meta typ expr = \r\n  { Kind = EntityKind.GlobalValue({ Name = name }, expr)\r\n    Symbol = createSymbol()\r\n    Type = Some typ\r\n    Meta = meta\r\n    Value = None\r\n    Errors = [] }\r\n\r\nlet evaluate (globals:seq<Entity>) (e:Entity) = \r\n  Log.trace(\"interpreter\", \"Evaluating entity %s (%O)\", e.Name, e.Kind)\r\n  let ctx = { Globals = dict [ for e in globals -> e.Name, e ] }\r\n  let res = evaluateEntityTree ctx e\r\n  Log.trace(\"interpreter\", \"Evaluated entity %s (%O) = %O\", e.Name, e.Kind, res)\r\n  res"]}