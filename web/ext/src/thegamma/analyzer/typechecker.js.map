{"version":3,"sources":["../../../../src/thegamma/analyzer/typechecker.fs"],"names":[],"mappings":"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","file":"typechecker.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿module TheGamma.TypeChecker\r\n\r\nopen TheGamma\r\nopen TheGamma.Ast\r\nopen TheGamma.Types\r\nopen TheGamma.Common\r\nopen System.Collections.Generic\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// Type checking \r\n// ------------------------------------------------------------------------------------------------\r\n\r\ntype CheckingContext = \r\n  { Errors : ResizeArray<Error<Range>> \r\n    Globals : IDictionary<string, Entity> \r\n    Ranges : IDictionary<Symbol, Range> }\r\n\r\nlet addError ctx ent err = \r\n  ctx.Errors.Add(err ctx.Ranges.[ent.Symbol])\r\n\r\nlet (|FindProperty|_|) (name:Name) { Members = membs } = \r\n  membs |> Seq.tryPick (function \r\n    Member.Property(name=n; typ=r; meta=m) when n = name.Name -> Some(m, r) | _ -> None) \r\n\r\nlet (|FindMethod|_|) (name:Name) { Members = membs } = \r\n  membs |> Seq.tryPick (function \r\n    Member.Method(name=n; arguments=args; meta=m; typ=r) when n = name.Name -> Some (m, args, r) | _ -> None) \r\n\r\n/// Given a list of types, find the most frequent type (using Type.Any as the last resort)\r\nlet inferListType typs = \r\n  typs \r\n  |> List.filter (function Type.Any -> false | _ -> true)\r\n  |> List.groupWith typesEqual\r\n  |> List.map (fun g -> List.head g, List.length g)\r\n  |> List.append [Type.Any, 0]\r\n  |> List.maxBy snd\r\n  |> fst\r\n\r\n/// Resolve type of parameter - parSpec can be Choice1Of2 with \r\n/// parameter name or Choice2Of2 with parameter index.\r\nlet resolveParameterType instTy methName parSpec = \r\n  match instTy with\r\n  | Type.Object(FindMethod methName (_, args, _)) ->\r\n      match parSpec with\r\n      | Choice1Of2 name -> args |> Seq.pick (fun (n, _, t) -> if n = name then Some t else None) // TODO: Can crash\r\n      | Choice2Of2 idx -> let _, _, t = args.[idx] in t // TODO: Can crash\r\n  | _ -> failwith \"resolveParameterType: Instance is not an object\"\r\n\r\n\r\nlet rec checkMethodCall ctx memTy pars argList args = \r\n\r\n  // Split arguments into position & name based and report \r\n  // error if there is non-named argument after named argument\r\n  let positionBased, nameBased = \r\n    let pb = args |> List.takeWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \r\n    let nb = args |> List.skipWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \r\n    pb |> Array.ofList,\r\n    nb |> List.choose (fun arg -> \r\n      match arg.Kind with\r\n      | EntityKind.NamedParam(name, value) -> Some(name.Name, value)\r\n      | _ ->\r\n          Errors.TypeChecker.nameBasedParamMustBeLast |> addError ctx arg\r\n          None ) |> Map.ofList\r\n\r\n  // Match actual arguments with the parameters and report\r\n  // error if non-optional parameter is missing an assignment\r\n  let matchedArguments = \r\n    pars |> List.mapi (fun index (name, optional, typ) ->\r\n      let arg = \r\n        if index < positionBased.Length then Some(positionBased.[index]) \r\n        else Map.tryFind name nameBased \r\n      match arg with\r\n      | Some arg -> name, typ, getType ctx arg, Some arg\r\n      | None when optional -> name, typ, typ, None\r\n      | None ->\r\n          Errors.TypeChecker.parameterMissingValue name |> addError ctx argList\r\n          name, typ, Type.Any, None)\r\n\r\n  // Infer assignments for type parameters from actual arguments\r\n  let tyVars, resTy = match memTy with Type.Forall(tya, resTy) -> tya, resTy | resTy -> [], resTy\r\n  let assigns = \r\n    matchedArguments |> List.collect (fun (name, parTy, argTy, entityOpt) ->\r\n      let assigns, errors = unifyTypes tyVars parTy argTy\r\n      if entityOpt.IsSome then\r\n        for t1, t2 in errors do\r\n          Errors.TypeChecker.incorrectParameterType name parTy argTy t1 t2 |> addError ctx entityOpt.Value \r\n      assigns )\r\n\r\n  // Report errors if we inferred conflicting assignments for one variable\r\n  for _, group in Seq.groupBy fst assigns do\r\n    match List.ofSeq group with\r\n    | (v, t1)::(_::_ as ts) ->\r\n        for _, t in ts do\r\n          Errors.TypeChecker.inferenceConflict v t1 t |> addError ctx argList\r\n    | _ -> ()\r\n  \r\n  // Substitute in the return type\r\n  let res = substituteTypes (Map.ofList assigns) resTy\r\n  //printfn \"Result of call: %A\" res\r\n  res\r\n  \r\n\r\n/// Get type of an entity and record errors generated when type checking this entity\r\nand getType ctx (e:Entity) = \r\n  if e.Type.IsNone then \r\n    let errorCount = ctx.Errors.Count\r\n    e.Type <- Some (typeCheckEntity ctx e)\r\n    e.Errors <- [ for i in errorCount .. ctx.Errors.Count - 1 -> ctx.Errors.[i] ]\r\n  e.Type.Value\r\n\r\n/// Type check entity - assumes that all antecedents of the entity \r\n/// have been reduced to non-delayed type before\r\nand typeCheckEntity ctx (e:Entity) = \r\n  match e.Kind with\r\n  | EntityKind.GlobalValue(name, _) ->\r\n      if not (ctx.Globals.ContainsKey(name.Name)) then\r\n        Errors.TypeChecker.variableNotInScope name.Name |> addError ctx e\r\n        Type.Any\r\n      else\r\n        getType ctx ctx.Globals.[name.Name]\r\n\r\n  | EntityKind.Variable(_, inst) ->\r\n      getType ctx inst      \r\n\r\n  | EntityKind.ChainElement(true, name, ident, Some inst, _) ->\r\n      match reduceType (getType ctx inst) with \r\n      | Type.Any -> Type.Any\r\n      | Type.Object(FindProperty name (meta, resTyp)) -> \r\n          e.Meta <- meta\r\n          resTyp\r\n      | Type.Object { Members = members } ->\r\n          Errors.TypeChecker.propertyMissing name.Name members |> addError ctx ident\r\n          Type.Any\r\n      | typ ->\r\n          Errors.TypeChecker.notAnObject name.Name typ |> addError ctx inst\r\n          Type.Any\r\n\r\n  | EntityKind.ChainElement(false, name, ident, Some inst, Some ({ Kind = EntityKind.ArgumentList(ents) } as arglist)) ->\r\n      match reduceType (getType ctx inst) with \r\n      | Type.Any -> Type.Any\r\n      | Type.Object(FindMethod name (meta, args, resTyp)) ->  \r\n          e.Meta <- meta\r\n          checkMethodCall ctx resTyp args arglist ents\r\n      | Type.Object { Members = members } ->\r\n          Errors.TypeChecker.methodMissing name.Name members |> addError ctx ident\r\n          Type.Any\r\n      | typ ->\r\n          Errors.TypeChecker.notAnObject name.Name typ |> addError ctx inst\r\n          Type.Any\r\n\r\n  | EntityKind.ChainElement(_, name, ident, None, _) ->\r\n      Errors.TypeChecker.callMissingInstance name.Name |> addError ctx ident\r\n      Type.Any\r\n\r\n  | EntityKind.ChainElement(false, name, _, _, _) ->\r\n      failwith (sprintf \"typeCheckEntity: Call to %s is missing argument list!\" name.Name)\r\n      \r\n  | EntityKind.Operator(l, operator, r) ->      \r\n      [l; r] |> List.iteri (fun idx operand ->\r\n        let typ = getType ctx operand \r\n        if not (typesEqual typ (Type.Primitive PrimitiveType.Number)) then\r\n          Errors.TypeChecker.numericOperatorExpectsNumbers operator idx typ |> addError ctx operand )\r\n      Type.Primitive PrimitiveType.Number\r\n\r\n  | EntityKind.List(elems) ->      \r\n      let typs = elems |> List.map (getType ctx)\r\n      let typ = inferListType typs \r\n      for a in elems do \r\n        let elty = getType ctx a\r\n        if not (typesEqual typ elty) then\r\n          Errors.TypeChecker.listElementTypeDoesNotMatch typ elty |> addError ctx a\r\n      Type.List typ\r\n\r\n  | EntityKind.Binding(name, { Kind = EntityKind.CallSite(inst, methName, parSpec) }) ->\r\n      // Binding node is used to resolve type of a lambda function variable. \r\n      // Its antecedent is `EntityKind.CallSite` containing reference to the method around it - \r\n      // assuming lambda appears in something like: `foo(10, fun x -> ...)`\r\n      match resolveParameterType (reduceType (getType ctx inst)) methName parSpec with\r\n      | Type.Function([tin], _) -> tin\r\n      | _ -> failwith \"typeCheckEntity: Expected parameter of function type\"\r\n\r\n  | EntityKind.Binding(name, _) ->\r\n      failwith (sprintf \"typeCheckEntity: Variable binding %s is missing call site!\" name.Name)\r\n\r\n  | EntityKind.Function(var, body) ->\r\n      Type.Function([getType ctx var], getType ctx body)\r\n\r\n  // Entities with primitive types\r\n  | EntityKind.Constant(Constant.Number _) -> Type.Primitive(PrimitiveType.Number)\r\n  | EntityKind.Constant(Constant.String _) -> Type.Primitive(PrimitiveType.String)\r\n  | EntityKind.Constant(Constant.Boolean _) -> Type.Primitive(PrimitiveType.Bool)\r\n  | EntityKind.Constant(Constant.Empty) -> Type.Any\r\n\r\n  // Entities that do not have a real type\r\n  | EntityKind.Root -> Type.Any\r\n  | EntityKind.LetCommand _ -> Type.Any\r\n  | EntityKind.RunCommand _ -> Type.Any\r\n  | EntityKind.ArgumentList _ -> Type.Any\r\n  | EntityKind.NamedParam _ -> Type.Any\r\n  | EntityKind.NamedMember _ -> Type.Any\r\n  | EntityKind.CallSite _ -> Type.Any\r\n  | EntityKind.Program _ -> Type.Any\r\n\r\n\r\n/// Perform type applications & evaluate delayed types\r\nlet rec evaluateDelayedType topLevel (t:Type) = async {\r\n  match t with\r\n  | Type.App(t, args) ->\r\n      let! t = evaluateDelayedType topLevel t \r\n      return Type.App(t, args)\r\n  | Type.Forall(vars, t) ->\r\n      let! t = evaluateDelayedType topLevel t \r\n      return Type.Forall(vars, t)  \r\n  | Type.Object(obj) when topLevel ->\r\n      let! members = obj.Members |> Async.Array.map (fun m -> async {\r\n        match m with\r\n        | Member.Method(n, args, typ, doc, e) -> \r\n            let! args = args |> Async.map (fun (n, opt, t) -> async {\r\n              let! t = evaluateDelayedType false t\r\n              return n, opt, t }) \r\n            return Member.Method(n, args, typ, doc, e)\r\n        | prop -> return prop })\r\n      return Type.Object { obj with Members = members }\r\n  | Type.Function(t1s, t2) ->\r\n      let! t2 = evaluateDelayedType topLevel t2\r\n      let! t1s = Async.map (evaluateDelayedType topLevel) t1s\r\n      return Type.Function(t1s, t2)\r\n  | Type.List(t) ->\r\n      let! t = evaluateDelayedType topLevel t\r\n      return Type.List(t)\r\n  | Type.Delayed(_, f) ->\r\n      let! t = Async.AwaitFuture f\r\n      return! evaluateDelayedType topLevel t\r\n  | t -> return t }\r\n\r\n\r\n/// Type check entity & return its type. This first recursively processes\r\n/// all antecedants to make sure that no antecedant is delayed  \r\n/// (this way, `getType` can be ordinary synchronouus function)\r\nlet typeCheckEntityAsync ctx (e:Entity) = async {\r\n  let visited = Dictionary<Symbol, bool>()\r\n\r\n  let rec loop e = async {\r\n    let isGlobal = match e.Kind with EntityKind.GlobalValue _ -> true | _ -> false\r\n    if not (visited.ContainsKey(e.Symbol)) && (isGlobal || e.Type.IsNone) then\r\n      visited.[e.Symbol] <- true\r\n      for a in e.Antecedents do\r\n        do! loop a \r\n      Log.trace(\"typechecker\", \"Type of entity '%s' (%O) is: %O\", e.Name, e.Kind, getType ctx e)\r\n      let! t = evaluateDelayedType true (getType ctx e)\r\n      Log.trace(\"typechecker\", \"Type of entity '%s' (%O) reduced to: %O\", e.Name, e.Kind, t)\r\n      e.Type <- Some t }\r\n\r\n  do! loop e\r\n  return getType ctx e }\r\n\r\n\r\n// ------------------------------------------------------------------------------------------------\r\n// User friendly entry point\r\n// ------------------------------------------------------------------------------------------------\r\n\r\nlet collectTypeErrors (entity:Entity) = \r\n  let errors = ResizeArray<_>()\r\n  let visited = Dictionary<Symbol, bool>()\r\n  let rec loop e = \r\n    if not (visited.ContainsKey e.Symbol) then\r\n      visited.[e.Symbol] <- true\r\n      for e in e.Antecedents do loop e\r\n      errors.AddRange(e.Errors)\r\n  loop entity\r\n  errors.ToArray()\r\n\r\nlet typeCheckProgram (globals:Entity list) (bound:Binder.BindingResult) prog = async {\r\n  Log.trace(\"typechecker\", \"Type checking program\")\r\n  try\r\n    let rangeLookup = dict [ for r, e in bound.Entities -> e.Symbol, r ]\r\n    let vars = dict [ for e in globals -> e.Name, e ]\r\n    let ctx = { Globals = vars; Errors = ResizeArray<_>(); Ranges = rangeLookup }\r\n    let! _ = typeCheckEntityAsync ctx prog \r\n    Log.trace(\"typechecker\", \"Completed type checking\")\r\n  with e ->\r\n    Log.exn(\"typechecker\", \"Type checking program failed: %O\", e) }"]}