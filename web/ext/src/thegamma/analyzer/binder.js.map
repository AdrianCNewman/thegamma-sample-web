{"version":3,"sources":["../../../../src/thegamma/analyzer/binder.fs"],"names":[],"mappings":"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","file":"binder.js","sourceRoot":"C:/Tomas/Public/thegamma/thegamma-script/out/src/thegamma","sourcesContent":["ï»¿// ------------------------------------------------------------------------------------------------\r\n// Binder attaches `Entity` objects to `Node` objects produced by the parser\r\n// Entities are reused when possible and contain inferred types etc.\r\n// ------------------------------------------------------------------------------------------------\r\nmodule TheGamma.Binder\r\n\r\nopen TheGamma.Ast\r\nopen TheGamma.Common\r\n\r\n/// Represents case of the EntityKind union\r\ntype EntityCode = int\r\n\r\n/// As we bind, we keep root entity, current scope & variables in scope\r\ntype BindingContext = \r\n  { Variables : Map<Name, Entity>  \r\n    GlobalValues : Map<Name, Entity>\r\n    Root : Entity\r\n    /// Table with previously created entities. This is a mutable mapping from \r\n    /// list of symbols (antecedent entities) together with entity kind & name\r\n    /// to the actual entity. Antecedents capture dependencies (if dependency \r\n    /// changed, we need to recreate the entity that depends on them)\r\n    Table : ListDictionary<Symbol, Map<EntityCode * string, Entity>> \r\n    /// Collects all bound entities and their ranges\r\n    Bound : ResizeArray<Range * Entity> }\r\n\r\n/// Represents result of binding syntax tree to entities \r\n/// (provides access to all bound entities & children lookup function)\r\ntype BindingResult(ents:(Range * Entity)[]) = \r\n  let childrenLookup = \r\n    let res = System.Collections.Generic.Dictionary<Symbol, ResizeArray<Entity>>()\r\n    let add a e = \r\n      if not (res.ContainsKey(a)) then res.Add(a, ResizeArray())\r\n      res.[a].Add(e)\r\n    for _, e in ents do\r\n      for a in e.Antecedents do\r\n        add a.Symbol e\r\n    res \r\n  member x.Entities = ents\r\n  member x.GetChildren(ent) = \r\n    match childrenLookup.TryGetValue(ent.Symbol) with true, res -> res.ToArray() | _ -> [||]\r\n\r\n/// Lookup entity (if it can be reused) or create & cache a new one\r\nlet bindEntity ctx kind =\r\n  let code, antecedents, name = entityCodeNameAndAntecedents kind\r\n  let symbols = ctx.Root::antecedents |> List.map (fun a -> a.Symbol)\r\n  let nestedDict = \r\n    match ListDictionary.tryFind symbols ctx.Table with\r\n    | None -> Map.empty\r\n    | Some res -> res\r\n  if nestedDict.ContainsKey (code, name) then \r\n    Log.trace(\"binder\", \"Cached: binding %s %s\", formatEntityKind kind, name)\r\n    nestedDict.[code, name]\r\n  else\r\n    Log.trace(\"binder\", \"New: binding %s %s\", formatEntityKind kind, name)\r\n    let symbol = createSymbol ()\r\n    let entity = { Kind = kind; Symbol = symbol; Type = None; Errors = []; Meta = []; Value = None }\r\n    ListDictionary.set symbols (Map.add (code, name) entity nestedDict) ctx.Table\r\n    entity    \r\n\r\n/// Assign entity to a node in parse tree\r\nlet setEntity ctx node entity = \r\n  ctx.Bound.Add(node.Range, entity)\r\n  node.Entity <- Some entity\r\n  entity\r\n\r\n/// Bind entities to expressions in the parse tree\r\n/// (See `EntityKind` for explanation of how the entity tree looks like)\r\nlet rec bindExpression callSite ctx node = \r\n  let bindCallArgExpression site = bindExpression (Some site)\r\n  let bindExpression = bindExpression None\r\n  match node.Node with\r\n  | Expr.Variable(name) ->\r\n      match ctx.Variables.TryFind name.Node with \r\n      | Some decl -> bindEntity ctx (EntityKind.Variable(name.Node, decl)) |> setEntity ctx node\r\n      | _ ->\r\n      match ctx.GlobalValues.TryFind name.Node with \r\n      | Some glob -> glob |> setEntity ctx node\r\n      | None -> bindEntity ctx (EntityKind.GlobalValue(name.Node, None)) |> setEntity ctx node\r\n\r\n  | Expr.Call(instExpr, name, argsNode) ->\r\n      // Bind instance & create call site that depends on it\r\n      let inst = defaultArg (Option.map (bindExpression ctx) instExpr) ctx.Root\r\n      let site arg = bindEntity ctx (EntityKind.CallSite(inst, name.Node, arg))\r\n      // Bind arguments - which depend on the call site\r\n      let args = argsNode.Node |> List.mapi (fun idx arg -> \r\n        let site = site (match arg.Name with Some n -> Choice1Of2 n.Node.Name | _ -> Choice2Of2 idx)\r\n        let expr = bindCallArgExpression site ctx arg.Value\r\n        match arg.Name with \r\n        | Some n -> bindEntity ctx (EntityKind.NamedParam(n.Node, expr)) |> setEntity ctx n\r\n        | None -> expr)\r\n      let args = bindEntity ctx (EntityKind.ArgumentList(args)) |> setEntity ctx argsNode\r\n      let named = bindEntity ctx (EntityKind.NamedMember(name.Node, inst)) |> setEntity ctx name\r\n      bindEntity ctx (EntityKind.ChainElement(false, name.Node, named, Some inst, Some args)) |> setEntity ctx node \r\n\r\n  | Expr.Property(expr, name) ->\r\n      let inst = bindExpression ctx expr\r\n      let named = bindEntity ctx (EntityKind.NamedMember(name.Node, inst)) |> setEntity ctx name      \r\n      bindEntity ctx (EntityKind.ChainElement(true, name.Node, named, Some inst, None)) |> setEntity ctx node \r\n\r\n  | Expr.Binary(l, op, r) ->\r\n      let lentity = bindExpression ctx l\r\n      let rentity = bindExpression ctx r\r\n      bindEntity ctx (EntityKind.Operator(lentity, op.Node, rentity)) |> setEntity ctx node\r\n\r\n  | Expr.List(els) ->\r\n      let entities = els |> List.map (bindExpression ctx)      \r\n      bindEntity ctx (EntityKind.List(entities)) |> setEntity ctx node\r\n\r\n  | Expr.Function(v, e) ->\r\n      let callSite = match callSite with Some s -> s | None -> failwith \"bindExpression: Function missing call site\"\r\n      let var = bindEntity ctx (EntityKind.Binding(v.Node, callSite)) |> setEntity ctx v\r\n      let body = bindExpression { ctx with Variables = Map.add v.Node var ctx.Variables } e\r\n      bindEntity ctx (EntityKind.Function(var, body)) |> setEntity ctx node\r\n\r\n  | Expr.Boolean b -> bindEntity ctx (EntityKind.Constant(Constant.Boolean b)) |> setEntity ctx node\r\n  | Expr.String s -> bindEntity ctx (EntityKind.Constant(Constant.String s)) |> setEntity ctx node\r\n  | Expr.Number n -> bindEntity ctx (EntityKind.Constant(Constant.Number n)) |> setEntity ctx node\r\n  | Expr.Empty -> bindEntity ctx (EntityKind.Constant Constant.Empty) |> setEntity ctx node\r\n\r\n/// Bind entities to a command in a parse tree. The handling of `let` is similar\r\n/// to the handling of lambda abstraction. This adds variables to context - we ignore\r\n/// bound entities, because nothing depends on it (except via variables)\r\nlet bindCommand ctx node =\r\n  match node.Node with\r\n  | Command.Let(v, e) ->\r\n      let body = bindExpression None ctx e \r\n      let var = bindEntity ctx (EntityKind.Variable(v.Node, body)) |> setEntity ctx v\r\n      let node = bindEntity ctx (EntityKind.LetCommand(var, body)) |> setEntity ctx node\r\n      { ctx with Variables = Map.add v.Node var ctx.Variables }, node\r\n\r\n  | Command.Expr(e) ->\r\n      let body = bindExpression None ctx e \r\n      let node = bindEntity ctx (EntityKind.RunCommand(body)) |> setEntity ctx node\r\n      ctx, node\r\n\r\n/// Bind entities to all nodes in the program\r\nlet bindProgram ctx (program:Program) =\r\n  ctx.Bound.Clear()\r\n  let _, ents = \r\n    program.Body.Node |> List.fold (fun (ctx, nodes) cmd -> \r\n      let ctx, node = bindCommand ctx cmd\r\n      ctx, node::nodes) (ctx, [])  \r\n  bindEntity ctx (EntityKind.Program(ents)),\r\n  BindingResult(ctx.Bound.ToArray())\r\n  \r\n/// Create a new binding context - this stores cached entities\r\nlet createContext (globals:list<Entity>) name =\r\n  let root = \r\n    { Kind = EntityKind.Root; Errors = []; Symbol = createSymbol(); Type = None; Meta = []; Value = None }\r\n  { Table = System.Collections.Generic.Dictionary<_, _>(); \r\n    Bound = ResizeArray<_>(); Variables = Map.empty; \r\n    GlobalValues = Map.ofList [ for e in globals -> { Name = e.Name }, e ]\r\n    Root = root }\r\n"]}